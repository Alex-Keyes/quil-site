{{:name org.processingjs.Processing, :macros false} {:cache {:use-macros nil, :excludes #{}, :name org.processingjs.Processing, :imports nil, :requires nil, :uses nil, :defs {}, :require-macros nil, :doc nil}, :source "goog.provide(\"org.processingjs.Processing\");\n"}, {:name quil.sketch, :macros false} {:cache {:use-macros nil, :excludes #{}, :name quil.sketch, :imports nil, :requires {goog.dom goog.dom, dom goog.dom, u quil.util, EventType goog.events.EventType, quil.middlewares.deprecated-options quil.middlewares.deprecated-options, do quil.middlewares.deprecated-options, goog.events.EventType goog.events.EventType, events goog.events, goog.events goog.events, quil.util quil.util}, :uses nil, :defs {current-applet {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.sketch/current-applet, :meta {}, :method-params ([])}, make-sketch {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.sketch/make-sketch, :meta {}, :method-params ([options])}, sketch {:variadic true, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.sketch/sketch, :meta {:top-fn {:variadic true, :max-fixed-arity 0, :method-params [(opts)], :arglists ([& opts]), :arglists-meta (nil)}}, :method-params [(opts)]}, bind-handlers {:variadic false, :protocol-impl nil, :max-fixed-arity 2, :fn-var true, :name quil.sketch/bind-handlers, :meta {}, :method-params ([prc opts])}, empty-body? {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.sketch/empty-body?, :meta {}, :method-params ([])}, rendering-modes {:name quil.sketch/rendering-modes, :meta {}}, size {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.sketch/size, :meta {:top-fn {:variadic false, :max-fixed-arity 3, :method-params ([width height] [width height mode]), :arglists ([width height] [width height mode]), :arglists-meta (nil nil)}}, :method-params ([width height] [width height mode])}, add-sketch-to-init-list {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.sketch/add-sketch-to-init-list, :meta {}, :method-params ([sk])}, sketch-init-list {:name quil.sketch/sketch-init-list, :meta {}}, init-sketches {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.sketch/init-sketches, :meta {}, :method-params ([])}, destroy-previous-sketch {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.sketch/destroy-previous-sketch, :meta {}, :method-params ([host-elem])}, resolve-renderer {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.sketch/resolve-renderer, :meta {}, :method-params ([mode])}, *applet* {:name quil.sketch/*applet*, :meta {}}, add-canvas {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.sketch/add-canvas, :meta {}, :method-params ([canvas-id])}}, :require-macros {quil.sketch quil.sketch, u quil.util, quil.util quil.util}, :cljs.analyzer/constants {:seen #{:features :key-typed :mouse-clicked :mouse-released :fn :mouse-exited :java2d :mouse-wheel :keyPressed :opengl :mouse-moved :mouseOut :settings :mouseScrolled :mouseDragged :renderer :size :setup :mouse-pressed :middleware :global-key-events :host :mouse-entered :key-pressed :key-released :keyReleased :mouseClicked :p2d :mouseReleased :mousePressed :mouseMoved :mouseOver :host-id :keyTyped :draw :p3d :mouse-dragged}, :order [:java2d :p2d :p3d :opengl :keyPressed :mouseOut :mouseScrolled :mouseDragged :setup :keyReleased :mouseClicked :mouseReleased :mousePressed :mouseMoved :mouseOver :keyTyped :draw :key-pressed :mouse-exited :mouse-wheel :mouse-dragged :key-released :mouse-clicked :mouse-released :mouse-pressed :mouse-moved :mouse-entered :key-typed :size :middleware :renderer :features :settings :global-key-events :host :host-id :fn]}, :doc nil}, :source ""}, {:name quil.util, :macros false} {:cache {:use-macros nil, :excludes #{}, :name quil.util, :imports nil, :requires {cstr clojure.string, clojure.string clojure.string}, :uses nil, :defs {clj-compilation? {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.util/clj-compilation?, :meta {}, :method-params ([])}, make-quil-constant-map {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.util/make-quil-constant-map, :meta {}, :method-params ([target const-map-name const-map])}, print-definition-list {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.util/print-definition-list, :meta {}, :method-params ([definitions])}, generate-quil-constants {:macro true, :variadic true, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.util/generate-quil-constants, :meta {:macro true, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env target opts)], :arglists ([&form &env target & opts]), :arglists-meta (nil)}}, :method-params [(&form &env target opts)]}, resolve-constant-key {:variadic false, :protocol-impl nil, :max-fixed-arity 2, :fn-var true, :name quil.util/resolve-constant-key, :meta {}, :method-params ([key mappings])}, no-fn {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.util/no-fn, :meta {}, :method-params ([])}, prepare-quil-clj-constants {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.util/prepare-quil-clj-constants, :meta {}, :method-params ([constants])}, prepare-quil-cljs-constants {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.util/prepare-quil-cljs-constants, :meta {}, :method-params ([constants])}, length-of-longest-key {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.util/length-of-longest-key, :meta {}, :method-params ([m])}, gen-padding {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.util/gen-padding, :meta {:top-fn {:variadic false, :max-fixed-arity 3, :method-params ([len] [len pad] [s len pad]), :arglists ([len] [len pad] [s len pad]), :arglists-meta (nil nil nil)}}, :method-params ([len] [len pad] [s len pad])}, prepare-quil-name {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.util/prepare-quil-name, :meta {}, :method-params ([const-keyword])}}, :require-macros nil, :cljs.analyzer/constants {:seen #{:else aget js/Processing.prototype.PConstants def :clj do}, :order [:else aget js/Processing.prototype.PConstants def :clj do]}, :doc "Utility fns"}, :source "goog.provide(\"quil.util\");\n/**\n * Function that does nothing.\n */\nquil.util.no_fn = (function quil$util$no_fn(){\nreturn null;\n});\n/**\n * Returns the val associated with key in mappings or key directly if it\n *   is one of the vals in mappings. Otherwise throws an exception.\n */\nquil.util.resolve_constant_key = (function quil$util$resolve_constant_key(key,mappings){\nif(cljs.core.truth_(cljs.core.get.call(null,mappings,key))){\nreturn cljs.core.get.call(null,mappings,key);\n} else {\nif(cljs.core.truth_(cljs.core.some.call(null,cljs.core.PersistentHashSet.fromArray([key], true),cljs.core.vals.call(null,mappings)))){\nreturn key;\n} else {\nthrow (new Error([cljs.core.str(\"Expecting a keyword, got: \"),cljs.core.str(key),cljs.core.str(\". Expected one of: \"),cljs.core.str(cljs.core.vec.call(null,cljs.core.sort.call(null,cljs.core.keys.call(null,mappings))))].join('')));\n\n}\n}\n});\n/**\n * Returns the length of the longest key of map m. Assumes m's keys are strings\n * and returns 0 if map is empty:\n * (length-of-longest-key {\"foo\" 1 \"barr\" 2 \"bazzz\" 3}) ;=> 5\n * (length-of-longest-key {}) ;=> 0\n */\nquil.util.length_of_longest_key = (function quil$util$length_of_longest_key(m){\nvar or__10278__auto__ = cljs.core.last.call(null,cljs.core.sort.call(null,cljs.core.map.call(null,(function (p1__1_SHARP_){\nreturn p1__1_SHARP_.length();\n}),cljs.core.keys.call(null,m))));\nif(cljs.core.truth_(or__10278__auto__)){\nreturn or__10278__auto__;\n} else {\nreturn (0);\n}\n});\n/**\n * Generates a padding string starting concatting s with len times pad:\n * (gen-padding \"\" 5 \"b\") ;=> \"bbbbb\"\n * May be called without starting string s in which case it defaults to the\n * empty string and also without pad in which case it defaults to a single space\n */\nquil.util.gen_padding = (function quil$util$gen_padding(var_args){\nvar args24 = [];\nvar len__11134__auto___27 = arguments.length;\nvar i__11135__auto___28 = (0);\nwhile(true){\nif((i__11135__auto___28 < len__11134__auto___27)){\nargs24.push((arguments[i__11135__auto___28]));\n\nvar G__29 = (i__11135__auto___28 + (1));\ni__11135__auto___28 = G__29;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__26 = args24.length;\nswitch (G__26) {\ncase (1):\nreturn quil.util.gen_padding.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.util.gen_padding.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.util.gen_padding.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args24.length)].join('')));\n\n}\n});\n\nquil.util.gen_padding.cljs$core$IFn$_invoke$arity$1 = (function (len){\nreturn quil.util.gen_padding.call(null,\"\",len,\" \");\n});\n\nquil.util.gen_padding.cljs$core$IFn$_invoke$arity$2 = (function (len,pad){\nreturn quil.util.gen_padding.call(null,\"\",len,pad);\n});\n\nquil.util.gen_padding.cljs$core$IFn$_invoke$arity$3 = (function (s,len,pad){\nif((len > (0))){\nreturn quil.util.gen_padding.call(null,[cljs.core.str(s),cljs.core.str(pad)].join(''),(len - (1)),pad);\n} else {\nreturn s;\n}\n});\n\nquil.util.gen_padding.cljs$lang$maxFixedArity = (3);\nquil.util.print_definition_list = (function quil$util$print_definition_list(definitions){\nvar longest_key = quil.util.length_of_longest_key.call(null,definitions);\nreturn cljs.core.dorun.call(null,cljs.core.map.call(null,((function (longest_key){\nreturn (function (p__33){\nvar vec__34 = p__33;\nvar k = cljs.core.nth.call(null,vec__34,(0),null);\nvar v = cljs.core.nth.call(null,vec__34,(1),null);\nvar len = k.length();\nvar diff = (longest_key - len);\nvar pad = quil.util.gen_padding.call(null,diff);\nreturn cljs.core.println.call(null,k,pad,\"- \",v);\n});})(longest_key))\n,definitions));\n});\nquil.util.clj_compilation_QMARK_ = (function quil$util$clj_compilation_QMARK_(){\nreturn false;\n});\nquil.util.prepare_quil_name = (function quil$util$prepare_quil_name(const_keyword){\nreturn clojure.string.replace.call(null,clojure.string.upper_case.call(null,cljs.core.name.call(null,const_keyword)),/-/,\"_\");\n});\nquil.util.prepare_quil_clj_constants = (function quil$util$prepare_quil_clj_constants(constants){\nreturn cljs.core.into.call(null,cljs.core.PersistentArrayMap.EMPTY,cljs.core.map.call(null,(function (p1__2_SHARP_){\nreturn (new cljs.core.PersistentVector(null,(2),(5),cljs.core.PersistentVector.EMPTY_NODE,[p1__2_SHARP_,cljs.core.symbol.call(null,[cljs.core.str(\"PConstants/\"),cljs.core.str(quil.util.prepare_quil_name.call(null,p1__2_SHARP_))].join(''))],null));\n}),constants));\n});\nquil.util.prepare_quil_cljs_constants = (function quil$util$prepare_quil_cljs_constants(constants){\nreturn cljs.core.into.call(null,cljs.core.PersistentArrayMap.EMPTY,cljs.core.map.call(null,(function (p1__3_SHARP_){\nreturn (new cljs.core.PersistentVector(null,(2),(5),cljs.core.PersistentVector.EMPTY_NODE,[p1__3_SHARP_,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"aget\",\"aget\",(1491056546),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"js\",\"Processing.prototype.PConstants\",\"js/Processing.prototype.PConstants\",(2034048972),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,quil.util.prepare_quil_name.call(null,p1__3_SHARP_))))],null));\n}),constants));\n});\nquil.util.make_quil_constant_map = (function quil$util$make_quil_constant_map(target,const_map_name,const_map){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"def\",\"def\",(597100991),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,const_map_name),cljs.core._conj.call(null,cljs.core.List.EMPTY,((cljs.core._EQ_.call(null,target,new cljs.core.Keyword(null,\"clj\",\"clj\",(-660495428))))?quil.util.prepare_quil_clj_constants.call(null,const_map):quil.util.prepare_quil_cljs_constants.call(null,const_map)))));\n});\nquil.util.generate_quil_constants = (function quil$util$generate_quil_constants(var_args){\nvar args__11136__auto__ = [];\nvar len__11134__auto___39 = arguments.length;\nvar i__11135__auto___40 = (0);\nwhile(true){\nif((i__11135__auto___40 < len__11134__auto___39)){\nargs__11136__auto__.push((arguments[i__11135__auto___40]));\n\nvar G__41 = (i__11135__auto___40 + (1));\ni__11135__auto___40 = G__41;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__11137__auto__ = ((((3) < args__11136__auto__.length))?(new cljs.core.IndexedSeq(args__11136__auto__.slice((3)),(0),null)):null);\nreturn quil.util.generate_quil_constants.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__11137__auto__);\n});\n\nquil.util.generate_quil_constants.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,target,opts){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"do\",\"do\",(1686842252),null)),cljs.core.map.call(null,(function (p1__4_SHARP_){\nreturn quil.util.make_quil_constant_map.call(null,target,cljs.core.first.call(null,p1__4_SHARP_),cljs.core.second.call(null,p1__4_SHARP_));\n}),cljs.core.partition.call(null,(2),opts))));\n});\n\nquil.util.generate_quil_constants.cljs$lang$maxFixedArity = (3);\n\nquil.util.generate_quil_constants.cljs$lang$applyTo = (function (seq35){\nvar G__36 = cljs.core.first.call(null,seq35);\nvar seq35__$1 = cljs.core.next.call(null,seq35);\nvar G__37 = cljs.core.first.call(null,seq35__$1);\nvar seq35__$2 = cljs.core.next.call(null,seq35__$1);\nvar G__38 = cljs.core.first.call(null,seq35__$2);\nvar seq35__$3 = cljs.core.next.call(null,seq35__$2);\nreturn quil.util.generate_quil_constants.cljs$core$IFn$_invoke$arity$variadic(G__36,G__37,G__38,seq35__$3);\n});\n\nquil.util.generate_quil_constants.cljs$lang$macro = true;\n"}, {:name quil.sketch, :macros true} {:cache {:use-macros nil, :excludes #{}, :name quil.sketch$macros, :imports nil, :requires nil, :uses nil, :defs {wrap-fns {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.sketch$macros/wrap-fns, :meta {}, :method-params ([opts])}, defsketch {:macro true, :variadic true, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.sketch$macros/defsketch, :meta {:macro true, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env app-name options)], :arglists ([&form &env app-name & options]), :arglists-meta (nil)}}, :method-params [(&form &env app-name options)]}, with-sketch {:macro true, :variadic true, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.sketch$macros/with-sketch, :meta {:macro true, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env applet body)], :arglists ([&form &env applet & body]), :arglists-meta (nil)}}, :method-params [(&form &env applet body)]}}, :require-macros nil, :cljs.analyzer/constants {:seen #{p1__5__6__auto__ & :features fn? quil.sketch/*applet* = :fn args fn do when-not defn :export if :host some fn* :host-id :no-start binding quil.sketch/add-sketch-to-init-list apply quil.sketch/sketch}, :order [binding quil.sketch/*applet* if fn? fn & args apply :host do defn :export quil.sketch/sketch when-not some fn* p1__5__6__auto__ = :no-start :features quil.sketch/add-sketch-to-init-list :fn :host-id]}, :doc nil}, :source "goog.provide(\"quil.sketch$macros\");\nquil.sketch$macros.with_sketch = (function quil$sketch$macros$with_sketch(var_args){\nvar args__11136__auto__ = [];\nvar len__11134__auto___46 = arguments.length;\nvar i__11135__auto___47 = (0);\nwhile(true){\nif((i__11135__auto___47 < len__11134__auto___46)){\nargs__11136__auto__.push((arguments[i__11135__auto___47]));\n\nvar G__48 = (i__11135__auto___47 + (1));\ni__11135__auto___47 = G__48;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__11137__auto__ = ((((3) < args__11136__auto__.length))?(new cljs.core.IndexedSeq(args__11136__auto__.slice((3)),(0),null)):null);\nreturn quil.sketch$macros.with_sketch.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__11137__auto__);\n});\n\nquil.sketch$macros.with_sketch.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,applet,body){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"binding\",\"binding\",(-2114503176),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.sketch\",\"*applet*\",\"quil.sketch/*applet*\",(-1126699869),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,applet))))),body));\n});\n\nquil.sketch$macros.with_sketch.cljs$lang$maxFixedArity = (3);\n\nquil.sketch$macros.with_sketch.cljs$lang$applyTo = (function (seq42){\nvar G__43 = cljs.core.first.call(null,seq42);\nvar seq42__$1 = cljs.core.next.call(null,seq42);\nvar G__44 = cljs.core.first.call(null,seq42__$1);\nvar seq42__$2 = cljs.core.next.call(null,seq42__$1);\nvar G__45 = cljs.core.first.call(null,seq42__$2);\nvar seq42__$3 = cljs.core.next.call(null,seq42__$2);\nreturn quil.sketch$macros.with_sketch.cljs$core$IFn$_invoke$arity$variadic(G__43,G__44,G__45,seq42__$3);\n});\n\nquil.sketch$macros.with_sketch.cljs$lang$macro = true;\n/**\n * Wrap fns allows dynamic redefinition of function such as draw, update\n *   in cljs. This is achieved by wrapping all provided functions to\n *   anonymous functions such that 'my-draw' function turns into\n *   (fn [& args] (apply my-draw args)). This adds a level of indirection\n *   so that when quil calls draw, it invokes anonymous function which in\n *   turn always calls my-draw by name and if you redefine - new version\n *   will be used. Hence we need this cryptic macro.\n */\nquil.sketch$macros.wrap_fns = (function quil$sketch$macros$wrap_fns(opts){\nreturn cljs.core.into.call(null,cljs.core.PersistentArrayMap.EMPTY,(function (){var iter__10859__auto__ = (function quil$sketch$macros$wrap_fns_$_iter__57(s__58){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar s__58__$1 = s__58;\nwhile(true){\nvar temp__10134__auto__ = cljs.core.seq.call(null,s__58__$1);\nif(temp__10134__auto__){\nvar s__58__$2 = temp__10134__auto__;\nif(cljs.core.chunked_seq_QMARK_.call(null,s__58__$2)){\nvar c__10857__auto__ = cljs.core.chunk_first.call(null,s__58__$2);\nvar size__10858__auto__ = cljs.core.count.call(null,c__10857__auto__);\nvar b__60 = cljs.core.chunk_buffer.call(null,size__10858__auto__);\nif((function (){var i__59 = (0);\nwhile(true){\nif((i__59 < size__10858__auto__)){\nvar vec__63 = cljs.core._nth.call(null,c__10857__auto__,i__59);\nvar k = cljs.core.nth.call(null,vec__63,(0),null);\nvar v = cljs.core.nth.call(null,vec__63,(1),null);\ncljs.core.chunk_append.call(null,b__60,(((v instanceof cljs.core.Symbol))?new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [k,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"if\",\"if\",(1181717262),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"fn?\",\"fn?\",(1820990818),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,v)))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"fn\",\"fn\",(465265323),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"&\",\"&\",(-2144855648),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"args\",\"args\",(-1338879193),null)))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"apply\",\"apply\",(-1334050276),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,v),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"args\",\"args\",(-1338879193),null)))))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,v)))], null):new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [k,v], null)));\n\nvar G__65 = (i__59 + (1));\ni__59 = G__65;\ncontinue;\n} else {\nreturn true;\n}\nbreak;\n}\n})()){\nreturn cljs.core.chunk_cons.call(null,cljs.core.chunk.call(null,b__60),quil$sketch$macros$wrap_fns_$_iter__57.call(null,cljs.core.chunk_rest.call(null,s__58__$2)));\n} else {\nreturn cljs.core.chunk_cons.call(null,cljs.core.chunk.call(null,b__60),null);\n}\n} else {\nvar vec__64 = cljs.core.first.call(null,s__58__$2);\nvar k = cljs.core.nth.call(null,vec__64,(0),null);\nvar v = cljs.core.nth.call(null,vec__64,(1),null);\nreturn cljs.core.cons.call(null,(((v instanceof cljs.core.Symbol))?new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [k,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"if\",\"if\",(1181717262),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"fn?\",\"fn?\",(1820990818),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,v)))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"fn\",\"fn\",(465265323),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"&\",\"&\",(-2144855648),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"args\",\"args\",(-1338879193),null)))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"apply\",\"apply\",(-1334050276),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,v),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"args\",\"args\",(-1338879193),null)))))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,v)))], null):new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [k,v], null)),quil$sketch$macros$wrap_fns_$_iter__57.call(null,cljs.core.rest.call(null,s__58__$2)));\n}\n} else {\nreturn null;\n}\nbreak;\n}\n}),null,null));\n});\nreturn iter__10859__auto__.call(null,opts);\n})());\n});\nquil.sketch$macros.defsketch = (function quil$sketch$macros$defsketch(var_args){\nvar args__11136__auto__ = [];\nvar len__11134__auto___70 = arguments.length;\nvar i__11135__auto___71 = (0);\nwhile(true){\nif((i__11135__auto___71 < len__11134__auto___70)){\nargs__11136__auto__.push((arguments[i__11135__auto___71]));\n\nvar G__72 = (i__11135__auto___71 + (1));\ni__11135__auto___71 = G__72;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__11137__auto__ = ((((3) < args__11136__auto__.length))?(new cljs.core.IndexedSeq(args__11136__auto__.slice((3)),(0),null)):null);\nreturn quil.sketch$macros.defsketch.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__11137__auto__);\n});\n\nquil.sketch$macros.defsketch.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,app_name,options){\nvar raw_opts = cljs.core.apply.call(null,cljs.core.hash_map,options);\nvar opts = quil.sketch$macros.wrap_fns.call(null,cljs.core.merge.call(null,new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"host\",\"host\",(-1558485167)),[cljs.core.str(app_name)].join('')], null),raw_opts));\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"do\",\"do\",(1686842252),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"defn\",\"defn\",(-126010802),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.vary_meta.call(null,app_name,cljs.core.assoc,new cljs.core.Keyword(null,\"export\",\"export\",(214356590)),true)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null)))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.sketch\",\"sketch\",\"quil.sketch/sketch\",(-934423233),null)),cljs.core.apply.call(null,cljs.core.concat,cljs.core.seq.call(null,opts)))))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"when-not\",\"when-not\",(-1223136340),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"some\",\"some\",(-310548046),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"fn*\",\"fn*\",(-752876845),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"p1__5__6__auto__\",\"p1__5__6__auto__\",(1788844416),null)))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"=\",\"=\",(-1501502141),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Keyword(null,\"no-start\",\"no-start\",(1381488856))),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"p1__5__6__auto__\",\"p1__5__6__auto__\",(1788844416),null)))))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Keyword(null,\"features\",\"features\",(-1146962336)).cljs$core$IFn$_invoke$arity$1(opts))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.sketch\",\"add-sketch-to-init-list\",\"quil.sketch/add-sketch-to-init-list\",(-205126918),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.apply.call(null,cljs.core.array_map,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Keyword(null,\"fn\",\"fn\",(-1175266204))),cljs.core._conj.call(null,cljs.core.List.EMPTY,app_name),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Keyword(null,\"host-id\",\"host-id\",(742376279))),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Keyword(null,\"host\",\"host\",(-1558485167)).cljs$core$IFn$_invoke$arity$1(opts))))))))))))));\n});\n\nquil.sketch$macros.defsketch.cljs$lang$maxFixedArity = (3);\n\nquil.sketch$macros.defsketch.cljs$lang$applyTo = (function (seq66){\nvar G__67 = cljs.core.first.call(null,seq66);\nvar seq66__$1 = cljs.core.next.call(null,seq66);\nvar G__68 = cljs.core.first.call(null,seq66__$1);\nvar seq66__$2 = cljs.core.next.call(null,seq66__$1);\nvar G__69 = cljs.core.first.call(null,seq66__$2);\nvar seq66__$3 = cljs.core.next.call(null,seq66__$2);\nreturn quil.sketch$macros.defsketch.cljs$core$IFn$_invoke$arity$variadic(G__67,G__68,G__69,seq66__$3);\n});\n\nquil.sketch$macros.defsketch.cljs$lang$macro = true;\n"}, {:name quil.util, :macros true} {:cache {:use-macros nil, :excludes #{}, :name quil.util$macros, :imports nil, :requires {cstr clojure.string, clojure.string clojure.string}, :uses nil, :defs {clj-compilation? {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.util$macros/clj-compilation?, :meta {}, :method-params ([])}, make-quil-constant-map {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.util$macros/make-quil-constant-map, :meta {}, :method-params ([target const-map-name const-map])}, print-definition-list {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.util$macros/print-definition-list, :meta {}, :method-params ([definitions])}, generate-quil-constants {:macro true, :variadic true, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.util$macros/generate-quil-constants, :meta {:macro true, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env target opts)], :arglists ([&form &env target & opts]), :arglists-meta (nil)}}, :method-params [(&form &env target opts)]}, resolve-constant-key {:variadic false, :protocol-impl nil, :max-fixed-arity 2, :fn-var true, :name quil.util$macros/resolve-constant-key, :meta {}, :method-params ([key mappings])}, no-fn {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.util$macros/no-fn, :meta {}, :method-params ([])}, prepare-quil-clj-constants {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.util$macros/prepare-quil-clj-constants, :meta {}, :method-params ([constants])}, prepare-quil-cljs-constants {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.util$macros/prepare-quil-cljs-constants, :meta {}, :method-params ([constants])}, length-of-longest-key {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.util$macros/length-of-longest-key, :meta {}, :method-params ([m])}, gen-padding {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.util$macros/gen-padding, :meta {:top-fn {:variadic false, :max-fixed-arity 3, :method-params ([len] [len pad] [s len pad]), :arglists ([len] [len pad] [s len pad]), :arglists-meta (nil nil nil)}}, :method-params ([len] [len pad] [s len pad])}, prepare-quil-name {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.util$macros/prepare-quil-name, :meta {}, :method-params ([const-keyword])}}, :require-macros nil, :cljs.analyzer/constants {:seen #{:else aget js/Processing.prototype.PConstants def :clj do}, :order [:else aget js/Processing.prototype.PConstants def :clj do]}, :doc nil}, :source "goog.provide(\"quil.util$macros\");\n/**\n * Function that does nothing.\n */\nquil.util$macros.no_fn = (function quil$util$macros$no_fn(){\nreturn null;\n});\n/**\n * Returns the val associated with key in mappings or key directly if it\n *   is one of the vals in mappings. Otherwise throws an exception.\n */\nquil.util$macros.resolve_constant_key = (function quil$util$macros$resolve_constant_key(key,mappings){\nif(cljs.core.truth_(cljs.core.get.call(null,mappings,key))){\nreturn cljs.core.get.call(null,mappings,key);\n} else {\nif(cljs.core.truth_(cljs.core.some.call(null,cljs.core.PersistentHashSet.fromArray([key], true),cljs.core.vals.call(null,mappings)))){\nreturn key;\n} else {\nthrow (new Error([cljs.core.str(\"Expecting a keyword, got: \"),cljs.core.str(key),cljs.core.str(\". Expected one of: \"),cljs.core.str(cljs.core.vec.call(null,cljs.core.sort.call(null,cljs.core.keys.call(null,mappings))))].join('')));\n\n}\n}\n});\n/**\n * Returns the length of the longest key of map m. Assumes m's keys are strings\n * and returns 0 if map is empty:\n * (length-of-longest-key {\"foo\" 1 \"barr\" 2 \"bazzz\" 3}) ;=> 5\n * (length-of-longest-key {}) ;=> 0\n */\nquil.util$macros.length_of_longest_key = (function quil$util$macros$length_of_longest_key(m){\nvar or__10278__auto__ = cljs.core.last.call(null,cljs.core.sort.call(null,cljs.core.map.call(null,(function (p1__7_SHARP_){\nreturn p1__7_SHARP_.length();\n}),cljs.core.keys.call(null,m))));\nif(cljs.core.truth_(or__10278__auto__)){\nreturn or__10278__auto__;\n} else {\nreturn (0);\n}\n});\n/**\n * Generates a padding string starting concatting s with len times pad:\n * (gen-padding \"\" 5 \"b\") ;=> \"bbbbb\"\n * May be called without starting string s in which case it defaults to the\n * empty string and also without pad in which case it defaults to a single space\n */\nquil.util$macros.gen_padding = (function quil$util$macros$gen_padding(var_args){\nvar args73 = [];\nvar len__11134__auto___76 = arguments.length;\nvar i__11135__auto___77 = (0);\nwhile(true){\nif((i__11135__auto___77 < len__11134__auto___76)){\nargs73.push((arguments[i__11135__auto___77]));\n\nvar G__78 = (i__11135__auto___77 + (1));\ni__11135__auto___77 = G__78;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__75 = args73.length;\nswitch (G__75) {\ncase (1):\nreturn quil.util$macros.gen_padding.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.util$macros.gen_padding.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.util$macros.gen_padding.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args73.length)].join('')));\n\n}\n});\n\nquil.util$macros.gen_padding.cljs$core$IFn$_invoke$arity$1 = (function (len){\nreturn quil.util$macros.gen_padding.call(null,\"\",len,\" \");\n});\n\nquil.util$macros.gen_padding.cljs$core$IFn$_invoke$arity$2 = (function (len,pad){\nreturn quil.util$macros.gen_padding.call(null,\"\",len,pad);\n});\n\nquil.util$macros.gen_padding.cljs$core$IFn$_invoke$arity$3 = (function (s,len,pad){\nif((len > (0))){\nreturn quil.util$macros.gen_padding.call(null,[cljs.core.str(s),cljs.core.str(pad)].join(''),(len - (1)),pad);\n} else {\nreturn s;\n}\n});\n\nquil.util$macros.gen_padding.cljs$lang$maxFixedArity = (3);\nquil.util$macros.print_definition_list = (function quil$util$macros$print_definition_list(definitions){\nvar longest_key = quil.util$macros.length_of_longest_key.call(null,definitions);\nreturn cljs.core.dorun.call(null,cljs.core.map.call(null,((function (longest_key){\nreturn (function (p__82){\nvar vec__83 = p__82;\nvar k = cljs.core.nth.call(null,vec__83,(0),null);\nvar v = cljs.core.nth.call(null,vec__83,(1),null);\nvar len = k.length();\nvar diff = (longest_key - len);\nvar pad = quil.util$macros.gen_padding.call(null,diff);\nreturn cljs.core.println.call(null,k,pad,\"- \",v);\n});})(longest_key))\n,definitions));\n});\nquil.util$macros.clj_compilation_QMARK_ = (function quil$util$macros$clj_compilation_QMARK_(){\nreturn false;\n});\nquil.util$macros.prepare_quil_name = (function quil$util$macros$prepare_quil_name(const_keyword){\nreturn clojure.string.replace.call(null,clojure.string.upper_case.call(null,cljs.core.name.call(null,const_keyword)),/-/,\"_\");\n});\nquil.util$macros.prepare_quil_clj_constants = (function quil$util$macros$prepare_quil_clj_constants(constants){\nreturn cljs.core.into.call(null,cljs.core.PersistentArrayMap.EMPTY,cljs.core.map.call(null,(function (p1__8_SHARP_){\nreturn (new cljs.core.PersistentVector(null,(2),(5),cljs.core.PersistentVector.EMPTY_NODE,[p1__8_SHARP_,cljs.core.symbol.call(null,[cljs.core.str(\"PConstants/\"),cljs.core.str(quil.util$macros.prepare_quil_name.call(null,p1__8_SHARP_))].join(''))],null));\n}),constants));\n});\nquil.util$macros.prepare_quil_cljs_constants = (function quil$util$macros$prepare_quil_cljs_constants(constants){\nreturn cljs.core.into.call(null,cljs.core.PersistentArrayMap.EMPTY,cljs.core.map.call(null,(function (p1__9_SHARP_){\nreturn (new cljs.core.PersistentVector(null,(2),(5),cljs.core.PersistentVector.EMPTY_NODE,[p1__9_SHARP_,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"aget\",\"aget\",(1491056546),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"js\",\"Processing.prototype.PConstants\",\"js/Processing.prototype.PConstants\",(2034048972),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,quil.util$macros.prepare_quil_name.call(null,p1__9_SHARP_))))],null));\n}),constants));\n});\nquil.util$macros.make_quil_constant_map = (function quil$util$macros$make_quil_constant_map(target,const_map_name,const_map){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"def\",\"def\",(597100991),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,const_map_name),cljs.core._conj.call(null,cljs.core.List.EMPTY,((cljs.core._EQ_.call(null,target,new cljs.core.Keyword(null,\"clj\",\"clj\",(-660495428))))?quil.util$macros.prepare_quil_clj_constants.call(null,const_map):quil.util$macros.prepare_quil_cljs_constants.call(null,const_map)))));\n});\nquil.util$macros.generate_quil_constants = (function quil$util$macros$generate_quil_constants(var_args){\nvar args__11136__auto__ = [];\nvar len__11134__auto___88 = arguments.length;\nvar i__11135__auto___89 = (0);\nwhile(true){\nif((i__11135__auto___89 < len__11134__auto___88)){\nargs__11136__auto__.push((arguments[i__11135__auto___89]));\n\nvar G__90 = (i__11135__auto___89 + (1));\ni__11135__auto___89 = G__90;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__11137__auto__ = ((((3) < args__11136__auto__.length))?(new cljs.core.IndexedSeq(args__11136__auto__.slice((3)),(0),null)):null);\nreturn quil.util$macros.generate_quil_constants.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__11137__auto__);\n});\n\nquil.util$macros.generate_quil_constants.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,target,opts){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"do\",\"do\",(1686842252),null)),cljs.core.map.call(null,(function (p1__10_SHARP_){\nreturn quil.util$macros.make_quil_constant_map.call(null,target,cljs.core.first.call(null,p1__10_SHARP_),cljs.core.second.call(null,p1__10_SHARP_));\n}),cljs.core.partition.call(null,(2),opts))));\n});\n\nquil.util$macros.generate_quil_constants.cljs$lang$maxFixedArity = (3);\n\nquil.util$macros.generate_quil_constants.cljs$lang$applyTo = (function (seq84){\nvar G__85 = cljs.core.first.call(null,seq84);\nvar seq84__$1 = cljs.core.next.call(null,seq84);\nvar G__86 = cljs.core.first.call(null,seq84__$1);\nvar seq84__$2 = cljs.core.next.call(null,seq84__$1);\nvar G__87 = cljs.core.first.call(null,seq84__$2);\nvar seq84__$3 = cljs.core.next.call(null,seq84__$2);\nreturn quil.util$macros.generate_quil_constants.cljs$core$IFn$_invoke$arity$variadic(G__85,G__86,G__87,seq84__$3);\n});\n\nquil.util$macros.generate_quil_constants.cljs$lang$macro = true;\n"}, {:name quil.core, :macros true} {:cache {:use-macros nil, :excludes #{}, :name quil.core$macros, :imports nil, :requires {clojure.string clojure.string, org.processingjs.Processing org.processingjs.Processing, ap quil.sketch, quil.sketch quil.sketch, u quil.util, quil.util quil.util}, :uses nil, :defs {rotate-x {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/rotate-x, :meta {}, :method-params ([angle])}, text-modes {:name quil.core$macros/text-modes, :meta {}}, print-projection {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/print-projection, :meta {}, :method-params ([])}, raw-key {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/raw-key, :meta {}, :method-params ([])}, text-char {:variadic false, :protocol-impl nil, :max-fixed-arity 4, :fn-var true, :name quil.core$macros/text-char, :meta {:top-fn {:variadic false, :max-fixed-arity 4, :method-params ([c x y] [c x y z]), :arglists ([c x y] [c x y z]), :arglists-meta (nil nil)}}, :method-params ([c x y] [c x y z])}, display-filter {:variadic false, :protocol-impl nil, :max-fixed-arity 2, :fn-var true, :name quil.core$macros/display-filter, :meta {:top-fn {:variadic false, :max-fixed-arity 2, :method-params ([mode] [mode level]), :arglists ([mode] [mode level]), :arglists-meta (nil nil)}}, :method-params ([mode] [mode level])}, rotate-z {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/rotate-z, :meta {}, :method-params ([angle])}, random-gaussian {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/random-gaussian, :meta {}, :method-params ([])}, blend {:variadic false, :protocol-impl nil, :max-fixed-arity 11, :fn-var true, :name quil.core$macros/blend, :meta {:top-fn {:variadic false, :max-fixed-arity 11, :method-params ([x y width height dx dy dwidth dheight mode] [src-img x y width height dx dy dwidth dheight mode] [src-img dest-img x y width height dx dy dwidth dheight mode]), :arglists ([x y width height dx dy dwidth dheight mode] [src-img x y width height dx dy dwidth dheight mode] [src-img dest-img x y width height dx dy dwidth dheight mode]), :arglists-meta (nil nil nil)}}, :method-params ([x y width height dx dy dwidth dheight mode] [src-img x y width height dx dy dwidth dheight mode] [src-img dest-img x y width height dx dy dwidth dheight mode])}, frame-count {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/frame-count, :meta {}, :method-params ([])}, with-graphics {:macro true, :variadic true, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/with-graphics, :meta {:macro true, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env graphics body)], :arglists ([&form &env graphics & body]), :arglists-meta (nil)}}, :method-params [(&form &env graphics body)]}, model-y {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/model-y, :meta {}, :method-params ([x y z])}, set-image {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/set-image, :meta {}, :method-params ([x y src])}, shape-mode {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/shape-mode, :meta {}, :method-params ([mode])}, cursor-image {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/cursor-image, :meta {:top-fn {:variadic false, :max-fixed-arity 3, :method-params ([img] [img hx hy]), :arglists ([img] [img hx hy]), :arglists-meta (nil nil)}}, :method-params ([img] [img hx hy])}, create-graphics {:variadic false, :protocol-impl nil, :max-fixed-arity 4, :fn-var true, :name quil.core$macros/create-graphics, :meta {:top-fn {:variadic false, :max-fixed-arity 4, :method-params ([w h] [w h renderer] [w h renderer path]), :arglists ([w h] [w h renderer] [w h renderer path]), :arglists-meta (nil nil nil)}}, :method-params ([w h] [w h renderer] [w h renderer path])}, update-pixels {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/update-pixels, :meta {:top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [img]), :arglists ([] [img]), :arglists-meta (nil nil)}}, :method-params ([] [img])}, text-size {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/text-size, :meta {}, :method-params ([size])}, pixels {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/pixels, :meta {:top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [img]), :arglists ([] [img]), :arglists-meta (nil nil)}}, :method-params ([] [img])}, stroke-float {:variadic false, :protocol-impl nil, :max-fixed-arity 4, :fn-var true, :name quil.core$macros/stroke-float, :meta {:top-fn {:variadic false, :max-fixed-arity 4, :method-params ([gray] [gray alpha] [x y z] [x y z a]), :arglists ([gray] [gray alpha] [x y z] [x y z a]), :arglists-meta (nil nil nil nil)}}, :method-params ([gray] [gray alpha] [x y z] [x y z a])}, constrain {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/constrain, :meta {}, :method-params ([amt low high])}, screen-y {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/screen-y, :meta {:top-fn {:variadic false, :max-fixed-arity 3, :method-params ([x y] [x y z]), :arglists ([x y] [x y z]), :arglists-meta (nil nil)}}, :method-params ([x y] [x y z])}, fill-float {:variadic false, :protocol-impl nil, :max-fixed-arity 4, :fn-var true, :name quil.core$macros/fill-float, :meta {:top-fn {:variadic false, :max-fixed-arity 4, :method-params ([gray] [gray alpha] [r g b] [r g b alpha]), :arglists ([gray] [gray alpha] [r g b] [r g b alpha]), :arglists-meta (nil nil nil nil)}}, :method-params ([gray] [gray alpha] [r g b] [r g b alpha])}, rect {:variadic false, :protocol-impl nil, :max-fixed-arity 8, :fn-var true, :name quil.core$macros/rect, :meta {:top-fn {:variadic false, :max-fixed-arity 8, :method-params ([x y width height] [x y width height r] [x y width height top-left-r top-right-r bottom-right-r bottom-left-r]), :arglists ([x y width height] [x y width height r] [x y width height top-left-r top-right-r bottom-right-r bottom-left-r]), :arglists-meta (nil nil nil)}}, :method-params ([x y width height] [x y width height r] [x y width height top-left-r top-right-r bottom-right-r bottom-left-r])}, log {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/log, :meta {}, :method-params ([val])}, with-stroke {:macro true, :variadic true, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/with-stroke, :meta {:macro true, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env stroke-args body)], :arglists ([&form &env stroke-args & body]), :arglists-meta (nil)}}, :method-params [(&form &env stroke-args body)]}, ambient-float {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/ambient-float, :meta {:top-fn {:variadic false, :max-fixed-arity 3, :method-params ([gray] [x y z]), :arglists ([gray] [x y z]), :arglists-meta (nil nil)}}, :method-params ([gray] [x y z])}, end-raw {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/end-raw, :meta {}, :method-params ([])}, radians {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/radians, :meta {}, :method-params ([degrees])}, degrees {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/degrees, :meta {}, :method-params ([radians])}, acos {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/acos, :meta {}, :method-params ([n])}, bezier-detail {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/bezier-detail, :meta {}, :method-params ([detail])}, texture {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/texture, :meta {}, :method-params ([img])}, stroke-int {:variadic false, :protocol-impl nil, :max-fixed-arity 2, :fn-var true, :name quil.core$macros/stroke-int, :meta {:top-fn {:variadic false, :max-fixed-arity 2, :method-params ([rgb] [rgb alpha]), :arglists ([rgb] [rgb alpha]), :arglists-meta (nil nil)}}, :method-params ([rgb] [rgb alpha])}, print-camera {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/print-camera, :meta {}, :method-params ([])}, floor {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/floor, :meta {}, :method-params ([n])}, atan2 {:variadic false, :protocol-impl nil, :max-fixed-arity 2, :fn-var true, :name quil.core$macros/atan2, :meta {}, :method-params ([y x])}, millis {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/millis, :meta {}, :method-params ([])}, lerp-color {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/lerp-color, :meta {}, :method-params ([c1 c2 amt])}, image-modes {:name quil.core$macros/image-modes, :meta {}}, no-fill-prop {:name quil.core$macros/no-fill-prop, :meta {}}, color-mode {:variadic false, :protocol-impl nil, :max-fixed-arity 5, :fn-var true, :name quil.core$macros/color-mode, :meta {:top-fn {:variadic false, :max-fixed-arity 5, :method-params ([mode] [mode max] [mode max-x max-y max-z] [mode max-x max-y max-z max-a]), :arglists ([mode] [mode max] [mode max-x max-y max-z] [mode max-x max-y max-z max-a]), :arglists-meta (nil nil nil nil)}}, :method-params ([mode] [mode max] [mode max-x max-y max-z] [mode max-x max-y max-z max-a])}, create-image {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/create-image, :meta {}, :method-params ([w h format])}, sq {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/sq, :meta {}, :method-params ([a])}, height {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/height, :meta {}, :method-params ([])}, no-loop {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/no-loop, :meta {}, :method-params ([])}, minute {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/minute, :meta {}, :method-params ([])}, text {:variadic false, :protocol-impl nil, :max-fixed-arity 5, :fn-var true, :name quil.core$macros/text, :meta {:top-fn {:variadic false, :max-fixed-arity 5, :method-params ([s x y] [s x y z] [s x1 y1 x2 y2]), :arglists ([s x y] [s x y z] [s x1 y1 x2 y2]), :arglists-meta (nil nil nil)}}, :method-params ([s x y] [s x y z] [s x1 y1 x2 y2])}, available-fonts {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/available-fonts, :meta {}, :method-params ([])}, rect-modes {:name quil.core$macros/rect-modes, :meta {}}, THIRD-PI {:name quil.core$macros/THIRD-PI, :meta {}}, binary {:variadic false, :protocol-impl nil, :max-fixed-arity 2, :fn-var true, :name quil.core$macros/binary, :meta {:top-fn {:variadic false, :max-fixed-arity 2, :method-params ([val] [val num-digits]), :arglists ([val] [val num-digits]), :arglists-meta (nil nil)}}, :method-params ([val] [val num-digits])}, pop-matrix {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/pop-matrix, :meta {}, :method-params ([])}, ceil {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/ceil, :meta {}, :method-params ([n])}, key-code {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/key-code, :meta {}, :method-params ([])}, sphere {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/sphere, :meta {}, :method-params ([radius])}, request-image {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/request-image, :meta {}, :method-params ([filename])}, hue {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/hue, :meta {}, :method-params ([col])}, background-int {:variadic false, :protocol-impl nil, :max-fixed-arity 2, :fn-var true, :name quil.core$macros/background-int, :meta {:top-fn {:variadic false, :max-fixed-arity 2, :method-params ([rgb] [rgb alpha]), :arglists ([rgb] [rgb alpha]), :arglists-meta (nil nil)}}, :method-params ([rgb] [rgb alpha])}, start-loop {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/start-loop, :meta {}, :method-params ([])}, no-fill? {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/no-fill?, :meta {}, :method-params ([graphics])}, curve-vertex {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/curve-vertex, :meta {:top-fn {:variadic false, :max-fixed-arity 3, :method-params ([x y] [x y z]), :arglists ([x y] [x y z]), :arglists-meta (nil nil)}}, :method-params ([x y] [x y z])}, state-atom {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/state-atom, :meta {}, :method-params ([])}, load-image {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/load-image, :meta {}, :method-params ([filename])}, bezier {:variadic false, :protocol-impl nil, :max-fixed-arity 12, :fn-var true, :name quil.core$macros/bezier, :meta {:top-fn {:variadic false, :max-fixed-arity 12, :method-params ([x1 y1 cx1 cy1 cx2 cy2 x2 y2] [x1 y1 z1 cx1 cy1 cz1 cx2 cy2 cz2 x2 y2 z2]), :arglists ([x1 y1 cx1 cy1 cx2 cy2 x2 y2] [x1 y1 z1 cx1 cy1 cz1 cx2 cy2 cz2 x2 y2 z2]), :arglists-meta (nil nil)}}, :method-params ([x1 y1 cx1 cy1 cx2 cy2 x2 y2] [x1 y1 z1 cx1 cy1 cz1 cx2 cy2 cz2 x2 y2 z2])}, smooth {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/smooth, :meta {:top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [level]), :arglists ([] [level]), :arglists-meta (nil nil)}}, :method-params ([] [level])}, filter-modes {:name quil.core$macros/filter-modes, :meta {}}, shear-x {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/shear-x, :meta {}, :method-params ([angle])}, stroke-weight {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/stroke-weight, :meta {}, :method-params ([weight])}, directional-light {:variadic false, :protocol-impl nil, :max-fixed-arity 6, :fn-var true, :name quil.core$macros/directional-light, :meta {}, :method-params ([r g b nx ny nz])}, frame-rate {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/frame-rate, :meta {}, :method-params ([new-rate])}, hour {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/hour, :meta {}, :method-params ([])}, fill-int {:variadic false, :protocol-impl nil, :max-fixed-arity 2, :fn-var true, :name quil.core$macros/fill-int, :meta {:top-fn {:variadic false, :max-fixed-arity 2, :method-params ([rgb] [rgb alpha]), :arglists ([rgb] [rgb alpha]), :arglists-meta (nil nil)}}, :method-params ([rgb] [rgb alpha])}, atan {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/atan, :meta {}, :method-params ([n])}, stroke-join-modes {:name quil.core$macros/stroke-join-modes, :meta {}}, rotate-y {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/rotate-y, :meta {}, :method-params ([angle])}, day {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/day, :meta {}, :method-params ([])}, point-light {:variadic false, :protocol-impl nil, :max-fixed-arity 6, :fn-var true, :name quil.core$macros/point-light, :meta {}, :method-params ([r g b x y z])}, pmouse-x {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/pmouse-x, :meta {}, :method-params ([])}, get-sketch-by-id {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/get-sketch-by-id, :meta {}, :method-params ([id])}, stroke {:variadic false, :protocol-impl nil, :max-fixed-arity 4, :fn-var true, :name quil.core$macros/stroke, :meta {:top-fn {:variadic false, :max-fixed-arity 4, :method-params ([rgb] [rgb alpha] [x y z] [x y z a]), :arglists ([rgb] [rgb alpha] [x y z] [x y z a]), :arglists-meta (nil nil nil nil)}}, :method-params ([rgb] [rgb alpha] [x y z] [x y z a])}, mouse-pressed? {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/mouse-pressed?, :meta {}, :method-params ([])}, key-pressed? {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/key-pressed?, :meta {}, :method-params ([])}, quadratic-vertex {:variadic false, :protocol-impl nil, :max-fixed-arity 6, :fn-var true, :name quil.core$macros/quadratic-vertex, :meta {:top-fn {:variadic false, :max-fixed-arity 6, :method-params ([cx cy x3 y3] [cx cy cz x3 y3 z3]), :arglists ([cx cy x3 y3] [cx cy cz x3 y3 z3]), :arglists-meta (nil nil)}}, :method-params ([cx cy x3 y3] [cx cy cz x3 y3 z3])}, texture-wrap-modes {:name quil.core$macros/texture-wrap-modes, :meta {}}, noise-seed {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/noise-seed, :meta {}, :method-params ([val])}, apply-matrix {:variadic false, :protocol-impl nil, :max-fixed-arity 16, :fn-var true, :name quil.core$macros/apply-matrix, :meta {}, :method-params ([n00 n01 n02 n03 n10 n11 n12 n13 n20 n21 n22 n23 n30 n31 n32 n33])}, copy {:variadic false, :protocol-impl nil, :max-fixed-arity 4, :fn-var true, :name quil.core$macros/copy, :meta {:top-fn {:variadic false, :max-fixed-arity 4, :method-params ([[sx sy swidth sheight] [dx dy dwidth dheight]] [src-img [sx sy swidth sheight] [dx dy dwidth dheight]] [src-img dest-img [sx sy swidth sheight] [dx dy dwidth dheight]]), :arglists ([[sx sy swidth sheight] [dx dy dwidth dheight]] [src-img [sx sy swidth sheight] [dx dy dwidth dheight]] [src-img dest-img [sx sy swidth sheight] [dx dy dwidth dheight]]), :arglists-meta (nil nil nil)}}, :method-params ([[sx sy swidth sheight] [dx dy dwidth dheight]] [src-img [sx sy swidth sheight] [dx dy dwidth dheight]] [src-img dest-img [sx sy swidth sheight] [dx dy dwidth dheight]])}, begin-shape {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/begin-shape, :meta {:top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [mode]), :arglists ([] [mode]), :arglists-meta (nil nil)}}, :method-params ([] [mode])}, set-state! {:variadic true, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/set-state!, :meta {:top-fn {:variadic true, :max-fixed-arity 0, :method-params [(state-vals)], :arglists ([& state-vals]), :arglists-meta (nil)}}, :method-params [(state-vals)]}, stroke-join {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/stroke-join, :meta {}, :method-params ([join-mode])}, cos {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/cos, :meta {}, :method-params ([angle])}, curve-tightness {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/curve-tightness, :meta {}, :method-params ([ti])}, tan {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/tan, :meta {}, :method-params ([angle])}, triangle {:variadic false, :protocol-impl nil, :max-fixed-arity 6, :fn-var true, :name quil.core$macros/triangle, :meta {}, :method-params ([x1 y1 x2 y2 x3 y3])}, emissive {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/emissive, :meta {:top-fn {:variadic false, :max-fixed-arity 3, :method-params ([c] [r g b]), :arglists ([c] [r g b]), :arglists-meta (nil nil)}}, :method-params ([c] [r g b])}, clear-no-fill-cljs {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/clear-no-fill-cljs, :meta {}, :method-params ([graphics])}, sketch {:variadic true, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/sketch, :meta {:top-fn {:variadic true, :max-fixed-arity 0, :method-params [(opts)], :arglists ([& opts]), :arglists-meta (nil)}}, :method-params [(opts)]}, color {:variadic false, :protocol-impl nil, :max-fixed-arity 4, :fn-var true, :name quil.core$macros/color, :meta {:top-fn {:variadic false, :max-fixed-arity 4, :method-params ([gray] [gray alpha] [r g b] [r g b a]), :arglists ([gray] [gray alpha] [r g b] [r g b a]), :arglists-meta (nil nil nil nil)}}, :method-params ([gray] [gray alpha] [r g b] [r g b a])}, arc {:variadic false, :protocol-impl nil, :max-fixed-arity 6, :fn-var true, :name quil.core$macros/arc, :meta {}, :method-params ([x y width height start stop])}, text-align {:variadic false, :protocol-impl nil, :max-fixed-arity 2, :fn-var true, :name quil.core$macros/text-align, :meta {:top-fn {:variadic false, :max-fixed-arity 2, :method-params ([align] [align-x align-y]), :arglists ([align] [align-x align-y]), :arglists-meta (nil nil)}}, :method-params ([align] [align-x align-y])}, text-width {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/text-width, :meta {}, :method-params ([data])}, mouse-x {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/mouse-x, :meta {}, :method-params ([])}, TWO-PI {:name quil.core$macros/TWO-PI, :meta {}}, mag {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/mag, :meta {:top-fn {:variadic false, :max-fixed-arity 3, :method-params ([a b] [a b c]), :arglists ([a b] [a b c]), :arglists-meta (nil nil)}}, :method-params ([a b] [a b c])}, exit {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/exit, :meta {}, :method-params ([])}, map-range {:variadic false, :protocol-impl nil, :max-fixed-arity 5, :fn-var true, :name quil.core$macros/map-range, :meta {}, :method-params ([val low1 high1 low2 high2])}, model-x {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/model-x, :meta {}, :method-params ([x y z])}, sqrt {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/sqrt, :meta {}, :method-params ([a])}, saturation {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/saturation, :meta {}, :method-params ([c])}, prc-print {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/prc-print, :meta {}, :method-params ([msg])}, text-font {:variadic false, :protocol-impl nil, :max-fixed-arity 2, :fn-var true, :name quil.core$macros/text-font, :meta {:top-fn {:variadic false, :max-fixed-arity 2, :method-params ([font] [font size]), :arglists ([font] [font size]), :arglists-meta (nil nil)}}, :method-params ([font] [font size])}, scale {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/scale, :meta {:top-fn {:variadic false, :max-fixed-arity 3, :method-params ([s] [sx sy] [sx sy sz]), :arglists ([s] [sx sy] [sx sy sz]), :arglists-meta (nil nil nil)}}, :method-params ([s] [sx sy] [sx sy sz])}, defsketch {:macro true, :variadic true, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/defsketch, :meta {:macro true, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env app-name options)], :arglists ([&form &env app-name & options]), :arglists-meta (nil)}}, :method-params [(&form &env app-name options)]}, no-stroke {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/no-stroke, :meta {}, :method-params ([])}, end-camera {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/end-camera, :meta {}, :method-params ([])}, random-seed {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/random-seed, :meta {}, :method-params ([w])}, model-z {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/model-z, :meta {}, :method-params ([x y z])}, light-specular {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/light-specular, :meta {}, :method-params ([r g b])}, key-as-keyword {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/key-as-keyword, :meta {}, :method-params ([])}, dist {:variadic false, :protocol-impl nil, :max-fixed-arity 6, :fn-var true, :name quil.core$macros/dist, :meta {:top-fn {:variadic false, :max-fixed-arity 6, :method-params ([x1 y1 x2 y2] [x1 y1 z1 x2 y2 z2]), :arglists ([x1 y1 x2 y2] [x1 y1 z1 x2 y2 z2]), :arglists-meta (nil nil)}}, :method-params ([x1 y1 x2 y2] [x1 y1 z1 x2 y2 z2])}, PI {:name quil.core$macros/PI, :meta {}}, norm {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/norm, :meta {}, :method-params ([val start stop])}, end-shape {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/end-shape, :meta {:top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [mode]), :arglists ([] [mode]), :arglists-meta (nil nil)}}, :method-params ([] [mode])}, fill {:variadic false, :protocol-impl nil, :max-fixed-arity 4, :fn-var true, :name quil.core$macros/fill, :meta {:top-fn {:variadic false, :max-fixed-arity 4, :method-params ([rgb] [rgb alpha] [r g b] [r g b a]), :arglists ([rgb] [rgb alpha] [r g b] [r g b a]), :arglists-meta (nil nil nil nil)}}, :method-params ([rgb] [rgb alpha] [r g b] [r g b a])}, with-translation {:macro true, :variadic true, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/with-translation, :meta {:macro true, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env translation-vector body)], :arglists ([&form &env translation-vector & body]), :arglists-meta (nil)}}, :method-params [(&form &env translation-vector body)]}, reset-matrix {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/reset-matrix, :meta {}, :method-params ([])}, emissive-float {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/emissive-float, :meta {:top-fn {:variadic false, :max-fixed-arity 3, :method-params ([float-val] [r g b]), :arglists ([float-val] [r g b]), :arglists-meta (nil nil)}}, :method-params ([float-val] [r g b])}, shape-modes {:name quil.core$macros/shape-modes, :meta {}}, green {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/green, :meta {}, :method-params ([col])}, HALF-PI {:name quil.core$macros/HALF-PI, :meta {}}, begin-contour {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/begin-contour, :meta {}, :method-params ([])}, DEG-TO-RAD {:name quil.core$macros/DEG-TO-RAD, :meta {}}, pow {:variadic false, :protocol-impl nil, :max-fixed-arity 2, :fn-var true, :name quil.core$macros/pow, :meta {}, :method-params ([num exponent])}, box {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/box, :meta {:top-fn {:variadic false, :max-fixed-arity 3, :method-params ([size] [width height depth]), :arglists ([size] [width height depth]), :arglists-meta (nil nil)}}, :method-params ([size] [width height depth])}, exp {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/exp, :meta {}, :method-params ([val])}, with-sketch {:macro true, :variadic true, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/with-sketch, :meta {:macro true, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env applet body)], :arglists ([&form &env applet & body]), :arglists-meta (nil)}}, :method-params [(&form &env applet body)]}, text-ascent {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/text-ascent, :meta {}, :method-params ([])}, tint-int {:variadic false, :protocol-impl nil, :max-fixed-arity 2, :fn-var true, :name quil.core$macros/tint-int, :meta {:top-fn {:variadic false, :max-fixed-arity 2, :method-params ([rgb] [rgb alpha]), :arglists ([rgb] [rgb alpha]), :arglists-meta (nil nil)}}, :method-params ([rgb] [rgb alpha])}, shininess {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/shininess, :meta {}, :method-params ([shine])}, rect-mode {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/rect-mode, :meta {}, :method-params ([mode])}, ellipse-mode {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/ellipse-mode, :meta {}, :method-params ([mode])}, month {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/month, :meta {}, :method-params ([])}, texture-modes {:name quil.core$macros/texture-modes, :meta {}}, tint-float {:variadic false, :protocol-impl nil, :max-fixed-arity 4, :fn-var true, :name quil.core$macros/tint-float, :meta {:top-fn {:variadic false, :max-fixed-arity 4, :method-params ([gray] [gray alpha] [r g b] [r g b a]), :arglists ([gray] [gray alpha] [r g b] [r g b a]), :arglists-meta (nil nil nil nil)}}, :method-params ([gray] [gray alpha] [r g b] [r g b a])}, width {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/width, :meta {}, :method-params ([])}, background {:variadic false, :protocol-impl nil, :max-fixed-arity 4, :fn-var true, :name quil.core$macros/background, :meta {:top-fn {:variadic false, :max-fixed-arity 4, :method-params ([rgb] [rgb alpha] [r g b] [r g b a]), :arglists ([rgb] [rgb alpha] [r g b] [r g b a]), :arglists-meta (nil nil nil nil)}}, :method-params ([rgb] [rgb alpha] [r g b] [r g b a])}, ortho {:variadic false, :protocol-impl nil, :max-fixed-arity 6, :fn-var true, :name quil.core$macros/ortho, :meta {:top-fn {:variadic false, :max-fixed-arity 6, :method-params ([] [left right bottom top] [left right bottom top near far]), :arglists ([] [left right bottom top] [left right bottom top near far]), :arglists-meta (nil nil nil)}}, :method-params ([] [left right bottom top] [left right bottom top near far])}, hint-options {:name quil.core$macros/hint-options, :meta {}}, prc-println {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/prc-println, :meta {}, :method-params ([msg])}, brightness {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/brightness, :meta {}, :method-params ([color])}, arc-modes {:name quil.core$macros/arc-modes, :meta {}}, specular {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/specular, :meta {:top-fn {:variadic false, :max-fixed-arity 3, :method-params ([gray] [x y z]), :arglists ([gray] [x y z]), :arglists-meta (nil nil)}}, :method-params ([gray] [x y z])}, save-frame {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/save-frame, :meta {:top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [name]), :arglists ([] [name]), :arglists-meta (nil nil)}}, :method-params ([] [name])}, cursor {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/cursor, :meta {:top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [cursor-mode]), :arglists ([] [cursor-mode]), :arglists-meta (nil nil)}}, :method-params ([] [cursor-mode])}, noise {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/noise, :meta {:top-fn {:variadic false, :max-fixed-arity 3, :method-params ([x] [x y] [x y z]), :arglists ([x] [x y] [x y z]), :arglists-meta (nil nil nil)}}, :method-params ([x] [x y] [x y z])}, push-style {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/push-style, :meta {}, :method-params ([])}, bezier-vertex {:variadic false, :protocol-impl nil, :max-fixed-arity 9, :fn-var true, :name quil.core$macros/bezier-vertex, :meta {:top-fn {:variadic false, :max-fixed-arity 9, :method-params ([cx1 cy1 cx2 cy2 x y] [cx1 cy1 cz1 cx2 cy2 cz2 x y z]), :arglists ([cx1 cy1 cx2 cy2 x y] [cx1 cy1 cz1 cx2 cy2 cz2 x y z]), :arglists-meta (nil nil)}}, :method-params ([cx1 cy1 cx2 cy2 x y] [cx1 cy1 cz1 cx2 cy2 cz2 x y z])}, light-falloff {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/light-falloff, :meta {}, :method-params ([constant linear quadratic])}, noise-detail {:variadic false, :protocol-impl nil, :max-fixed-arity 2, :fn-var true, :name quil.core$macros/noise-detail, :meta {:top-fn {:variadic false, :max-fixed-arity 2, :method-params ([octaves] [octaves falloff]), :arglists ([octaves] [octaves falloff]), :arglists-meta (nil nil)}}, :method-params ([octaves] [octaves falloff])}, save {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/save, :meta {}, :method-params ([filename])}, curve-point {:variadic false, :protocol-impl nil, :max-fixed-arity 5, :fn-var true, :name quil.core$macros/curve-point, :meta {}, :method-params ([a b c d t])}, state {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/state, :meta {:top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [key]), :arglists ([] [key]), :arglists-meta (nil nil)}}, :method-params ([] [key])}, load-shader {:variadic false, :protocol-impl nil, :max-fixed-arity 2, :fn-var true, :name quil.core$macros/load-shader, :meta {:top-fn {:variadic false, :max-fixed-arity 2, :method-params ([fragment-filename] [fragment-filename vertex-filename]), :arglists ([fragment-filename] [fragment-filename vertex-filename]), :arglists-meta (nil nil)}}, :method-params ([fragment-filename] [fragment-filename vertex-filename])}, resize {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/resize, :meta {}, :method-params ([img w h])}, normal {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/normal, :meta {}, :method-params ([nx ny nz])}, perspective {:variadic false, :protocol-impl nil, :max-fixed-arity 4, :fn-var true, :name quil.core$macros/perspective, :meta {:top-fn {:variadic false, :max-fixed-arity 4, :method-params ([] [fovy aspect z-near z-far]), :arglists ([] [fovy aspect z-near z-far]), :arglists-meta (nil nil)}}, :method-params ([] [fovy aspect z-near z-far])}, seconds {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/seconds, :meta {}, :method-params ([])}, hint {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/hint, :meta {}, :method-params ([hint-type])}, sphere-detail {:variadic false, :protocol-impl nil, :max-fixed-arity 2, :fn-var true, :name quil.core$macros/sphere-detail, :meta {:top-fn {:variadic false, :max-fixed-arity 2, :method-params ([res] [ures vres]), :arglists ([res] [ures vres]), :arglists-meta (nil nil)}}, :method-params ([res] [ures vres])}, vertex {:variadic false, :protocol-impl nil, :max-fixed-arity 5, :fn-var true, :name quil.core$macros/vertex, :meta {:top-fn {:variadic false, :max-fixed-arity 5, :method-params ([x y] [x y z] [x y u v] [x y z u v]), :arglists ([x y] [x y z] [x y u v] [x y z u v]), :arglists-meta (nil nil nil nil)}}, :method-params ([x y] [x y z] [x y u v] [x y z u v])}, delay-frame {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/delay-frame, :meta {}, :method-params ([freeze-ms])}, horizontal-alignment-modes {:name quil.core$macros/horizontal-alignment-modes, :meta {}}, spot-light {:variadic false, :protocol-impl nil, :max-fixed-arity 11, :fn-var true, :name quil.core$macros/spot-light, :meta {:top-fn {:variadic false, :max-fixed-arity 11, :method-params ([r g b x y z nx ny nz angle concentration] [[r g b] [x y z] [nx ny nz] angle concentration]), :arglists ([r g b x y z nx ny nz angle concentration] [[r g b] [x y z] [nx ny nz] angle concentration]), :arglists-meta (nil nil)}}, :method-params ([r g b x y z nx ny nz angle concentration] [[r g b] [x y z] [nx ny nz] angle concentration])}, target-frame-rate {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/target-frame-rate, :meta {}, :method-params ([])}, tint {:variadic false, :protocol-impl nil, :max-fixed-arity 4, :fn-var true, :name quil.core$macros/tint, :meta {:top-fn {:variadic false, :max-fixed-arity 4, :method-params ([rgb] [rgb alpha] [r g b] [r g b a]), :arglists ([rgb] [rgb alpha] [r g b] [r g b a]), :arglists-meta (nil nil nil nil)}}, :method-params ([rgb] [rgb alpha] [r g b] [r g b a])}, bezier-tangent {:variadic false, :protocol-impl nil, :max-fixed-arity 5, :fn-var true, :name quil.core$macros/bezier-tangent, :meta {}, :method-params ([a b c d t])}, asin {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/asin, :meta {}, :method-params ([n])}, lerp {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/lerp, :meta {}, :method-params ([start stop amt])}, unhex {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/unhex, :meta {}, :method-params ([hex-str])}, begin-camera {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/begin-camera, :meta {}, :method-params ([])}, text-num {:variadic false, :protocol-impl nil, :max-fixed-arity 4, :fn-var true, :name quil.core$macros/text-num, :meta {:top-fn {:variadic false, :max-fixed-arity 4, :method-params ([num x y] [num x y z]), :arglists ([num x y] [num x y z]), :arglists-meta (nil nil)}}, :method-params ([num x y] [num x y z])}, round {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/round, :meta {}, :method-params ([val])}, background-image {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/background-image, :meta {}, :method-params ([img])}, load-shape {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/load-shape, :meta {}, :method-params ([filename])}, vertical-alignment-modes {:name quil.core$macros/vertical-alignment-modes, :meta {}}, blend-color {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/blend-color, :meta {}, :method-params ([c1 c2 mode])}, QUARTER-PI {:name quil.core$macros/QUARTER-PI, :meta {}}, stroke-cap {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/stroke-cap, :meta {}, :method-params ([cap-mode])}, blend-modes {:name quil.core$macros/blend-modes, :meta {}}, no-fill {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/no-fill, :meta {}, :method-params ([])}, year {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/year, :meta {}, :method-params ([])}, key-coded? {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/key-coded?, :meta {}, :method-params ([c])}, curve-tangent {:variadic false, :protocol-impl nil, :max-fixed-arity 5, :fn-var true, :name quil.core$macros/curve-tangent, :meta {}, :method-params ([a b c d t])}, ellipse-modes {:name quil.core$macros/ellipse-modes, :meta {}}, pmouse-y {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/pmouse-y, :meta {}, :method-params ([])}, hex {:variadic false, :protocol-impl nil, :max-fixed-arity 2, :fn-var true, :name quil.core$macros/hex, :meta {:top-fn {:variadic false, :max-fixed-arity 2, :method-params ([val] [val num-digits]), :arglists ([val] [val num-digits]), :arglists-meta (nil nil)}}, :method-params ([val] [val num-digits])}, with-fill {:macro true, :variadic true, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/with-fill, :meta {:macro true, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env fill-args body)], :arglists ([&form &env fill-args & body]), :arglists-meta (nil)}}, :method-params [(&form &env fill-args body)]}, no-cursor {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/no-cursor, :meta {}, :method-params ([])}, create-font {:variadic false, :protocol-impl nil, :max-fixed-arity 4, :fn-var true, :name quil.core$macros/create-font, :meta {:top-fn {:variadic false, :max-fixed-arity 4, :method-params ([name size] [name size smooth] [name size smooth charset]), :arglists ([name size] [name size smooth] [name size smooth charset]), :arglists-meta (nil nil nil)}}, :method-params ([name size] [name size smooth] [name size smooth charset])}, current-graphics {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/current-graphics, :meta {}, :method-params ([])}, abs {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/abs, :meta {}, :method-params ([n])}, pop-style {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/pop-style, :meta {}, :method-params ([])}, focused {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/focused, :meta {}, :method-params ([])}, background-float {:variadic false, :protocol-impl nil, :max-fixed-arity 4, :fn-var true, :name quil.core$macros/background-float, :meta {:top-fn {:variadic false, :max-fixed-arity 4, :method-params ([gray] [gray alpha] [r g b] [r g b a]), :arglists ([gray] [gray alpha] [r g b] [r g b a]), :arglists-meta (nil nil nil nil)}}, :method-params ([gray] [gray alpha] [r g b] [r g b a])}, text-mode {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/text-mode, :meta {}, :method-params ([mode])}, image-mode {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/image-mode, :meta {}, :method-params ([mode])}, line {:variadic false, :protocol-impl nil, :max-fixed-arity 6, :fn-var true, :name quil.core$macros/line, :meta {:top-fn {:variadic false, :max-fixed-arity 6, :method-params ([p1 p2] [x1 y1 x2 y2] [x1 y1 z1 x2 y2 z2]), :arglists ([p1 p2] [x1 y1 x2 y2] [x1 y1 z1 x2 y2 z2]), :arglists-meta (nil nil nil)}}, :method-params ([p1 p2] [x1 y1 x2 y2] [x1 y1 z1 x2 y2 z2])}, red {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/red, :meta {}, :method-params ([c])}, current-fill {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/current-fill, :meta {}, :method-params ([])}, color-modes {:name quil.core$macros/color-modes, :meta {}}, blue {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/blue, :meta {}, :method-params ([color])}, frustum {:variadic false, :protocol-impl nil, :max-fixed-arity 6, :fn-var true, :name quil.core$macros/frustum, :meta {}, :method-params ([left right bottom top near far])}, with-rotation {:macro true, :variadic true, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/with-rotation, :meta {:macro true, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env rotation body)], :arglists ([&form &env rotation & body]), :arglists-meta (nil)}}, :method-params [(&form &env rotation body)]}, print-matrix {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/print-matrix, :meta {}, :method-params ([])}, ambient-light {:variadic false, :protocol-impl nil, :max-fixed-arity 6, :fn-var true, :name quil.core$macros/ambient-light, :meta {:top-fn {:variadic false, :max-fixed-arity 6, :method-params ([red green blue] [red green blue x y z]), :arglists ([red green blue] [red green blue x y z]), :arglists-meta (nil nil)}}, :method-params ([red green blue] [red green blue x y z])}, bezier-point {:variadic false, :protocol-impl nil, :max-fixed-arity 5, :fn-var true, :name quil.core$macros/bezier-point, :meta {}, :method-params ([a b c d t])}, stroke-cap-modes {:name quil.core$macros/stroke-cap-modes, :meta {}}, quad {:variadic false, :protocol-impl nil, :max-fixed-arity 8, :fn-var true, :name quil.core$macros/quad, :meta {}, :method-params ([x1 y1 x2 y2 x3 y3 x4 y4])}, screen-x {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/screen-x, :meta {:top-fn {:variadic false, :max-fixed-arity 3, :method-params ([x y] [x y z]), :arglists ([x y] [x y z]), :arglists-meta (nil nil)}}, :method-params ([x y] [x y z])}, lights {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/lights, :meta {}, :method-params ([])}, *graphics* {:name quil.core$macros/*graphics*, :meta {}}, KEY-CODES {:name quil.core$macros/KEY-CODES, :meta {}}, curve-detail {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/curve-detail, :meta {}, :method-params ([detail])}, current-frame-rate {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/current-frame-rate, :meta {}, :method-params ([])}, end-contour {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/end-contour, :meta {}, :method-params ([])}, sin {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/sin, :meta {}, :method-params ([angle])}, current-stroke {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/current-stroke, :meta {}, :method-params ([])}, curve {:variadic false, :protocol-impl nil, :max-fixed-arity 12, :fn-var true, :name quil.core$macros/curve, :meta {:top-fn {:variadic false, :max-fixed-arity 12, :method-params ([x1 y1 x2 y2 x3 y3 x4 y4] [x1 y1 z1 x2 y2 z2 x3 y3 z3 x4 y4 z4]), :arglists ([x1 y1 x2 y2 x3 y3 x4 y4] [x1 y1 z1 x2 y2 z2 x3 y3 z3 x4 y4 z4]), :arglists-meta (nil nil)}}, :method-params ([x1 y1 x2 y2 x3 y3 x4 y4] [x1 y1 z1 x2 y2 z2 x3 y3 z3 x4 y4 z4])}, shape {:variadic false, :protocol-impl nil, :max-fixed-arity 5, :fn-var true, :name quil.core$macros/shape, :meta {:top-fn {:variadic false, :max-fixed-arity 5, :method-params ([sh] [sh x y] [sh x y width height]), :arglists ([sh] [sh x y] [sh x y width height]), :arglists-meta (nil nil nil)}}, :method-params ([sh] [sh x y] [sh x y width height])}, image-formats {:name quil.core$macros/image-formats, :meta {}}, text-descent {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/text-descent, :meta {}, :method-params ([])}, screen-z {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/screen-z, :meta {}, :method-params ([x y z])}, ambient-int {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/ambient-int, :meta {}, :method-params ([rgb])}, ellipse {:variadic false, :protocol-impl nil, :max-fixed-arity 4, :fn-var true, :name quil.core$macros/ellipse, :meta {}, :method-params ([x y width height])}, text-leading {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/text-leading, :meta {}, :method-params ([leading])}, image-filter {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/image-filter, :meta {:top-fn {:variadic false, :max-fixed-arity 3, :method-params ([img mode] [img mode level]), :arglists ([img mode] [img mode level]), :arglists-meta (nil nil)}}, :method-params ([img mode] [img mode level])}, random {:variadic false, :protocol-impl nil, :max-fixed-arity 2, :fn-var true, :name quil.core$macros/random, :meta {:top-fn {:variadic false, :max-fixed-arity 2, :method-params ([max] [min max]), :arglists ([max] [min max]), :arglists-meta (nil nil)}}, :method-params ([max] [min max])}, texture-mode {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/texture-mode, :meta {}, :method-params ([mode])}, redraw {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/redraw, :meta {}, :method-params ([])}, RAD-TO-DEG {:name quil.core$macros/RAD-TO-DEG, :meta {}}, get-pixel {:variadic false, :protocol-impl nil, :max-fixed-arity 5, :fn-var true, :name quil.core$macros/get-pixel, :meta {:top-fn {:variadic false, :max-fixed-arity 5, :method-params ([] [img] [x y] [img x y] [x y w h] [img x y w h]), :arglists ([] [img] [x y] [img x y] [x y w h] [img x y w h]), :arglists-meta (nil nil nil nil nil nil)}}, :method-params ([] [img] [x y] [img x y] [x y w h] [img x y w h])}, rotate {:variadic false, :protocol-impl nil, :max-fixed-arity 4, :fn-var true, :name quil.core$macros/rotate, :meta {:top-fn {:variadic false, :max-fixed-arity 4, :method-params ([angle] [angle vx vy vz]), :arglists ([angle] [angle vx vy vz]), :arglists-meta (nil nil)}}, :method-params ([angle] [angle vx vy vz])}, set-pixel {:variadic false, :protocol-impl nil, :max-fixed-arity 4, :fn-var true, :name quil.core$macros/set-pixel, :meta {:top-fn {:variadic false, :max-fixed-arity 4, :method-params ([x y c] [img x y c]), :arglists ([x y c] [img x y c]), :arglists-meta (nil nil)}}, :method-params ([x y c] [img x y c])}, push-matrix {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/push-matrix, :meta {}, :method-params ([])}, no-smooth {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/no-smooth, :meta {}, :method-params ([])}, alpha {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/alpha, :meta {}, :method-params ([color])}, camera {:variadic false, :protocol-impl nil, :max-fixed-arity 9, :fn-var true, :name quil.core$macros/camera, :meta {:top-fn {:variadic false, :max-fixed-arity 9, :method-params ([] [eyeX eyeY eyeZ centerX centerY centerZ upX upY upZ]), :arglists ([] [eyeX eyeY eyeZ centerX centerY centerZ upX upY upZ]), :arglists-meta (nil nil)}}, :method-params ([] [eyeX eyeY eyeZ centerX centerY centerZ upX upY upZ])}, translate {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/translate, :meta {:top-fn {:variadic false, :max-fixed-arity 3, :method-params ([v] [tx ty] [tx ty tz]), :arglists ([v] [tx ty] [tx ty tz]), :arglists-meta (nil nil nil)}}, :method-params ([v] [tx ty] [tx ty tz])}, load-font {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/load-font, :meta {}, :method-params ([filename])}, ambient {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/ambient, :meta {:top-fn {:variadic false, :max-fixed-arity 3, :method-params ([rgb] [x y z]), :arglists ([rgb] [x y z]), :arglists-meta (nil nil)}}, :method-params ([rgb] [x y z])}, shear-y {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/shear-y, :meta {}, :method-params ([angle])}, cursor-modes {:name quil.core$macros/cursor-modes, :meta {}}, mouse-y {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/mouse-y, :meta {}, :method-params ([])}, mouse-button {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/mouse-button, :meta {}, :method-params ([])}, p-shape-modes {:name quil.core$macros/p-shape-modes, :meta {}}, image {:variadic false, :protocol-impl nil, :max-fixed-arity 5, :fn-var true, :name quil.core$macros/image, :meta {:top-fn {:variadic false, :max-fixed-arity 5, :method-params ([img x y] [img x y c d]), :arglists ([img x y] [img x y c d]), :arglists-meta (nil nil)}}, :method-params ([img x y] [img x y c d])}, unbinary {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/unbinary, :meta {}, :method-params ([str-val])}, no-tint {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/no-tint, :meta {}, :method-params ([])}, no-lights {:variadic false, :protocol-impl nil, :max-fixed-arity 0, :fn-var true, :name quil.core$macros/no-lights, :meta {}, :method-params ([])}, emissive-int {:variadic false, :protocol-impl nil, :max-fixed-arity 1, :fn-var true, :name quil.core$macros/emissive-int, :meta {}, :method-params ([int-val])}, point {:variadic false, :protocol-impl nil, :max-fixed-arity 3, :fn-var true, :name quil.core$macros/point, :meta {:top-fn {:variadic false, :max-fixed-arity 3, :method-params ([x y] [x y z]), :arglists ([x y] [x y z]), :arglists-meta (nil nil)}}, :method-params ([x y] [x y z])}}, :require-macros {ap quil.sketch, quil.sketch quil.sketch, u quil.util, quil.util quil.util}, :cljs.analyzer/constants {:seen #{:shift .endDraw :open :baseline :disable-stroke-perspective :hsb :quads :arrow :dilate quil.core/current-fill try quil.core/*graphics* :quad-strip :down :disable-depth-mask :burn :posterize quil.sketch/with-sketch :f8 quil.core/translate :screen :enable-depth-test :gray :enable-depth-sort :f1 :corner :disable-texture-mipmaps :darkest :f10 :dodge :bottom :bevel :disable-stroke-pure :replace :alt :top :disable-depth-test finally :pie quil.core/pop-matrix :enable-stroke-perspective let :chord :rgb :lines :argb :move :f5 :command quil.core/stroke tr__13__auto__ :miter :points :hand :close :radius :normal :threshold :up :center :round :disable-optimized-stroke :corners :f11 :opaque :overlay :enable-opengl-errors :enable-stroke-pure :blur :project :triangle-fan :f3 :enable-depth-mask :f2 :control :difference quil.core/push-matrix :square :enable-optimized-stroke :p2d tr__14__auto__ :shape :f12 :exclusion quil.core/fill :disable-opengl-errors :unknown-key :alpha :wait :right quil.core/current-stroke :repeat :hard-light quil.sketch$macros/defsketch :image :multiply binding :lightest quil.core/rotate :f7 :blend :disable-depth-sort :f9 :erode :add :soft-light :subtract :clamp apply :f6 :f4 :triangle-strip old-fill__11__auto__ :cross old-stroke__12__auto__ :triangles .beginDraw :left :invert :text :enable-texture-mipmaps :model}, :order [:open :chord :pie :arrow :cross :hand :move :text :wait :points :lines :triangles :triangle-fan :triangle-strip :quads :quad-strip :burn :screen :darkest :dodge :replace :overlay :difference :exclusion :hard-light :multiply :lightest :blend :add :soft-light :subtract :rgb :hsb :argb :alpha :center :radius :corner :corners :disable-stroke-perspective :disable-depth-mask :enable-depth-test :enable-depth-sort :disable-texture-mipmaps :disable-stroke-pure :disable-depth-test :enable-stroke-perspective :disable-optimized-stroke :enable-opengl-errors :enable-stroke-pure :enable-depth-mask :enable-optimized-stroke :disable-opengl-errors :disable-depth-sort :enable-texture-mipmaps :square :round :project :model :miter :bevel :left :right :top :bottom :baseline :shape :image :normal :clamp :repeat :threshold :gray :invert :posterize :blur :opaque :erode :dilate :up :down :shift :f1 :control :f2 :alt :f3 :f4 :f5 :f6 :f7 :f8 :f9 :f10 :f11 :f12 :command quil.sketch/with-sketch :p2d :close let old-fill__11__auto__ quil.core/current-fill apply quil.core/fill old-stroke__12__auto__ quil.core/current-stroke quil.core/stroke tr__13__auto__ quil.core/push-matrix try quil.core/translate finally quil.core/pop-matrix tr__14__auto__ quil.core/rotate binding quil.core/*graphics* .beginDraw .endDraw quil.sketch$macros/defsketch :unknown-key]}, :doc nil}, :source "goog.provide(\"quil.core$macros\");\nquil.core$macros._STAR_graphics_STAR_ = null;\nquil.core$macros.no_fill_prop = \"no-fill-quil\";\n/**\n * Graphics currently used for drawing. By default it is sketch graphics,\n *   but if called inside with-graphics macro - graphics passed to the macro\n *   is returned. This method should be used if you need to call some methods\n *   that are not implemented by quil. Example:\n *   (.beginDraw (current-graphics)).\n */\nquil.core$macros.current_graphics = (function quil$core$macros$current_graphics(){\nvar or__10278__auto__ = quil.core$macros._STAR_graphics_STAR_;\nif(cljs.core.truth_(or__10278__auto__)){\nreturn or__10278__auto__;\n} else {\nreturn quil.sketch.current_applet.call(null);\n}\n});\nquil.core$macros.arc_modes = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"open\",\"open\",(-1763596448)),(Processing.prototype.PConstants[\"OPEN\"]),new cljs.core.Keyword(null,\"chord\",\"chord\",(-696248342)),(Processing.prototype.PConstants[\"CHORD\"]),new cljs.core.Keyword(null,\"pie\",\"pie\",(1530441672)),(Processing.prototype.PConstants[\"PIE\"])], null);\n\nquil.core$macros.shape_modes = new cljs.core.PersistentArrayMap(null, 7, [new cljs.core.Keyword(null,\"points\",\"points\",(-1486596883)),(Processing.prototype.PConstants[\"POINTS\"]),new cljs.core.Keyword(null,\"lines\",\"lines\",(-700165781)),(Processing.prototype.PConstants[\"LINES\"]),new cljs.core.Keyword(null,\"triangles\",\"triangles\",(-1525417058)),(Processing.prototype.PConstants[\"TRIANGLES\"]),new cljs.core.Keyword(null,\"triangle-fan\",\"triangle-fan\",(1743150739)),(Processing.prototype.PConstants[\"TRIANGLE_FAN\"]),new cljs.core.Keyword(null,\"triangle-strip\",\"triangle-strip\",(221845500)),(Processing.prototype.PConstants[\"TRIANGLE_STRIP\"]),new cljs.core.Keyword(null,\"quads\",\"quads\",(1347497505)),(Processing.prototype.PConstants[\"QUADS\"]),new cljs.core.Keyword(null,\"quad-strip\",\"quad-strip\",(-1297270686)),(Processing.prototype.PConstants[\"QUAD_STRIP\"])], null);\n\nquil.core$macros.blend_modes = cljs.core.PersistentHashMap.fromArrays([new cljs.core.Keyword(null,\"burn\",\"burn\",(-458179293)),new cljs.core.Keyword(null,\"screen\",\"screen\",(1990059748)),new cljs.core.Keyword(null,\"darkest\",\"darkest\",(68197253)),new cljs.core.Keyword(null,\"dodge\",\"dodge\",(-1556666427)),new cljs.core.Keyword(null,\"replace\",\"replace\",(-786587770)),new cljs.core.Keyword(null,\"overlay\",\"overlay\",(-139131598)),new cljs.core.Keyword(null,\"difference\",\"difference\",(1916101396)),new cljs.core.Keyword(null,\"exclusion\",\"exclusion\",(531897910)),new cljs.core.Keyword(null,\"hard-light\",\"hard-light\",(-37591145)),new cljs.core.Keyword(null,\"multiply\",\"multiply\",(-1036907048)),new cljs.core.Keyword(null,\"lightest\",\"lightest\",(-2043115912)),new cljs.core.Keyword(null,\"blend\",\"blend\",(249565561)),new cljs.core.Keyword(null,\"add\",\"add\",(235287739)),new cljs.core.Keyword(null,\"soft-light\",\"soft-light\",(513207899)),new cljs.core.Keyword(null,\"subtract\",\"subtract\",(2136988635))],[(Processing.prototype.PConstants[\"BURN\"]),(Processing.prototype.PConstants[\"SCREEN\"]),(Processing.prototype.PConstants[\"DARKEST\"]),(Processing.prototype.PConstants[\"DODGE\"]),(Processing.prototype.PConstants[\"REPLACE\"]),(Processing.prototype.PConstants[\"OVERLAY\"]),(Processing.prototype.PConstants[\"DIFFERENCE\"]),(Processing.prototype.PConstants[\"EXCLUSION\"]),(Processing.prototype.PConstants[\"HARD_LIGHT\"]),(Processing.prototype.PConstants[\"MULTIPLY\"]),(Processing.prototype.PConstants[\"LIGHTEST\"]),(Processing.prototype.PConstants[\"BLEND\"]),(Processing.prototype.PConstants[\"ADD\"]),(Processing.prototype.PConstants[\"SOFT_LIGHT\"]),(Processing.prototype.PConstants[\"SUBTRACT\"])]);\n\nquil.core$macros.color_modes = new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"rgb\",\"rgb\",(1432123467)),(Processing.prototype.PConstants[\"RGB\"]),new cljs.core.Keyword(null,\"hsb\",\"hsb\",(-753472031)),(Processing.prototype.PConstants[\"HSB\"])], null);\n\nquil.core$macros.image_formats = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"rgb\",\"rgb\",(1432123467)),(Processing.prototype.PConstants[\"RGB\"]),new cljs.core.Keyword(null,\"argb\",\"argb\",(633844107)),(Processing.prototype.PConstants[\"ARGB\"]),new cljs.core.Keyword(null,\"alpha\",\"alpha\",(-1574982441)),(Processing.prototype.PConstants[\"ALPHA\"])], null);\n\nquil.core$macros.ellipse_modes = new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"center\",\"center\",(-748944368)),(Processing.prototype.PConstants[\"CENTER\"]),new cljs.core.Keyword(null,\"radius\",\"radius\",(-2073122258)),(Processing.prototype.PConstants[\"RADIUS\"]),new cljs.core.Keyword(null,\"corner\",\"corner\",(1296717125)),(Processing.prototype.PConstants[\"CORNER\"]),new cljs.core.Keyword(null,\"corners\",\"corners\",(-137817903)),(Processing.prototype.PConstants[\"CORNERS\"])], null);\n\nquil.core$macros.hint_options = cljs.core.PersistentHashMap.fromArrays([new cljs.core.Keyword(null,\"disable-stroke-perspective\",\"disable-stroke-perspective\",(479198433)),new cljs.core.Keyword(null,\"disable-depth-mask\",\"disable-depth-mask\",(3298562)),new cljs.core.Keyword(null,\"enable-depth-test\",\"enable-depth-test\",(1519326084)),new cljs.core.Keyword(null,\"enable-depth-sort\",\"enable-depth-sort\",(-383089627)),new cljs.core.Keyword(null,\"disable-texture-mipmaps\",\"disable-texture-mipmaps\",(1697917541)),new cljs.core.Keyword(null,\"disable-stroke-pure\",\"disable-stroke-pure\",(735493926)),new cljs.core.Keyword(null,\"disable-depth-test\",\"disable-depth-test\",(284606407)),new cljs.core.Keyword(null,\"enable-stroke-perspective\",\"enable-stroke-perspective\",(-259923319)),new cljs.core.Keyword(null,\"disable-optimized-stroke\",\"disable-optimized-stroke\",(74038544)),new cljs.core.Keyword(null,\"enable-opengl-errors\",\"enable-opengl-errors\",(89998962)),new cljs.core.Keyword(null,\"enable-stroke-pure\",\"enable-stroke-pure\",(881345587)),new cljs.core.Keyword(null,\"enable-depth-mask\",\"enable-depth-mask\",(872785875)),new cljs.core.Keyword(null,\"enable-optimized-stroke\",\"enable-optimized-stroke\",(1537575253)),new cljs.core.Keyword(null,\"disable-opengl-errors\",\"disable-opengl-errors\",(506822839)),new cljs.core.Keyword(null,\"disable-depth-sort\",\"disable-depth-sort\",(-1568352839)),new cljs.core.Keyword(null,\"enable-texture-mipmaps\",\"enable-texture-mipmaps\",(1241892671))],[(Processing.prototype.PConstants[\"DISABLE_STROKE_PERSPECTIVE\"]),(Processing.prototype.PConstants[\"DISABLE_DEPTH_MASK\"]),(Processing.prototype.PConstants[\"ENABLE_DEPTH_TEST\"]),(Processing.prototype.PConstants[\"ENABLE_DEPTH_SORT\"]),(Processing.prototype.PConstants[\"DISABLE_TEXTURE_MIPMAPS\"]),(Processing.prototype.PConstants[\"DISABLE_STROKE_PURE\"]),(Processing.prototype.PConstants[\"DISABLE_DEPTH_TEST\"]),(Processing.prototype.PConstants[\"ENABLE_STROKE_PERSPECTIVE\"]),(Processing.prototype.PConstants[\"DISABLE_OPTIMIZED_STROKE\"]),(Processing.prototype.PConstants[\"ENABLE_OPENGL_ERRORS\"]),(Processing.prototype.PConstants[\"ENABLE_STROKE_PURE\"]),(Processing.prototype.PConstants[\"ENABLE_DEPTH_MASK\"]),(Processing.prototype.PConstants[\"ENABLE_OPTIMIZED_STROKE\"]),(Processing.prototype.PConstants[\"DISABLE_OPENGL_ERRORS\"]),(Processing.prototype.PConstants[\"DISABLE_DEPTH_SORT\"]),(Processing.prototype.PConstants[\"ENABLE_TEXTURE_MIPMAPS\"])]);\n\nquil.core$macros.image_modes = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"corner\",\"corner\",(1296717125)),(Processing.prototype.PConstants[\"CORNER\"]),new cljs.core.Keyword(null,\"corners\",\"corners\",(-137817903)),(Processing.prototype.PConstants[\"CORNERS\"]),new cljs.core.Keyword(null,\"center\",\"center\",(-748944368)),(Processing.prototype.PConstants[\"CENTER\"])], null);\n\nquil.core$macros.rect_modes = new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"corner\",\"corner\",(1296717125)),(Processing.prototype.PConstants[\"CORNER\"]),new cljs.core.Keyword(null,\"corners\",\"corners\",(-137817903)),(Processing.prototype.PConstants[\"CORNERS\"]),new cljs.core.Keyword(null,\"center\",\"center\",(-748944368)),(Processing.prototype.PConstants[\"CENTER\"]),new cljs.core.Keyword(null,\"radius\",\"radius\",(-2073122258)),(Processing.prototype.PConstants[\"RADIUS\"])], null);\n\nquil.core$macros.p_shape_modes = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"corner\",\"corner\",(1296717125)),(Processing.prototype.PConstants[\"CORNER\"]),new cljs.core.Keyword(null,\"corners\",\"corners\",(-137817903)),(Processing.prototype.PConstants[\"CORNERS\"]),new cljs.core.Keyword(null,\"center\",\"center\",(-748944368)),(Processing.prototype.PConstants[\"CENTER\"])], null);\n\nquil.core$macros.stroke_cap_modes = new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"square\",\"square\",(812434677)),(Processing.prototype.PConstants[\"SQUARE\"]),new cljs.core.Keyword(null,\"round\",\"round\",(2009433328)),(Processing.prototype.PConstants[\"ROUND\"]),new cljs.core.Keyword(null,\"project\",\"project\",(1124394579)),(Processing.prototype.PConstants[\"PROJECT\"]),new cljs.core.Keyword(null,\"model\",\"model\",(331153215)),(Processing.prototype.PConstants[\"MODEL\"])], null);\n\nquil.core$macros.stroke_join_modes = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"miter\",\"miter\",(327727052)),(Processing.prototype.PConstants[\"MITER\"]),new cljs.core.Keyword(null,\"bevel\",\"bevel\",(2090515654)),(Processing.prototype.PConstants[\"BEVEL\"]),new cljs.core.Keyword(null,\"round\",\"round\",(2009433328)),(Processing.prototype.PConstants[\"ROUND\"])], null);\n\nquil.core$macros.horizontal_alignment_modes = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"left\",\"left\",(-399115937)),(Processing.prototype.PConstants[\"LEFT\"]),new cljs.core.Keyword(null,\"center\",\"center\",(-748944368)),(Processing.prototype.PConstants[\"CENTER\"]),new cljs.core.Keyword(null,\"right\",\"right\",(-452581833)),(Processing.prototype.PConstants[\"RIGHT\"])], null);\n\nquil.core$macros.vertical_alignment_modes = new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"top\",\"top\",(-1856271961)),(Processing.prototype.PConstants[\"TOP\"]),new cljs.core.Keyword(null,\"bottom\",\"bottom\",(-1550509018)),(Processing.prototype.PConstants[\"BOTTOM\"]),new cljs.core.Keyword(null,\"center\",\"center\",(-748944368)),(Processing.prototype.PConstants[\"CENTER\"]),new cljs.core.Keyword(null,\"baseline\",\"baseline\",(1151033280)),(Processing.prototype.PConstants[\"BASELINE\"])], null);\n\nquil.core$macros.text_modes = new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"model\",\"model\",(331153215)),(Processing.prototype.PConstants[\"MODEL\"]),new cljs.core.Keyword(null,\"shape\",\"shape\",(1190694006)),(Processing.prototype.PConstants[\"SHAPE\"])], null);\n\nquil.core$macros.texture_modes = new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"image\",\"image\",(-58725096)),(Processing.prototype.PConstants[\"IMAGE\"]),new cljs.core.Keyword(null,\"normal\",\"normal\",(-1519123858)),(Processing.prototype.PConstants[\"NORMAL\"])], null);\n\nquil.core$macros.texture_wrap_modes = new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"clamp\",\"clamp\",(1803814940)),(Processing.prototype.PConstants[\"CLAMP\"]),new cljs.core.Keyword(null,\"repeat\",\"repeat\",(832692087)),(Processing.prototype.PConstants[\"REPEAT\"])], null);\n\nquil.core$macros.filter_modes = new cljs.core.PersistentArrayMap(null, 8, [new cljs.core.Keyword(null,\"threshold\",\"threshold\",(204221583)),(Processing.prototype.PConstants[\"THRESHOLD\"]),new cljs.core.Keyword(null,\"gray\",\"gray\",(1013268388)),(Processing.prototype.PConstants[\"GRAY\"]),new cljs.core.Keyword(null,\"invert\",\"invert\",(1553577503)),(Processing.prototype.PConstants[\"INVERT\"]),new cljs.core.Keyword(null,\"posterize\",\"posterize\",(-148251901)),(Processing.prototype.PConstants[\"POSTERIZE\"]),new cljs.core.Keyword(null,\"blur\",\"blur\",(-453500461)),(Processing.prototype.PConstants[\"BLUR\"]),new cljs.core.Keyword(null,\"opaque\",\"opaque\",(-1243552654)),(Processing.prototype.PConstants[\"OPAQUE\"]),new cljs.core.Keyword(null,\"erode\",\"erode\",(1539530618)),(Processing.prototype.PConstants[\"ERODE\"]),new cljs.core.Keyword(null,\"dilate\",\"dilate\",(1504745153)),(Processing.prototype.PConstants[\"DILATE\"])], null);\n\nquil.core$macros.cursor_modes = new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\"arrow\",\"arrow\",(1071351425)),(Processing.prototype.PConstants[\"ARROW\"]),new cljs.core.Keyword(null,\"cross\",\"cross\",(194557789)),(Processing.prototype.PConstants[\"CROSS\"]),new cljs.core.Keyword(null,\"hand\",\"hand\",(791601933)),(Processing.prototype.PConstants[\"HAND\"]),new cljs.core.Keyword(null,\"move\",\"move\",(-2110884309)),(Processing.prototype.PConstants[\"MOVE\"]),new cljs.core.Keyword(null,\"text\",\"text\",(-1790561697)),(Processing.prototype.PConstants[\"TEXT\"]),new cljs.core.Keyword(null,\"wait\",\"wait\",(-260664777)),(Processing.prototype.PConstants[\"WAIT\"])], null);\nquil.core$macros.PI = Math.PI;\nquil.core$macros.HALF_PI = (quil.core$macros.PI / (2));\nquil.core$macros.THIRD_PI = (quil.core$macros.PI / (3));\nquil.core$macros.QUARTER_PI = (quil.core$macros.PI / (4));\nquil.core$macros.TWO_PI = (quil.core$macros.PI * (2));\nquil.core$macros.DEG_TO_RAD = (quil.core$macros.PI / (180));\nquil.core$macros.RAD_TO_DEG = ((180) / quil.core$macros.PI);\nquil.core$macros.KEY_CODES = cljs.core.PersistentHashMap.fromArrays([(37),(38),(39),(40),(16),(112),(17),(113),(18),(114),(115),(116),(117),(118),(119),(120),(121),(122),(123),(157)],[new cljs.core.Keyword(null,\"left\",\"left\",(-399115937)),new cljs.core.Keyword(null,\"up\",\"up\",(-269712113)),new cljs.core.Keyword(null,\"right\",\"right\",(-452581833)),new cljs.core.Keyword(null,\"down\",\"down\",(1565245570)),new cljs.core.Keyword(null,\"shift\",\"shift\",(997140064)),new cljs.core.Keyword(null,\"f1\",\"f1\",(1714532389)),new cljs.core.Keyword(null,\"control\",\"control\",(1892578036)),new cljs.core.Keyword(null,\"f2\",\"f2\",(396168596)),new cljs.core.Keyword(null,\"alt\",\"alt\",(-3214426)),new cljs.core.Keyword(null,\"f3\",\"f3\",(1954829043)),new cljs.core.Keyword(null,\"f4\",\"f4\",(990968764)),new cljs.core.Keyword(null,\"f5\",\"f5\",(1587057387)),new cljs.core.Keyword(null,\"f6\",\"f6\",(2103080604)),new cljs.core.Keyword(null,\"f7\",\"f7\",(356150168)),new cljs.core.Keyword(null,\"f8\",\"f8\",(-2141475484)),new cljs.core.Keyword(null,\"f9\",\"f9\",(704633338)),new cljs.core.Keyword(null,\"f10\",\"f10\",(627525541)),new cljs.core.Keyword(null,\"f11\",\"f11\",(-1417398799)),new cljs.core.Keyword(null,\"f12\",\"f12\",(853352790)),new cljs.core.Keyword(null,\"command\",\"command\",(-894540724))]);\n/**\n * Writes to the text area of the Processing environment's console.\n *   This is often helpful for looking at the data a program is producing.\n *   Each call to this function creates a new line of output.\n *   Individual elements can be separated with quotes (\"\") and joined with the string concatenation operator (+).\n *   Also writes the content of an array to the text area of the Processing environment.\n *   This is often helpful for looking at the data a program is producing.\n *   A new line is put between each element of the array. This function can only print 1D arrays,\n *   but can test to see if the content are null or not null for 2+ dimensional arrays.\n */\nquil.core$macros.prc_println = (function quil$core$macros$prc_println(msg){\nreturn quil.sketch.current_applet.call(null).println(msg);\n});\n/**\n * Writes to the console area of the Processing environment.\n *   This is often helpful for looking at the data a program is producing.\n *   The companion function println() works like print(), but creates a new line of text for each call to the function.\n * Individual elements can be separated with quotes (\"\") and joined with the addition operator (+). \n */\nquil.core$macros.prc_print = (function quil$core$macros$prc_print(msg){\nreturn quil.sketch.current_applet.call(null).print(msg);\n});\n/**\n * Returns sketch object by id of canvas element of sketch.\n */\nquil.core$macros.get_sketch_by_id = (function quil$core$macros$get_sketch_by_id(id){\nreturn Processing.getInstanceById(id);\n});\nquil.core$macros.with_sketch = (function quil$core$macros$with_sketch(var_args){\nvar args__11136__auto__ = [];\nvar len__11134__auto___95 = arguments.length;\nvar i__11135__auto___96 = (0);\nwhile(true){\nif((i__11135__auto___96 < len__11134__auto___95)){\nargs__11136__auto__.push((arguments[i__11135__auto___96]));\n\nvar G__97 = (i__11135__auto___96 + (1));\ni__11135__auto___96 = G__97;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__11137__auto__ = ((((3) < args__11136__auto__.length))?(new cljs.core.IndexedSeq(args__11136__auto__.slice((3)),(0),null)):null);\nreturn quil.core$macros.with_sketch.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__11137__auto__);\n});\n\nquil.core$macros.with_sketch.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,applet,body){\nif(cljs.core.truth_(quil.util.clj_compilation_QMARK_.call(null))){\nreturn null;\n} else {\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.sketch\",\"with-sketch\",\"quil.sketch/with-sketch\",(-634067708),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,applet),body));\n}\n});\n\nquil.core$macros.with_sketch.cljs$lang$maxFixedArity = (3);\n\nquil.core$macros.with_sketch.cljs$lang$applyTo = (function (seq91){\nvar G__92 = cljs.core.first.call(null,seq91);\nvar seq91__$1 = cljs.core.next.call(null,seq91);\nvar G__93 = cljs.core.first.call(null,seq91__$1);\nvar seq91__$2 = cljs.core.next.call(null,seq91__$1);\nvar G__94 = cljs.core.first.call(null,seq91__$2);\nvar seq91__$3 = cljs.core.next.call(null,seq91__$2);\nreturn quil.core$macros.with_sketch.cljs$core$IFn$_invoke$arity$variadic(G__92,G__93,G__94,seq91__$3);\n});\n\nquil.core$macros.with_sketch.cljs$lang$macro = true;\n/**\n * Retrieve sketch-specific state-atom. All changes to the\n *   atom will be reflected in the state.\n * \n *   (set-state! :foo 1)\n *   (state :foo) ;=> 1\n *   (swap! (state-atom) update-in [:foo] inc)\n *   (state :foo) ;=> 2\n */\nquil.core$macros.state_atom = (function quil$core$macros$state_atom(){\nreturn quil.sketch.current_applet.call(null).quil;\n});\n/**\n * Retrieve sketch-specific state by key. Must initially call\n *   set-state! to store state. If no parameter passed whole\n *   state map is returned.\n * \n *   (set-state! :foo 1)\n *   (state :foo) ;=> 1\n *   (state) ;=> {:foo 1}\n */\nquil.core$macros.state = (function quil$core$macros$state(var_args){\nvar args98 = [];\nvar len__11134__auto___101 = arguments.length;\nvar i__11135__auto___102 = (0);\nwhile(true){\nif((i__11135__auto___102 < len__11134__auto___101)){\nargs98.push((arguments[i__11135__auto___102]));\n\nvar G__103 = (i__11135__auto___102 + (1));\ni__11135__auto___102 = G__103;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__100 = args98.length;\nswitch (G__100) {\ncase (0):\nreturn quil.core$macros.state.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.state.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args98.length)].join('')));\n\n}\n});\n\nquil.core$macros.state.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn cljs.core.deref.call(null,quil.core$macros.state_atom.call(null));\n});\n\nquil.core$macros.state.cljs$core$IFn$_invoke$arity$1 = (function (key){\nvar state = quil.core$macros.state.call(null);\nif(cljs.core.contains_QMARK_.call(null,state,key)){\n} else {\nthrow Error([cljs.core.str(\"Unable to find state with key: \"),cljs.core.str(key)].join(''));\n}\n\nreturn cljs.core.get.call(null,state,key);\n});\n\nquil.core$macros.state.cljs$lang$maxFixedArity = (1);\n/**\n * Set sketch-specific state. May only be called once (ideally in the\n *   setup fn).  Subsequent calls have no effect.\n * \n *   Example:\n *   (set-state! :foo 1 :bar (atom true) :baz (/ (width) 2))\n */\nquil.core$macros.set_state_BANG_ = (function quil$core$macros$set_state_BANG_(var_args){\nvar args__11136__auto__ = [];\nvar len__11134__auto___106 = arguments.length;\nvar i__11135__auto___107 = (0);\nwhile(true){\nif((i__11135__auto___107 < len__11134__auto___106)){\nargs__11136__auto__.push((arguments[i__11135__auto___107]));\n\nvar G__108 = (i__11135__auto___107 + (1));\ni__11135__auto___107 = G__108;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__11137__auto__ = ((((0) < args__11136__auto__.length))?(new cljs.core.IndexedSeq(args__11136__auto__.slice((0)),(0),null)):null);\nreturn quil.core$macros.set_state_BANG_.cljs$core$IFn$_invoke$arity$variadic(argseq__11137__auto__);\n});\n\nquil.core$macros.set_state_BANG_.cljs$core$IFn$_invoke$arity$variadic = (function (state_vals){\nvar state_STAR_ = quil.core$macros.state_atom.call(null);\nif(cljs.core.truth_(cljs.core.deref.call(null,state_STAR_))){\nreturn null;\n} else {\nvar state_map = cljs.core.apply.call(null,cljs.core.hash_map,state_vals);\nreturn cljs.core.reset_BANG_.call(null,state_STAR_,state_map);\n}\n});\n\nquil.core$macros.set_state_BANG_.cljs$lang$maxFixedArity = (0);\n\nquil.core$macros.set_state_BANG_.cljs$lang$applyTo = (function (seq105){\nreturn quil.core$macros.set_state_BANG_.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq.call(null,seq105));\n});\n/**\n * Calculates the absolute value (magnitude) of a number. The\n *   absolute value of a number is always positive. Dynamically casts to\n *   an int or float appropriately\n */\nquil.core$macros.abs = (function quil$core$macros$abs(n){\nreturn quil.sketch.current_applet.call(null).abs(n);\n});\n/**\n * The inverse of cos, returns the arc cosine of a value. This\n *   function expects the values in the range of -1 to 1 and values are\n *   returned in the range 0 to Math/PI (3.1415927).\n */\nquil.core$macros.acos = (function quil$core$macros$acos(n){\nreturn quil.sketch.current_applet.call(null).acos(n);\n});\n/**\n * Extracts the alpha value from a color.\n */\nquil.core$macros.alpha = (function quil$core$macros$alpha(color){\nreturn quil.core$macros.current_graphics.call(null).alpha(cljs.core.unchecked_int.call(null,color));\n});\n/**\n * Sets the ambient reflectance for shapes drawn to the screen. This\n *   is combined with the ambient light component of environment. The\n *   color components set through the parameters define the\n *   reflectance. For example in the default color mode, setting x=255,\n *   y=126, z=0, would cause all the red light to reflect and half of the\n *   green light to reflect. Used in combination with emissive, specular,\n *   and shininess in setting the material properties of shapes.\n */\nquil.core$macros.ambient_float = (function quil$core$macros$ambient_float(var_args){\nvar args109 = [];\nvar len__11134__auto___112 = arguments.length;\nvar i__11135__auto___113 = (0);\nwhile(true){\nif((i__11135__auto___113 < len__11134__auto___112)){\nargs109.push((arguments[i__11135__auto___113]));\n\nvar G__114 = (i__11135__auto___113 + (1));\ni__11135__auto___113 = G__114;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__111 = args109.length;\nswitch (G__111) {\ncase (1):\nreturn quil.core$macros.ambient_float.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.ambient_float.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args109.length)].join('')));\n\n}\n});\n\nquil.core$macros.ambient_float.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nreturn quil.core$macros.current_graphics.call(null).ambient(gray);\n});\n\nquil.core$macros.ambient_float.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.current_graphics.call(null).ambient(x,y,z);\n});\n\nquil.core$macros.ambient_float.cljs$lang$maxFixedArity = (3);\n/**\n * Sets the ambient reflectance for shapes drawn to the screen. This\n *   is combined with the ambient light component of environment. The rgb\n *   color components set define the reflectance. Used in combination\n *   with emissive, specular, and shininess in setting the material\n *   properties of shapes.\n */\nquil.core$macros.ambient_int = (function quil$core$macros$ambient_int(rgb){\nreturn quil.core$macros.current_graphics.call(null).ambient((rgb | (0)));\n});\n/**\n * Sets the ambient reflectance for shapes drawn to the screen. This\n *   is combined with the ambient light component of environment. The\n *   color components set through the parameters define the\n *   reflectance. For example in the default color mode, setting x=255,\n *   y=126, z=0, would cause all the red light to reflect and half of the\n *   green light to reflect. Used in combination with emissive, specular,\n *   and shininess in setting the material properties of shapes.\n */\nquil.core$macros.ambient = (function quil$core$macros$ambient(var_args){\nvar args116 = [];\nvar len__11134__auto___119 = arguments.length;\nvar i__11135__auto___120 = (0);\nwhile(true){\nif((i__11135__auto___120 < len__11134__auto___119)){\nargs116.push((arguments[i__11135__auto___120]));\n\nvar G__121 = (i__11135__auto___120 + (1));\ni__11135__auto___120 = G__121;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__118 = args116.length;\nswitch (G__118) {\ncase (1):\nreturn quil.core$macros.ambient.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.ambient.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args116.length)].join('')));\n\n}\n});\n\nquil.core$macros.ambient.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core$macros.ambient_float.call(null,rgb);\n});\n\nquil.core$macros.ambient.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.ambient_float.call(null,x,y,z);\n});\n\nquil.core$macros.ambient.cljs$lang$maxFixedArity = (3);\n/**\n * Adds an ambient light. Ambient light doesn't come from a specific direction,\n *   the rays have light have bounced around so much that objects are\n *   evenly lit from all sides. Ambient lights are almost always used in\n *   combination with other types of lights. Lights need to be included\n *   in the draw to remain persistent in a looping program. Placing them\n *   in the setup of a looping program will cause them to only have an\n *   effect the first time through the loop. The effect of the\n *   parameters is determined by the current color mode.\n */\nquil.core$macros.ambient_light = (function quil$core$macros$ambient_light(var_args){\nvar args123 = [];\nvar len__11134__auto___126 = arguments.length;\nvar i__11135__auto___127 = (0);\nwhile(true){\nif((i__11135__auto___127 < len__11134__auto___126)){\nargs123.push((arguments[i__11135__auto___127]));\n\nvar G__128 = (i__11135__auto___127 + (1));\ni__11135__auto___127 = G__128;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__125 = args123.length;\nswitch (G__125) {\ncase (3):\nreturn quil.core$macros.ambient_light.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (6):\nreturn quil.core$macros.ambient_light.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args123.length)].join('')));\n\n}\n});\n\nquil.core$macros.ambient_light.cljs$core$IFn$_invoke$arity$3 = (function (red,green,blue){\nreturn quil.core$macros.current_graphics.call(null).ambientLight(red,green,blue);\n});\n\nquil.core$macros.ambient_light.cljs$core$IFn$_invoke$arity$6 = (function (red,green,blue,x,y,z){\nreturn quil.core$macros.current_graphics.call(null).ambientLight(red,green,blue,x,y,z);\n});\n\nquil.core$macros.ambient_light.cljs$lang$maxFixedArity = (6);\n/**\n * Multiplies the current matrix by the one specified through the\n *   parameters. This is very slow because it will try to calculate the\n *   inverse of the transform, so avoid it whenever possible. The\n *   equivalent function in OpenGL is glMultMatrix().\n */\nquil.core$macros.apply_matrix = (function quil$core$macros$apply_matrix(n00,n01,n02,n03,n10,n11,n12,n13,n20,n21,n22,n23,n30,n31,n32,n33){\nreturn quil.core$macros.current_graphics.call(null).applyMatrix(n00,n01,n02,n03,n10,n11,n12,n13,n20,n21,n22,n23,n30,n31,n32,n33);\n});\n/**\n * Draws an arc in the display window. Arcs are drawn along the outer\n *   edge of an ellipse defined by the x, y, width and height\n *   parameters. The origin or the arc's ellipse may be changed with the\n *   ellipse-mode function. The start and stop parameters specify the\n *   angles at which to draw the arc. The mode is either :open, :chord or :pie.\n */\nquil.core$macros.arc = (function quil$core$macros$arc(x,y,width,height,start,stop){\nreturn quil.core$macros.current_graphics.call(null).arc(x,y,width,height,start,stop);\n});\n/**\n * The inverse of sin, returns the arc sine of a value. This function\n *   expects the values in the range of -1 to 1 and values are returned\n *   in the range -PI/2 to PI/2.\n */\nquil.core$macros.asin = (function quil$core$macros$asin(n){\nreturn quil.sketch.current_applet.call(null).asin(n);\n});\n/**\n * The inverse of tan, returns the arc tangent of a value. This\n *   function expects the values in the range of -Infinity to\n *   Infinity (exclusive) and values are returned in the range -PI/2 to\n *   PI/2 .\n */\nquil.core$macros.atan = (function quil$core$macros$atan(n){\nreturn quil.sketch.current_applet.call(null).atan(n);\n});\n/**\n * Calculates the angle (in radians) from a specified point to the\n *   coordinate origin as measured from the positive x-axis. Values are\n *   returned as a float in the range from PI to -PI. The atan2 function\n *   is most often used for orienting geometry to the position of the\n *   cursor. Note: The y-coordinate of the point is the first parameter\n *   and the x-coordinate is the second due to the structure of\n *   calculating the tangent.\n */\nquil.core$macros.atan2 = (function quil$core$macros$atan2(y,x){\nreturn quil.sketch.current_applet.call(null).atan2(y,x);\n});\n/**\n * A sequence of strings representing the fonts on this system\n *   available for use.\n * \n *   Because of limitations in Java, not all fonts can be used and some\n *   might work with one operating system and not others. When sharing a\n *   sketch with other people or posting it on the web, you may need to\n *   include a .ttf or .otf version of your font in the data directory of\n *   the sketch because other people might not have the font installed on\n *   their computer. Only fonts that can legally be distributed should be\n *   included with a sketch.\n */\nquil.core$macros.available_fonts = (function quil$core$macros$available_fonts(){\nreturn cljs.core.seq.call(null,PFont.list());\n});\n/**\n * Sets the color used for the background of the Processing\n *   window. The default background is light gray. In the draw function,\n *   the background color is used to clear the display window at the\n *   beginning of each frame.\n * \n *   It is not possible to use transparency (alpha) in background colors\n *   with the main drawing surface, however they will work properly with\n *   create-graphics. Converts args to floats.\n */\nquil.core$macros.background_float = (function quil$core$macros$background_float(var_args){\nvar args130 = [];\nvar len__11134__auto___133 = arguments.length;\nvar i__11135__auto___134 = (0);\nwhile(true){\nif((i__11135__auto___134 < len__11134__auto___133)){\nargs130.push((arguments[i__11135__auto___134]));\n\nvar G__135 = (i__11135__auto___134 + (1));\ni__11135__auto___134 = G__135;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__132 = args130.length;\nswitch (G__132) {\ncase (1):\nreturn quil.core$macros.background_float.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.background_float.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.background_float.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.background_float.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args130.length)].join('')));\n\n}\n});\n\nquil.core$macros.background_float.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nreturn quil.core$macros.current_graphics.call(null).background(gray);\n});\n\nquil.core$macros.background_float.cljs$core$IFn$_invoke$arity$2 = (function (gray,alpha){\nreturn quil.core$macros.current_graphics.call(null).background(gray,alpha);\n});\n\nquil.core$macros.background_float.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core$macros.current_graphics.call(null).background(r,g,b);\n});\n\nquil.core$macros.background_float.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,a){\nreturn quil.core$macros.current_graphics.call(null).background(r,g,b,a);\n});\n\nquil.core$macros.background_float.cljs$lang$maxFixedArity = (4);\n/**\n * Sets the color used for the background of the Processing\n *   window. The default background is light gray. In the draw function,\n *   the background color is used to clear the display window at the\n *   beginning of each frame.\n * \n *   It is not possible to use transparency (alpha) in background colors\n *   with the main drawing surface, however they will work properly with\n *   create-graphics. Converts rgb to an int and alpha to a float.\n */\nquil.core$macros.background_int = (function quil$core$macros$background_int(var_args){\nvar args137 = [];\nvar len__11134__auto___140 = arguments.length;\nvar i__11135__auto___141 = (0);\nwhile(true){\nif((i__11135__auto___141 < len__11134__auto___140)){\nargs137.push((arguments[i__11135__auto___141]));\n\nvar G__142 = (i__11135__auto___141 + (1));\ni__11135__auto___141 = G__142;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__139 = args137.length;\nswitch (G__139) {\ncase (1):\nreturn quil.core$macros.background_int.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.background_int.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args137.length)].join('')));\n\n}\n});\n\nquil.core$macros.background_int.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core$macros.current_graphics.call(null).background(cljs.core.unchecked_int.call(null,rgb));\n});\n\nquil.core$macros.background_int.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core$macros.current_graphics.call(null).background(cljs.core.unchecked_int.call(null,rgb),alpha);\n});\n\nquil.core$macros.background_int.cljs$lang$maxFixedArity = (2);\n/**\n * Sets the color used for the background of the Processing\n *   window. The default background is light gray. In the draw function,\n *   the background color is used to clear the display window at the\n *   beginning of each frame.\n * \n *   It is not possible to use transparency (alpha) in background colors\n *   with the main drawing surface, however they will work properly with\n *   create-graphics. Converts args to floats.\n */\nquil.core$macros.background = (function quil$core$macros$background(var_args){\nvar args144 = [];\nvar len__11134__auto___147 = arguments.length;\nvar i__11135__auto___148 = (0);\nwhile(true){\nif((i__11135__auto___148 < len__11134__auto___147)){\nargs144.push((arguments[i__11135__auto___148]));\n\nvar G__149 = (i__11135__auto___148 + (1));\ni__11135__auto___148 = G__149;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__146 = args144.length;\nswitch (G__146) {\ncase (1):\nreturn quil.core$macros.background.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.background.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.background.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.background.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args144.length)].join('')));\n\n}\n});\n\nquil.core$macros.background.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core$macros.current_graphics.call(null).background(rgb);\n});\n\nquil.core$macros.background.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core$macros.current_graphics.call(null).background(rgb,alpha);\n});\n\nquil.core$macros.background.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core$macros.background_float.call(null,r,g,b);\n});\n\nquil.core$macros.background.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,a){\nreturn quil.core$macros.background_float.call(null,r,g,b,a);\n});\n\nquil.core$macros.background.cljs$lang$maxFixedArity = (4);\n/**\n * Specify an image to be used as the background for a sketch. Its\n *   width and height must be the same size as the sketch window. Images\n *   used as background will ignore the current tint setting.\n */\nquil.core$macros.background_image = (function quil$core$macros$background_image(img){\nreturn quil.core$macros.current_graphics.call(null).background(img);\n});\n/**\n * Sets the matrix mode to the camera matrix so calls such as\n *   translate, rotate, apply-matrix and reset-matrix affect the\n *   camera. begin-camera should always be used with a following\n *   end-camera and pairs of begin-camera and end-camera cannot be\n *   nested.\n * \n *   For most situations the camera function will be sufficient.\n */\nquil.core$macros.begin_camera = (function quil$core$macros$begin_camera(){\nreturn quil.core$macros.current_graphics.call(null).beginCamera();\n});\n/**\n * Use the begin-contour and end-contour function to create negative\n *   shapes within shapes. These functions can only be within a\n *   begin-shape/end-shape pair and they only work with the :p2d and :p3d\n *   renderers.\n */\nquil.core$macros.begin_contour = (function quil$core$macros$begin_contour(){\nreturn quil.core$macros.current_graphics.call(null).beginContour();\n});\n/**\n * Enables the creation of complex forms. begin-shape begins recording\n *   vertices for a shape and end-shape stops recording. Use the mode\n *   keyword to specify which shape create from the provided\n *   vertices. With no mode specified, the shape can be any irregular\n *   polygon.\n * \n *   The available mode keywords are :points, :lines, :triangles,\n *                                :triangle-fan, :triangle-strip,\n *                                :quads, :quad-strip.\n * \n *   After calling the begin-shape function, a series of vertex commands\n *   must follow. To stop drawing the shape, call end-shape. The vertex\n *   function with two parameters specifies a position in 2D and the\n *   vertex function with three parameters specifies a position in\n *   3D. Each shape will be outlined with the current stroke color and\n *   filled with the fill color.\n * \n *   Transformations such as translate, rotate, and scale do not work\n *   within begin-shape. It is also not possible to use other shapes,\n *   such as ellipse or rect within begin-shape.\n */\nquil.core$macros.begin_shape = (function quil$core$macros$begin_shape(var_args){\nvar args151 = [];\nvar len__11134__auto___154 = arguments.length;\nvar i__11135__auto___155 = (0);\nwhile(true){\nif((i__11135__auto___155 < len__11134__auto___154)){\nargs151.push((arguments[i__11135__auto___155]));\n\nvar G__156 = (i__11135__auto___155 + (1));\ni__11135__auto___155 = G__156;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__153 = args151.length;\nswitch (G__153) {\ncase (0):\nreturn quil.core$macros.begin_shape.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.begin_shape.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args151.length)].join('')));\n\n}\n});\n\nquil.core$macros.begin_shape.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.current_graphics.call(null).beginShape();\n});\n\nquil.core$macros.begin_shape.cljs$core$IFn$_invoke$arity$1 = (function (mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.shape_modes);\nreturn quil.core$macros.current_graphics.call(null).beginShape((mode__$1 | (0)));\n});\n\nquil.core$macros.begin_shape.cljs$lang$maxFixedArity = (1);\n/**\n * Draws a Bezier curve on the screen. These curves are defined by a\n *   series of anchor and control points. The first two parameters\n *   specify the first anchor point and the last two parameters specify\n *   the other anchor point. The middle parameters specify the control\n *   points which define the shape of the curve.\n */\nquil.core$macros.bezier = (function quil$core$macros$bezier(var_args){\nvar args158 = [];\nvar len__11134__auto___161 = arguments.length;\nvar i__11135__auto___162 = (0);\nwhile(true){\nif((i__11135__auto___162 < len__11134__auto___161)){\nargs158.push((arguments[i__11135__auto___162]));\n\nvar G__163 = (i__11135__auto___162 + (1));\ni__11135__auto___162 = G__163;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__160 = args158.length;\nswitch (G__160) {\ncase (8):\nreturn quil.core$macros.bezier.cljs$core$IFn$_invoke$arity$8((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]));\n\nbreak;\ncase (12):\nreturn quil.core$macros.bezier.cljs$core$IFn$_invoke$arity$12((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args158.length)].join('')));\n\n}\n});\n\nquil.core$macros.bezier.cljs$core$IFn$_invoke$arity$8 = (function (x1,y1,cx1,cy1,cx2,cy2,x2,y2){\nreturn quil.core$macros.current_graphics.call(null).bezier(x1,y1,cx1,cy1,cx2,cy2,x2,y2);\n});\n\nquil.core$macros.bezier.cljs$core$IFn$_invoke$arity$12 = (function (x1,y1,z1,cx1,cy1,cz1,cx2,cy2,cz2,x2,y2,z2){\nreturn quil.core$macros.current_graphics.call(null).bezier(x1,y1,z1,cx1,cy1,cz1,cx2,cy2,cz2,x2,y2,z2);\n});\n\nquil.core$macros.bezier.cljs$lang$maxFixedArity = (12);\n/**\n * Sets the resolution at which Beziers display. The default value is\n *   20. This function is only useful when using the :p3d or :opengl\n *   renderer as the default (:java2d) renderer does not use this\n *   information.\n */\nquil.core$macros.bezier_detail = (function quil$core$macros$bezier_detail(detail){\nreturn quil.core$macros.current_graphics.call(null).bezierDetail((detail | (0)));\n});\n/**\n * Evaluates the Bezier at point t for points a, b, c, d. The\n *   parameter t varies between 0 and 1, a and d are points on the curve,\n *   and b and c are the control points. This can be done once with the x\n *   coordinates and a second time with the y coordinates to get the\n *   location of a bezier curve at t.\n */\nquil.core$macros.bezier_point = (function quil$core$macros$bezier_point(a,b,c,d,t){\nreturn quil.core$macros.current_graphics.call(null).bezierPoint(a,b,c,d,t);\n});\n/**\n * Calculates the tangent of a point on a Bezier curve.\n *   (See http://en.wikipedia.org/wiki/Tangent)\n */\nquil.core$macros.bezier_tangent = (function quil$core$macros$bezier_tangent(a,b,c,d,t){\nreturn quil.core$macros.current_graphics.call(null).bezierTangent(a,b,c,d,t);\n});\n/**\n * Specifies vertex coordinates for Bezier curves. Each call to\n *   bezier-vertex defines the position of two control points and one\n *   anchor point of a Bezier curve, adding a new segment to a line or\n *   shape. The first time bezier-vertex is used within a begin-shape\n *   call, it must be prefaced with a call to vertex to set the first\n *   anchor point. This function must be used between begin-shape and\n *   end-shape and only when there is no parameter specified to\n *   begin-shape.\n */\nquil.core$macros.bezier_vertex = (function quil$core$macros$bezier_vertex(var_args){\nvar args165 = [];\nvar len__11134__auto___168 = arguments.length;\nvar i__11135__auto___169 = (0);\nwhile(true){\nif((i__11135__auto___169 < len__11134__auto___168)){\nargs165.push((arguments[i__11135__auto___169]));\n\nvar G__170 = (i__11135__auto___169 + (1));\ni__11135__auto___169 = G__170;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__167 = args165.length;\nswitch (G__167) {\ncase (6):\nreturn quil.core$macros.bezier_vertex.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ncase (9):\nreturn quil.core$macros.bezier_vertex.cljs$core$IFn$_invoke$arity$9((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args165.length)].join('')));\n\n}\n});\n\nquil.core$macros.bezier_vertex.cljs$core$IFn$_invoke$arity$6 = (function (cx1,cy1,cx2,cy2,x,y){\nreturn quil.core$macros.current_graphics.call(null).bezierVertex(cx1,cy1,cx2,cy2,x,y);\n});\n\nquil.core$macros.bezier_vertex.cljs$core$IFn$_invoke$arity$9 = (function (cx1,cy1,cz1,cx2,cy2,cz2,x,y,z){\nreturn quil.core$macros.current_graphics.call(null).bezierVertex(cx1,cy1,cz1,cx2,cy2,cz2,x,y,z);\n});\n\nquil.core$macros.bezier_vertex.cljs$lang$maxFixedArity = (9);\n/**\n * Returns a string representing the binary value of an int, char or\n *   byte. When converting an int to a string, it is possible to specify\n *   the number of digits used.\n */\nquil.core$macros.binary = (function quil$core$macros$binary(var_args){\nvar args172 = [];\nvar len__11134__auto___175 = arguments.length;\nvar i__11135__auto___176 = (0);\nwhile(true){\nif((i__11135__auto___176 < len__11134__auto___175)){\nargs172.push((arguments[i__11135__auto___176]));\n\nvar G__177 = (i__11135__auto___176 + (1));\ni__11135__auto___176 = G__177;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__174 = args172.length;\nswitch (G__174) {\ncase (1):\nreturn quil.core$macros.binary.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.binary.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args172.length)].join('')));\n\n}\n});\n\nquil.core$macros.binary.cljs$core$IFn$_invoke$arity$1 = (function (val){\nreturn quil.sketch.current_applet.call(null).binary(val);\n});\n\nquil.core$macros.binary.cljs$core$IFn$_invoke$arity$2 = (function (val,num_digits){\nreturn quil.sketch.current_applet.call(null).binary(val,num_digits);\n});\n\nquil.core$macros.binary.cljs$lang$maxFixedArity = (2);\n/**\n * Blends a region of pixels from one image into another with full alpha\n *   channel support. If src is not specified it defaults to current-graphics.\n *   If dest is not specified it defaults to current-graphics.\n * \n *   Note: blend-mode function is recommended to use instead of this one.\n * \n *   Available blend modes are:\n * \n *   :blend      - linear interpolation of colours: C = A*factor + B\n *   :add        - additive blending with white clip:\n *                                          C = min(A*factor + B, 255)\n *   :subtract   - subtractive blending with black clip:\n *                                          C = max(B - A*factor, 0)\n *   :darkest    - only the darkest colour succeeds:\n *                                          C = min(A*factor, B)\n *   :lightest   - only the lightest colour succeeds:\n *                                          C = max(A*factor, B)\n *   :difference - subtract colors from underlying image.\n *   :exclusion  - similar to :difference, but less extreme.\n *   :multiply   - Multiply the colors, result will always be darker.\n *   :screen     - Opposite multiply, uses inverse values of the colors.\n *   :overlay    - A mix of :multiply and :screen. Multiplies dark values\n *              and screens light values.\n *   :hard-light - :screen when greater than 50% gray, :multiply when\n *              lower.\n *   :soft-light - Mix of :darkest and :lightest. Works like :overlay,\n *              but not as harsh.\n *   :dodge      - Lightens light tones and increases contrast, ignores\n *              darks.\n *              Called \"Color Dodge\" in Illustrator and Photoshop.\n *   :burn       - Darker areas are applied, increasing contrast, ignores\n *              lights. Called \"Color Burn\" in Illustrator and\n *              Photoshop.\n */\nquil.core$macros.blend = (function quil$core$macros$blend(var_args){\nvar args179 = [];\nvar len__11134__auto___182 = arguments.length;\nvar i__11135__auto___183 = (0);\nwhile(true){\nif((i__11135__auto___183 < len__11134__auto___182)){\nargs179.push((arguments[i__11135__auto___183]));\n\nvar G__184 = (i__11135__auto___183 + (1));\ni__11135__auto___183 = G__184;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__181 = args179.length;\nswitch (G__181) {\ncase (9):\nreturn quil.core$macros.blend.cljs$core$IFn$_invoke$arity$9((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]));\n\nbreak;\ncase (10):\nreturn quil.core$macros.blend.cljs$core$IFn$_invoke$arity$10((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]));\n\nbreak;\ncase (11):\nreturn quil.core$macros.blend.cljs$core$IFn$_invoke$arity$11((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args179.length)].join('')));\n\n}\n});\n\nquil.core$macros.blend.cljs$core$IFn$_invoke$arity$9 = (function (x,y,width,height,dx,dy,dwidth,dheight,mode){\nreturn quil.core$macros.blend.call(null,quil.core$macros.current_graphics.call(null),quil.core$macros.current_graphics.call(null),x,y,width,height,dx,dy,dwidth,dheight,mode);\n});\n\nquil.core$macros.blend.cljs$core$IFn$_invoke$arity$10 = (function (src_img,x,y,width,height,dx,dy,dwidth,dheight,mode){\nreturn quil.core$macros.blend.call(null,src_img,quil.core$macros.current_graphics.call(null),x,y,width,height,dx,dy,dwidth,dheight,mode);\n});\n\nquil.core$macros.blend.cljs$core$IFn$_invoke$arity$11 = (function (src_img,dest_img,x,y,width,height,dx,dy,dwidth,dheight,mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.blend_modes);\nreturn dest_img.blend(src_img,(x | (0)),(y | (0)),(width | (0)),(height | (0)),(dx | (0)),(dy | (0)),(dwidth | (0)),(dheight | (0)),(mode__$1 | (0)));\n});\n\nquil.core$macros.blend.cljs$lang$maxFixedArity = (11);\n/**\n * Blends two color values together based on the blending mode given specified\n *   with the mode keyword.\n * \n *   Available blend modes are:\n * \n *   :blend      - linear interpolation of colours: C = A*factor + B\n *   :add        - additive blending with white clip:\n *                                          C = min(A*factor + B, 255)\n *   :subtract   - subtractive blending with black clip:\n *                                          C = max(B - A*factor, 0)\n *   :darkest    - only the darkest colour succeeds:\n *                                          C = min(A*factor, B)\n *   :lightest   - only the lightest colour succeeds:\n *                                          C = max(A*factor, B)\n *   :difference - subtract colors from underlying image.\n *   :exclusion  - similar to :difference, but less extreme.\n *   :multiply   - Multiply the colors, result will always be darker.\n *   :screen     - Opposite multiply, uses inverse values of the colors.\n *   :overlay    - A mix of :multiply and :screen. Multiplies dark values\n *              and screens light values.\n *   :hard-light - :screen when greater than 50% gray, :multiply when\n *              lower.\n *   :soft-light - Mix of :darkest and :lightest. Works like :overlay,\n *              but not as harsh.\n *   :dodge      - Lightens light tones and increases contrast, ignores\n *              darks.\n *              Called \"Color Dodge\" in Illustrator and Photoshop.\n *   :burn       - Darker areas are applied, increasing contrast, ignores\n *              lights. Called \"Color Burn\" in Illustrator and\n *              Photoshop.\n */\nquil.core$macros.blend_color = (function quil$core$macros$blend_color(c1,c2,mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.blend_modes);\nreturn quil.core$macros.current_graphics.call(null).blendColor(c1,c2,mode__$1);\n});\n/**\n * Extracts the blue value from a color, scaled to match current color-mode.\n *   Returns a float.\n */\nquil.core$macros.blue = (function quil$core$macros$blue(color){\nreturn quil.core$macros.current_graphics.call(null).blue(cljs.core.unchecked_int.call(null,color));\n});\n/**\n * Creates an extruded rectangle.\n */\nquil.core$macros.box = (function quil$core$macros$box(var_args){\nvar args186 = [];\nvar len__11134__auto___189 = arguments.length;\nvar i__11135__auto___190 = (0);\nwhile(true){\nif((i__11135__auto___190 < len__11134__auto___189)){\nargs186.push((arguments[i__11135__auto___190]));\n\nvar G__191 = (i__11135__auto___190 + (1));\ni__11135__auto___190 = G__191;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__188 = args186.length;\nswitch (G__188) {\ncase (1):\nreturn quil.core$macros.box.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.box.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args186.length)].join('')));\n\n}\n});\n\nquil.core$macros.box.cljs$core$IFn$_invoke$arity$1 = (function (size){\nreturn quil.core$macros.current_graphics.call(null).box(size);\n});\n\nquil.core$macros.box.cljs$core$IFn$_invoke$arity$3 = (function (width,height,depth){\nreturn quil.core$macros.current_graphics.call(null).box(width,height,depth);\n});\n\nquil.core$macros.box.cljs$lang$maxFixedArity = (3);\n/**\n * Extracts the brightness value from a color. Returns a float.\n */\nquil.core$macros.brightness = (function quil$core$macros$brightness(color){\nreturn quil.core$macros.current_graphics.call(null).brightness(cljs.core.unchecked_int.call(null,color));\n});\n/**\n * Sets the position of the camera through setting the eye position,\n *   the center of the scene, and which axis is facing upward. Moving the\n *   eye position and the direction it is pointing (the center of the\n *   scene) allows the images to be seen from different angles. The\n *   version without any parameters sets the camera to the default\n *   position, pointing to the center of the display window with the Y\n *   axis as up. The default values are:\n * \n *   eyeX:     (/ (width) 2.0)\n *   eyeY:     (/ (height) 2.0)\n *   eyeZ:     (/ (/ (height) 2.0) (tan (/ (* Math/PI 60.0) 360.0)))\n *   centerX:  (/ (width) 2.0)\n *   centerY:  (/ (height) 2.0)\n *   centerZ:  0\n *   upX:      0\n *   upY:      1\n *   upZ:      0\n * \n *   Similar imilar to gluLookAt() in OpenGL, but it first clears the\n *   current camera settings.\n */\nquil.core$macros.camera = (function quil$core$macros$camera(var_args){\nvar args193 = [];\nvar len__11134__auto___196 = arguments.length;\nvar i__11135__auto___197 = (0);\nwhile(true){\nif((i__11135__auto___197 < len__11134__auto___196)){\nargs193.push((arguments[i__11135__auto___197]));\n\nvar G__198 = (i__11135__auto___197 + (1));\ni__11135__auto___197 = G__198;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__195 = args193.length;\nswitch (G__195) {\ncase (0):\nreturn quil.core$macros.camera.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (9):\nreturn quil.core$macros.camera.cljs$core$IFn$_invoke$arity$9((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args193.length)].join('')));\n\n}\n});\n\nquil.core$macros.camera.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.current_graphics.call(null).camera();\n});\n\nquil.core$macros.camera.cljs$core$IFn$_invoke$arity$9 = (function (eyeX,eyeY,eyeZ,centerX,centerY,centerZ,upX,upY,upZ){\nreturn quil.core$macros.current_graphics.call(null).camera(eyeX,eyeY,eyeZ,centerX,centerY,centerZ,upX,upY,upZ);\n});\n\nquil.core$macros.camera.cljs$lang$maxFixedArity = (9);\n/**\n * Calculates the closest int value that is greater than or equal to\n *   the value of the parameter. For example, (ceil 9.03) returns the\n *   value 10.\n */\nquil.core$macros.ceil = (function quil$core$macros$ceil(n){\nreturn quil.sketch.current_applet.call(null).ceil(n);\n});\n/**\n * Creates an integer representation of a color The parameters are\n *   interpreted as RGB or HSB values depending on the current\n *   color-mode. The default mode is RGB values from 0 to 255 and\n *   therefore, the function call (color 255 204 0) will return a bright\n *   yellow. Args are cast to floats.\n * \n *   r - red or hue value\n *   g - green or saturation value\n *   b - blue or brightness value\n *   a - alpha value\n */\nquil.core$macros.color = (function quil$core$macros$color(var_args){\nvar args200 = [];\nvar len__11134__auto___203 = arguments.length;\nvar i__11135__auto___204 = (0);\nwhile(true){\nif((i__11135__auto___204 < len__11134__auto___203)){\nargs200.push((arguments[i__11135__auto___204]));\n\nvar G__205 = (i__11135__auto___204 + (1));\ni__11135__auto___204 = G__205;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__202 = args200.length;\nswitch (G__202) {\ncase (1):\nreturn quil.core$macros.color.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.color.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.color.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.color.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args200.length)].join('')));\n\n}\n});\n\nquil.core$macros.color.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nreturn quil.core$macros.current_graphics.call(null).color(gray);\n});\n\nquil.core$macros.color.cljs$core$IFn$_invoke$arity$2 = (function (gray,alpha){\nreturn quil.core$macros.current_graphics.call(null).color(gray,alpha);\n});\n\nquil.core$macros.color.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core$macros.current_graphics.call(null).color(r,g,b);\n});\n\nquil.core$macros.color.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,a){\nreturn quil.core$macros.current_graphics.call(null).color(r,g,b,a);\n});\n\nquil.core$macros.color.cljs$lang$maxFixedArity = (4);\n/**\n * Changes the way Processing interprets color data. Available modes\n *   are :rgb and :hsb.By default, the parameters for fill, stroke,\n *   background, and color are defined by values between 0 and 255 using\n *   the :rgb color model. The color-mode fn is used to change the\n *   numerical range used for specifying colors and to switch color\n *   systems. For example, calling\n *   (color-mode :rgb 1.0) will specify that values are specified between\n *   0 and 1. The limits for defining colors are altered by setting the\n *   parameters range1, range2, range3, and range 4.\n */\nquil.core$macros.color_mode = (function quil$core$macros$color_mode(var_args){\nvar args207 = [];\nvar len__11134__auto___210 = arguments.length;\nvar i__11135__auto___211 = (0);\nwhile(true){\nif((i__11135__auto___211 < len__11134__auto___210)){\nargs207.push((arguments[i__11135__auto___211]));\n\nvar G__212 = (i__11135__auto___211 + (1));\ni__11135__auto___211 = G__212;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__209 = args207.length;\nswitch (G__209) {\ncase (1):\nreturn quil.core$macros.color_mode.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.color_mode.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.color_mode.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (5):\nreturn quil.core$macros.color_mode.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args207.length)].join('')));\n\n}\n});\n\nquil.core$macros.color_mode.cljs$core$IFn$_invoke$arity$1 = (function (mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.color_modes);\nreturn quil.core$macros.current_graphics.call(null).colorMode((mode__$1 | (0)));\n});\n\nquil.core$macros.color_mode.cljs$core$IFn$_invoke$arity$2 = (function (mode,max){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.color_modes);\nreturn quil.core$macros.current_graphics.call(null).colorMode((mode__$1 | (0)),max);\n});\n\nquil.core$macros.color_mode.cljs$core$IFn$_invoke$arity$4 = (function (mode,max_x,max_y,max_z){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.color_modes);\nreturn quil.core$macros.current_graphics.call(null).colorMode((mode__$1 | (0)),max_x,max_y,max_z);\n});\n\nquil.core$macros.color_mode.cljs$core$IFn$_invoke$arity$5 = (function (mode,max_x,max_y,max_z,max_a){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.color_modes);\nreturn quil.core$macros.current_graphics.call(null).colorMode((mode__$1 | (0)),max_x,max_y,max_z,max_a);\n});\n\nquil.core$macros.color_mode.cljs$lang$maxFixedArity = (5);\n/**\n * Constrains a value to not exceed a maximum and minimum value.\n */\nquil.core$macros.constrain = (function quil$core$macros$constrain(amt,low,high){\nreturn quil.sketch.current_applet.call(null).constrain(amt,low,high);\n});\n/**\n * Copies a region of pixels from the one image to another. If src-img\n *   is not specified it defaults to current-graphics. If dest-img is not\n *   specified - it defaults to current-graphics. If the source\n *   and destination regions aren't the same size, it will automatically\n *   resize the source pixels to fit the specified target region. No\n *   alpha information is used in the process, however if the source\n *   image has an alpha channel set, it will be copied as well. \n */\nquil.core$macros.copy = (function quil$core$macros$copy(var_args){\nvar args214 = [];\nvar len__11134__auto___229 = arguments.length;\nvar i__11135__auto___230 = (0);\nwhile(true){\nif((i__11135__auto___230 < len__11134__auto___229)){\nargs214.push((arguments[i__11135__auto___230]));\n\nvar G__231 = (i__11135__auto___230 + (1));\ni__11135__auto___230 = G__231;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__216 = args214.length;\nswitch (G__216) {\ncase (2):\nreturn quil.core$macros.copy.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.copy.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.copy.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args214.length)].join('')));\n\n}\n});\n\nquil.core$macros.copy.cljs$core$IFn$_invoke$arity$2 = (function (p__217,p__218){\nvar vec__219 = p__217;\nvar sx = cljs.core.nth.call(null,vec__219,(0),null);\nvar sy = cljs.core.nth.call(null,vec__219,(1),null);\nvar swidth = cljs.core.nth.call(null,vec__219,(2),null);\nvar sheight = cljs.core.nth.call(null,vec__219,(3),null);\nvar vec__220 = p__218;\nvar dx = cljs.core.nth.call(null,vec__220,(0),null);\nvar dy = cljs.core.nth.call(null,vec__220,(1),null);\nvar dwidth = cljs.core.nth.call(null,vec__220,(2),null);\nvar dheight = cljs.core.nth.call(null,vec__220,(3),null);\nreturn quil.core$macros.current_graphics.call(null).copy((sx | (0)),(sy | (0)),(swidth | (0)),(sheight | (0)),(dx | (0)),(dy | (0)),(dwidth | (0)),(dheight | (0)));\n});\n\nquil.core$macros.copy.cljs$core$IFn$_invoke$arity$3 = (function (src_img,p__221,p__222){\nvar vec__223 = p__221;\nvar sx = cljs.core.nth.call(null,vec__223,(0),null);\nvar sy = cljs.core.nth.call(null,vec__223,(1),null);\nvar swidth = cljs.core.nth.call(null,vec__223,(2),null);\nvar sheight = cljs.core.nth.call(null,vec__223,(3),null);\nvar vec__224 = p__222;\nvar dx = cljs.core.nth.call(null,vec__224,(0),null);\nvar dy = cljs.core.nth.call(null,vec__224,(1),null);\nvar dwidth = cljs.core.nth.call(null,vec__224,(2),null);\nvar dheight = cljs.core.nth.call(null,vec__224,(3),null);\nreturn quil.core$macros.copy.call(null,src_img,quil.core$macros.current_graphics.call(null),new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [sx,sy,swidth,sheight], null),new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [dx,dy,dwidth,dheight], null));\n});\n\nquil.core$macros.copy.cljs$core$IFn$_invoke$arity$4 = (function (src_img,dest_img,p__225,p__226){\nvar vec__227 = p__225;\nvar sx = cljs.core.nth.call(null,vec__227,(0),null);\nvar sy = cljs.core.nth.call(null,vec__227,(1),null);\nvar swidth = cljs.core.nth.call(null,vec__227,(2),null);\nvar sheight = cljs.core.nth.call(null,vec__227,(3),null);\nvar vec__228 = p__226;\nvar dx = cljs.core.nth.call(null,vec__228,(0),null);\nvar dy = cljs.core.nth.call(null,vec__228,(1),null);\nvar dwidth = cljs.core.nth.call(null,vec__228,(2),null);\nvar dheight = cljs.core.nth.call(null,vec__228,(3),null);\nreturn dest_img.copy(src_img,(sx | (0)),(sy | (0)),(swidth | (0)),(sheight | (0)),(dx | (0)),(dy | (0)),(dwidth | (0)),(dheight | (0)));\n});\n\nquil.core$macros.copy.cljs$lang$maxFixedArity = (4);\n/**\n * Calculates the cosine of an angle. This function expects the values\n *   of the angle parameter to be provided in radians (values from 0 to\n *   Math/PI*2). Values are returned in the range -1 to 1.\n */\nquil.core$macros.cos = (function quil$core$macros$cos(angle){\nreturn quil.sketch.current_applet.call(null).cos(angle);\n});\n/**\n * Dynamically converts a font to the format used by Processing (a\n *   PFont) from either a font name that's installed on the computer, or\n *   from a .ttf or .otf file inside the sketches 'data' folder. This\n *   function is an advanced feature for precise control.\n * \n *   Use available-fonts to obtain the names for the fonts recognized by\n *   the computer and are compatible with this function.\n * \n *   The size parameter states the font size you want to generate. The\n *   smooth parameter specifies if the font should be antialiased or not,\n *   and the charset parameter is an array of chars that specifies the\n *   characters to generate.\n * \n *   This function creates a bitmapped version of a font It loads a font\n *   by name, and converts it to a series of images based on the size of\n *   the font. When possible, the text function will use a native font\n *   rather than the bitmapped version created behind the scenes with\n *   create-font. For instance, when using the default renderer\n *   setting (JAVA2D), the actual native version of the font will be\n *   employed by the sketch, improving drawing quality and\n *   performance. With the :p2d, :p3d, and :opengl renderer settings, the\n *   bitmapped version will be used. While this can drastically improve\n *   speed and appearance, results are poor when exporting if the sketch\n *   does not include the .otf or .ttf file, and the requested font is\n *   not available on the machine running the sketch.\n */\nquil.core$macros.create_font = (function quil$core$macros$create_font(var_args){\nvar args233 = [];\nvar len__11134__auto___236 = arguments.length;\nvar i__11135__auto___237 = (0);\nwhile(true){\nif((i__11135__auto___237 < len__11134__auto___236)){\nargs233.push((arguments[i__11135__auto___237]));\n\nvar G__238 = (i__11135__auto___237 + (1));\ni__11135__auto___237 = G__238;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__235 = args233.length;\nswitch (G__235) {\ncase (2):\nreturn quil.core$macros.create_font.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.create_font.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.create_font.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args233.length)].join('')));\n\n}\n});\n\nquil.core$macros.create_font.cljs$core$IFn$_invoke$arity$2 = (function (name,size){\nreturn quil.sketch.current_applet.call(null).createFont([cljs.core.str(name)].join(''),size);\n});\n\nquil.core$macros.create_font.cljs$core$IFn$_invoke$arity$3 = (function (name,size,smooth){\nreturn quil.sketch.current_applet.call(null).createFont([cljs.core.str(name)].join(''),size,smooth);\n});\n\nquil.core$macros.create_font.cljs$core$IFn$_invoke$arity$4 = (function (name,size,smooth,charset){\nreturn quil.sketch.current_applet.call(null).createFont([cljs.core.str(name)].join(''),size,smooth,charset);\n});\n\nquil.core$macros.create_font.cljs$lang$maxFixedArity = (4);\n/**\n * Creates and returns a new PGraphics object of the types :p2d, :p3d,\n *   :java2d, :pdf. By default :java2d is used. Use this class if you\n *   need to draw into an off-screen graphics buffer. It's not possible\n *   to use create-graphics with the :opengl renderer, because it doesn't\n *   allow offscreen use. The :pdf renderer requires the filename parameter.\n * \n *   Note: don't use create-graphics in draw in clojurescript, it leaks memory.\n *   You should create graphic in setup and reuse it in draw instead of creating\n *   a new one.\n * \n *   It's important to call any drawing commands between (.beginDraw graphics) and\n *   (.endDraw graphics) statements or use with-graphics macro. This is also true\n *   for any commands that affect drawing, such as smooth or color-mode.\n * \n *   If you're using :pdf renderer - don't forget to call (.dispose graphics)\n *   as last command inside with-graphics macro, otherwise graphics won't be\n *   saved.\n * \n *   Unlike the main drawing surface which is completely opaque, surfaces\n *   created with create-graphics can have transparency. This makes it\n *   possible to draw into a graphics and maintain the alpha channel. By\n *   using save to write a PNG or TGA file, the transparency of the\n *   graphics object will be honored.\n */\nquil.core$macros.create_graphics = (function quil$core$macros$create_graphics(var_args){\nvar args240 = [];\nvar len__11134__auto___243 = arguments.length;\nvar i__11135__auto___244 = (0);\nwhile(true){\nif((i__11135__auto___244 < len__11134__auto___243)){\nargs240.push((arguments[i__11135__auto___244]));\n\nvar G__245 = (i__11135__auto___244 + (1));\ni__11135__auto___244 = G__245;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__242 = args240.length;\nswitch (G__242) {\ncase (2):\nreturn quil.core$macros.create_graphics.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.create_graphics.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.create_graphics.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args240.length)].join('')));\n\n}\n});\n\nquil.core$macros.create_graphics.cljs$core$IFn$_invoke$arity$2 = (function (w,h){\nreturn quil.sketch.current_applet.call(null).createGraphics((w | (0)),(h | (0)),new cljs.core.Keyword(null,\"p2d\",\"p2d\",(-2106175755)));\n});\n\nquil.core$macros.create_graphics.cljs$core$IFn$_invoke$arity$3 = (function (w,h,renderer){\nreturn quil.sketch.current_applet.call(null).createGraphics((w | (0)),(h | (0)),quil.sketch.resolve_renderer.call(null,renderer));\n});\n\nquil.core$macros.create_graphics.cljs$core$IFn$_invoke$arity$4 = (function (w,h,renderer,path){\nreturn quil.sketch.current_applet.call(null).createGraphics((w | (0)),(h | (0)),quil.sketch.resolve_renderer.call(null,renderer),path);\n});\n\nquil.core$macros.create_graphics.cljs$lang$maxFixedArity = (4);\n/**\n * Creates a new PImage (the datatype for storing images). This\n *   provides a fresh buffer of pixels to play with. Set the size of the\n *   buffer with the width and height parameters. The format parameter\n *   defines how the pixels are stored. See the PImage reference for more\n *   information.\n * \n *   Possible formats: :rgb, :argb, :alpha (grayscale alpha channel)\n * \n *   Prefer using create-image over initialising new PImage instances\n *   directly.\n */\nquil.core$macros.create_image = (function quil$core$macros$create_image(w,h,format){\nvar format__$1 = quil.util.resolve_constant_key.call(null,format,quil.core$macros.image_formats);\nreturn quil.sketch.current_applet.call(null).createImage((w | (0)),(h | (0)),(format__$1 | (0)));\n});\n/**\n * Return the current fill color.\n */\nquil.core$macros.current_fill = (function quil$core$macros$current_fill(){\nreturn quil.core$macros.current_graphics.call(null).fillColor();\n});\n/**\n * Return the current stroke color.\n */\nquil.core$macros.current_stroke = (function quil$core$macros$current_stroke(){\nreturn quil.core$macros.current_graphics.call(null).strokeColor();\n});\n/**\n * Sets the cursor to a predefined symbol or makes it\n *   visible if already hidden (after no-cursor was called).\n * \n *   Available modes: :arrow, :cross, :hand, :move, :text, :wait\n * \n *   See cursor-image for specifying a generic image as the cursor\n *   symbol.\n */\nquil.core$macros.cursor = (function quil$core$macros$cursor(var_args){\nvar args247 = [];\nvar len__11134__auto___250 = arguments.length;\nvar i__11135__auto___251 = (0);\nwhile(true){\nif((i__11135__auto___251 < len__11134__auto___250)){\nargs247.push((arguments[i__11135__auto___251]));\n\nvar G__252 = (i__11135__auto___251 + (1));\ni__11135__auto___251 = G__252;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__249 = args247.length;\nswitch (G__249) {\ncase (0):\nreturn quil.core$macros.cursor.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.cursor.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args247.length)].join('')));\n\n}\n});\n\nquil.core$macros.cursor.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.sketch.current_applet.call(null).cursor();\n});\n\nquil.core$macros.cursor.cljs$core$IFn$_invoke$arity$1 = (function (cursor_mode){\nvar cursor_mode__$1 = quil.util.resolve_constant_key.call(null,cursor_mode,quil.core$macros.cursor_modes);\nreturn quil.sketch.current_applet.call(null).cursor([cljs.core.str(cursor_mode__$1)].join(''));\n});\n\nquil.core$macros.cursor.cljs$lang$maxFixedArity = (1);\n/**\n * Set the cursor to a predefined image. The horizontal and vertical\n *   active spots of the cursor may be specified with hx and hy.\n *   It is recommended to make the size 16x16 or 32x32 pixels.\n */\nquil.core$macros.cursor_image = (function quil$core$macros$cursor_image(var_args){\nvar args254 = [];\nvar len__11134__auto___257 = arguments.length;\nvar i__11135__auto___258 = (0);\nwhile(true){\nif((i__11135__auto___258 < len__11134__auto___257)){\nargs254.push((arguments[i__11135__auto___258]));\n\nvar G__259 = (i__11135__auto___258 + (1));\ni__11135__auto___258 = G__259;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__256 = args254.length;\nswitch (G__256) {\ncase (1):\nreturn quil.core$macros.cursor_image.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.cursor_image.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args254.length)].join('')));\n\n}\n});\n\nquil.core$macros.cursor_image.cljs$core$IFn$_invoke$arity$1 = (function (img){\nreturn quil.sketch.current_applet.call(null).cursor(img);\n});\n\nquil.core$macros.cursor_image.cljs$core$IFn$_invoke$arity$3 = (function (img,hx,hy){\nreturn quil.sketch.current_applet.call(null).cursor(img,(hx | (0)),(hy | (0)));\n});\n\nquil.core$macros.cursor_image.cljs$lang$maxFixedArity = (3);\n/**\n * Draws a curved line on the screen. The first and second parameters\n *   specify the beginning control point and the last two parameters\n *   specify the ending control point. The middle parameters specify the\n *   start and stop of the curve. Longer curves can be created by putting\n *   a series of curve fns together or using curve-vertex. An additional\n *   fn called curve-tightness provides control for the visual quality of\n *   the curve. The curve fn is an implementation of Catmull-Rom\n *   splines.\n */\nquil.core$macros.curve = (function quil$core$macros$curve(var_args){\nvar args261 = [];\nvar len__11134__auto___264 = arguments.length;\nvar i__11135__auto___265 = (0);\nwhile(true){\nif((i__11135__auto___265 < len__11134__auto___264)){\nargs261.push((arguments[i__11135__auto___265]));\n\nvar G__266 = (i__11135__auto___265 + (1));\ni__11135__auto___265 = G__266;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__263 = args261.length;\nswitch (G__263) {\ncase (8):\nreturn quil.core$macros.curve.cljs$core$IFn$_invoke$arity$8((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]));\n\nbreak;\ncase (12):\nreturn quil.core$macros.curve.cljs$core$IFn$_invoke$arity$12((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args261.length)].join('')));\n\n}\n});\n\nquil.core$macros.curve.cljs$core$IFn$_invoke$arity$8 = (function (x1,y1,x2,y2,x3,y3,x4,y4){\nreturn quil.core$macros.current_graphics.call(null).curve(x1,y1,x2,y2,x3,y3,x4,y4);\n});\n\nquil.core$macros.curve.cljs$core$IFn$_invoke$arity$12 = (function (x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4){\nreturn quil.core$macros.current_graphics.call(null).curve(x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4);\n});\n\nquil.core$macros.curve.cljs$lang$maxFixedArity = (12);\n/**\n * Sets the resolution at which curves display. The default value is\n *   20. This function is only useful when using the :p3d or :opengl\n *   renderer as the default (:java2d) renderer does not use this\n *   information.\n */\nquil.core$macros.curve_detail = (function quil$core$macros$curve_detail(detail){\nreturn quil.core$macros.current_graphics.call(null).curveDetail((detail | (0)));\n});\n/**\n * Evalutes the curve at point t for points a, b, c, d. The parameter\n *   t varies between 0 and 1, a and d are points on the curve, and b c\n *   and are the control points. This can be done once with the x\n *   coordinates and a second time with the y coordinates to get the\n *   location of a curve at t.\n */\nquil.core$macros.curve_point = (function quil$core$macros$curve_point(a,b,c,d,t){\nreturn quil.core$macros.current_graphics.call(null).curvePoint(a,b,c,d,t);\n});\n/**\n * Calculates the tangent of a point on a curve.\n *   See: http://en.wikipedia.org/wiki/Tangent\n */\nquil.core$macros.curve_tangent = (function quil$core$macros$curve_tangent(a,b,c,d,t){\nreturn quil.core$macros.current_graphics.call(null).curveTangent(a,b,c,d,t);\n});\n/**\n * Modifies the quality of forms created with curve and\n *   curve-vertex. The parameter squishy determines how the curve fits\n *   to the vertex points. The value 0.0 is the default value for\n *   squishy (this value defines the curves to be Catmull-Rom splines)\n *   and the value 1.0 connects all the points with straight\n *   lines. Values within the range -5.0 and 5.0 will deform the curves\n *   but will leave them recognizable and as values increase in\n *   magnitude, they will continue to deform.\n */\nquil.core$macros.curve_tightness = (function quil$core$macros$curve_tightness(ti){\nreturn quil.core$macros.current_graphics.call(null).curveTightness(ti);\n});\n/**\n * Specifies vertex coordinates for curves. This function may only be\n *   used between begin-shape and end-shape and only when there is no\n *   mode keyword specified to begin-shape. The first and last points in a\n *   series of curve-vertex lines will be used to guide the beginning and\n *   end of a the curve. A minimum of four points is required to draw a\n *   tiny curve between the second and third points. Adding a fifth point\n *   with curve-vertex will draw the curve between the second, third, and\n *   fourth points. The curve-vertex function is an implementation of\n *   Catmull-Rom splines.\n */\nquil.core$macros.curve_vertex = (function quil$core$macros$curve_vertex(var_args){\nvar args268 = [];\nvar len__11134__auto___271 = arguments.length;\nvar i__11135__auto___272 = (0);\nwhile(true){\nif((i__11135__auto___272 < len__11134__auto___271)){\nargs268.push((arguments[i__11135__auto___272]));\n\nvar G__273 = (i__11135__auto___272 + (1));\ni__11135__auto___272 = G__273;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__270 = args268.length;\nswitch (G__270) {\ncase (2):\nreturn quil.core$macros.curve_vertex.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.curve_vertex.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args268.length)].join('')));\n\n}\n});\n\nquil.core$macros.curve_vertex.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.core$macros.current_graphics.call(null).curveVertex(x,y);\n});\n\nquil.core$macros.curve_vertex.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.current_graphics.call(null).curveVertex(x,y,z);\n});\n\nquil.core$macros.curve_vertex.cljs$lang$maxFixedArity = (3);\n/**\n * Get the current day of the month (1 through 31).\n */\nquil.core$macros.day = (function quil$core$macros$day(){\nreturn quil.sketch.current_applet.call(null).day();\n});\nquil.core$macros.degrees = (function quil$core$macros$degrees(radians){\nreturn quil.sketch.current_applet.call(null).degrees(radians);\n});\n/**\n * Forces the program to stop running for a specified time. Delay\n *   times are specified in thousandths of a second, therefore the\n *   function call (delay 3000) will stop the program for three\n *   seconds. Because the screen is updated only at the end of draw,\n *   the program may appear to 'freeze', because the screen will not\n *   update when the delay fn is used. This function has no affect\n *   inside setup.\n */\nquil.core$macros.delay_frame = (function quil$core$macros$delay_frame(freeze_ms){\nreturn quil.sketch.current_applet.call(null).delay((freeze_ms | (0)));\n});\n/**\n * Adds a directional light. Directional light comes from one\n *   direction and is stronger when hitting a surface squarely and weaker\n *   if it hits at a gentle angle. After hitting a surface, a\n *   directional lights scatters in all directions. Lights need to be\n *   included in the draw fn to remain persistent in a looping\n *   program. Placing them in the setup fn of a looping program will cause\n *   them to only have an effect the first time through the loop. The\n *   affect of the r, g, and b parameters is determined by the current\n *   color mode. The nx, ny, and nz parameters specify the direction the\n *   light is facing. For example, setting ny to -1 will cause the\n *   geometry to be lit from below (the light is facing directly upward)\n */\nquil.core$macros.directional_light = (function quil$core$macros$directional_light(r,g,b,nx,ny,nz){\nreturn quil.core$macros.current_graphics.call(null).directionalLight(r,g,b,nx,ny,nz);\n});\n/**\n * Calculates the distance between two points\n */\nquil.core$macros.dist = (function quil$core$macros$dist(var_args){\nvar args275 = [];\nvar len__11134__auto___278 = arguments.length;\nvar i__11135__auto___279 = (0);\nwhile(true){\nif((i__11135__auto___279 < len__11134__auto___278)){\nargs275.push((arguments[i__11135__auto___279]));\n\nvar G__280 = (i__11135__auto___279 + (1));\ni__11135__auto___279 = G__280;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__277 = args275.length;\nswitch (G__277) {\ncase (4):\nreturn quil.core$macros.dist.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (6):\nreturn quil.core$macros.dist.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args275.length)].join('')));\n\n}\n});\n\nquil.core$macros.dist.cljs$core$IFn$_invoke$arity$4 = (function (x1,y1,x2,y2){\nreturn quil.sketch.current_applet.call(null).dist(x1,y1,x2,y2);\n});\n\nquil.core$macros.dist.cljs$core$IFn$_invoke$arity$6 = (function (x1,y1,z1,x2,y2,z2){\nreturn quil.sketch.current_applet.call(null).dist(x1,y1,z1,x2,y2,z2);\n});\n\nquil.core$macros.dist.cljs$lang$maxFixedArity = (6);\n/**\n * Draws an ellipse (oval) in the display window. An ellipse with an\n *   equal width and height is a circle.  The origin may be changed with\n *   the ellipse-mode function\n */\nquil.core$macros.ellipse = (function quil$core$macros$ellipse(x,y,width,height){\nreturn quil.core$macros.current_graphics.call(null).ellipse(x,y,width,height);\n});\n/**\n * Modifies the origin of the ellispse according to the specified mode:\n * \n *   :center  - specifies the location of the ellipse as\n *           the center of the shape. (Default).\n *   :radius  - similar to center, but the width and height parameters to\n *           ellipse specify the radius of the ellipse, rather than the\n *           diameter.\n *   :corner  - draws the shape from the upper-left corner of its bounding\n *           box.\n *   :corners - uses the four parameters to ellipse to set two opposing\n *           corners of the ellipse's bounding box.\n */\nquil.core$macros.ellipse_mode = (function quil$core$macros$ellipse_mode(mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.ellipse_modes);\nreturn quil.core$macros.current_graphics.call(null).ellipseMode((mode__$1 | (0)));\n});\n/**\n * Sets the emissive color of the material used for drawing shapes\n *  drawn to the screen. Used in combination with ambient, specular, and\n *  shininess in setting the material properties of shapes. Converts all\n *  args to floats\n */\nquil.core$macros.emissive_float = (function quil$core$macros$emissive_float(var_args){\nvar args282 = [];\nvar len__11134__auto___285 = arguments.length;\nvar i__11135__auto___286 = (0);\nwhile(true){\nif((i__11135__auto___286 < len__11134__auto___285)){\nargs282.push((arguments[i__11135__auto___286]));\n\nvar G__287 = (i__11135__auto___286 + (1));\ni__11135__auto___286 = G__287;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__284 = args282.length;\nswitch (G__284) {\ncase (1):\nreturn quil.core$macros.emissive_float.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.emissive_float.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args282.length)].join('')));\n\n}\n});\n\nquil.core$macros.emissive_float.cljs$core$IFn$_invoke$arity$1 = (function (float_val){\nreturn quil.core$macros.current_graphics.call(null).emissive(float_val);\n});\n\nquil.core$macros.emissive_float.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core$macros.current_graphics.call(null).emissive(r,g,b);\n});\n\nquil.core$macros.emissive_float.cljs$lang$maxFixedArity = (3);\n/**\n * Sets the emissive color of the material used for drawing shapes\n *   drawn to the screen. Used in combination with ambient, specular, and\n *   shininess in setting the material properties of shapes. Converts all\n *   args to ints\n */\nquil.core$macros.emissive_int = (function quil$core$macros$emissive_int(int_val){\nreturn quil.core$macros.current_graphics.call(null).emissive((int_val | (0)));\n});\n/**\n * Sets the emissive color of the material used for drawing shapes\n *   drawn to the screen. Used in combination with ambient, specular, and\n *   shininess in setting the material properties of shapes.\n * \n *   If passed one arg - it is assumed to be an int (i.e. a color),\n *   multiple args are converted to floats.\n */\nquil.core$macros.emissive = (function quil$core$macros$emissive(var_args){\nvar args289 = [];\nvar len__11134__auto___292 = arguments.length;\nvar i__11135__auto___293 = (0);\nwhile(true){\nif((i__11135__auto___293 < len__11134__auto___292)){\nargs289.push((arguments[i__11135__auto___293]));\n\nvar G__294 = (i__11135__auto___293 + (1));\ni__11135__auto___293 = G__294;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__291 = args289.length;\nswitch (G__291) {\ncase (1):\nreturn quil.core$macros.emissive.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.emissive.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args289.length)].join('')));\n\n}\n});\n\nquil.core$macros.emissive.cljs$core$IFn$_invoke$arity$1 = (function (c){\nreturn quil.core$macros.emissive_float.call(null,c);\n});\n\nquil.core$macros.emissive.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core$macros.emissive_float.call(null,r,g,b);\n});\n\nquil.core$macros.emissive.cljs$lang$maxFixedArity = (3);\n/**\n * Unsets the matrix mode from the camera matrix. See begin-camera.\n */\nquil.core$macros.end_camera = (function quil$core$macros$end_camera(){\nreturn quil.core$macros.current_graphics.call(null).endCamera();\n});\n/**\n * Use the begin-contour and end-contour function to create negative\n *   shapes within shapes. These functions can only be within a\n *   begin-shape/end-shape pair and they only work with the :p2d and :p3d\n *   renderers.\n */\nquil.core$macros.end_contour = (function quil$core$macros$end_contour(){\nreturn quil.core$macros.current_graphics.call(null).endContour();\n});\n/**\n * Complement to begin-raw; they must always be used together. See\n *   the begin-raw docstring for details.\n */\nquil.core$macros.end_raw = (function quil$core$macros$end_raw(){\nreturn quil.core$macros.current_graphics.call(null).endRaw();\n});\n/**\n * May only be called after begin-shape. When end-shape is called,\n *   all of image data defined since the previous call to begin-shape is\n *   written into the image buffer. The keyword :close may be passed to\n *   close the shape (to connect the beginning and the end).\n */\nquil.core$macros.end_shape = (function quil$core$macros$end_shape(var_args){\nvar args296 = [];\nvar len__11134__auto___299 = arguments.length;\nvar i__11135__auto___300 = (0);\nwhile(true){\nif((i__11135__auto___300 < len__11134__auto___299)){\nargs296.push((arguments[i__11135__auto___300]));\n\nvar G__301 = (i__11135__auto___300 + (1));\ni__11135__auto___300 = G__301;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__298 = args296.length;\nswitch (G__298) {\ncase (0):\nreturn quil.core$macros.end_shape.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.end_shape.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args296.length)].join('')));\n\n}\n});\n\nquil.core$macros.end_shape.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.current_graphics.call(null).endShape();\n});\n\nquil.core$macros.end_shape.cljs$core$IFn$_invoke$arity$1 = (function (mode){\nif(cljs.core._EQ_.call(null,new cljs.core.Keyword(null,\"close\",\"close\",(1835149582)),mode)){\n} else {\n}\n\nreturn quil.core$macros.current_graphics.call(null).endShape((2));\n});\n\nquil.core$macros.end_shape.cljs$lang$maxFixedArity = (1);\n/**\n * Quits/stops/exits the program.  Rather than terminating\n *   immediately, exit will cause the sketch to exit after draw has\n *   completed (or after setup completes if called during the setup\n *   method). \n */\nquil.core$macros.exit = (function quil$core$macros$exit(){\nreturn quil.sketch.current_applet.call(null).exit();\n});\n/**\n * Returns Euler's number e (2.71828...) raised to the power of the\n *   value parameter.\n */\nquil.core$macros.exp = (function quil$core$macros$exp(val){\nreturn quil.sketch.current_applet.call(null).exp(val);\n});\n/**\n * Sets custom property on graphcis object indicating that it has\n *   fill color.\n */\nquil.core$macros.clear_no_fill_cljs = (function quil$core$macros$clear_no_fill_cljs(graphics){\nreturn (graphics[quil.core$macros.no_fill_prop] = false);\n});\n/**\n * Sets the color used to fill shapes. For example, (fill 204 102 0),\n *   will specify that all subsequent shapes will be filled with orange.\n */\nquil.core$macros.fill_float = (function quil$core$macros$fill_float(var_args){\nvar args303 = [];\nvar len__11134__auto___306 = arguments.length;\nvar i__11135__auto___307 = (0);\nwhile(true){\nif((i__11135__auto___307 < len__11134__auto___306)){\nargs303.push((arguments[i__11135__auto___307]));\n\nvar G__308 = (i__11135__auto___307 + (1));\ni__11135__auto___307 = G__308;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__305 = args303.length;\nswitch (G__305) {\ncase (1):\nreturn quil.core$macros.fill_float.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.fill_float.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.fill_float.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.fill_float.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args303.length)].join('')));\n\n}\n});\n\nquil.core$macros.fill_float.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nquil.core$macros.current_graphics.call(null).fill(gray);\n\nreturn quil.core$macros.clear_no_fill_cljs.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.fill_float.cljs$core$IFn$_invoke$arity$2 = (function (gray,alpha){\nquil.core$macros.current_graphics.call(null).fill(gray,alpha);\n\nreturn quil.core$macros.clear_no_fill_cljs.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.fill_float.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nquil.core$macros.current_graphics.call(null).fill(r,g,b);\n\nreturn quil.core$macros.clear_no_fill_cljs.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.fill_float.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,alpha){\nquil.core$macros.current_graphics.call(null).fill(r,g,b,alpha);\n\nreturn quil.core$macros.clear_no_fill_cljs.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.fill_float.cljs$lang$maxFixedArity = (4);\n/**\n * Sets the color used to fill shapes.\n */\nquil.core$macros.fill_int = (function quil$core$macros$fill_int(var_args){\nvar args310 = [];\nvar len__11134__auto___313 = arguments.length;\nvar i__11135__auto___314 = (0);\nwhile(true){\nif((i__11135__auto___314 < len__11134__auto___313)){\nargs310.push((arguments[i__11135__auto___314]));\n\nvar G__315 = (i__11135__auto___314 + (1));\ni__11135__auto___314 = G__315;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__312 = args310.length;\nswitch (G__312) {\ncase (1):\nreturn quil.core$macros.fill_int.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.fill_int.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args310.length)].join('')));\n\n}\n});\n\nquil.core$macros.fill_int.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nquil.core$macros.current_graphics.call(null).fill(cljs.core.unchecked_int.call(null,rgb));\n\nreturn quil.core$macros.clear_no_fill_cljs.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.fill_int.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nquil.core$macros.current_graphics.call(null).fill(cljs.core.unchecked_int.call(null,rgb),alpha);\n\nreturn quil.core$macros.clear_no_fill_cljs.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.fill_int.cljs$lang$maxFixedArity = (2);\n/**\n * Sets the color used to fill shapes.\n */\nquil.core$macros.fill = (function quil$core$macros$fill(var_args){\nvar args317 = [];\nvar len__11134__auto___320 = arguments.length;\nvar i__11135__auto___321 = (0);\nwhile(true){\nif((i__11135__auto___321 < len__11134__auto___320)){\nargs317.push((arguments[i__11135__auto___321]));\n\nvar G__322 = (i__11135__auto___321 + (1));\ni__11135__auto___321 = G__322;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__319 = args317.length;\nswitch (G__319) {\ncase (1):\nreturn quil.core$macros.fill.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.fill.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.fill.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.fill.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args317.length)].join('')));\n\n}\n});\n\nquil.core$macros.fill.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core$macros.fill_float.call(null,rgb);\n});\n\nquil.core$macros.fill.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core$macros.fill_float.call(null,rgb,alpha);\n});\n\nquil.core$macros.fill.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core$macros.fill_float.call(null,r,g,b);\n});\n\nquil.core$macros.fill.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,a){\nreturn quil.core$macros.fill_float.call(null,r,g,b,a);\n});\n\nquil.core$macros.fill.cljs$lang$maxFixedArity = (4);\n/**\n * Originally named filter in Processing Language.\n *   Filters the display window with the specified mode and level.\n *   Level defines the quality of the filter and mode may be one of the\n *   following keywords:\n * \n *   :threshold - converts the image to black and white pixels depending\n *             if they are above or below the threshold defined by\n *             the level parameter. The level must be between\n *             0.0 (black) and 1.0 (white). If no level is specified,\n *             0.5 is used.\n *   :gray      - converts any colors in the image to grayscale\n *             equivalents. Doesn't work with level.\n *   :invert    - sets each pixel to its inverse value. Doesn't work with\n *             level.\n *   :posterize - limits each channel of the image to the number of\n *             colors specified as the level parameter. The parameter can\n *             be set to values between 2 and 255, but results are most\n *             noticeable in the lower ranges.\n *   :blur      - executes a Guassian blur with the level parameter\n *             specifying the extent of the blurring. If no level\n *             parameter is used, the blur is equivalent to Guassian\n *             blur of radius 1.\n *   :opaque    - sets the alpha channel to entirely opaque. Doesn't work\n *             with level.\n *   :erode     - reduces the light areas. Doesn't work with level.\n *   :dilate    - increases the light areas.  Doesn't work with level.\n */\nquil.core$macros.display_filter = (function quil$core$macros$display_filter(var_args){\nvar args324 = [];\nvar len__11134__auto___327 = arguments.length;\nvar i__11135__auto___328 = (0);\nwhile(true){\nif((i__11135__auto___328 < len__11134__auto___327)){\nargs324.push((arguments[i__11135__auto___328]));\n\nvar G__329 = (i__11135__auto___328 + (1));\ni__11135__auto___328 = G__329;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__326 = args324.length;\nswitch (G__326) {\ncase (1):\nreturn quil.core$macros.display_filter.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.display_filter.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args324.length)].join('')));\n\n}\n});\n\nquil.core$macros.display_filter.cljs$core$IFn$_invoke$arity$1 = (function (mode){\nreturn quil.core$macros.current_graphics.call(null).filter((quil.util.resolve_constant_key.call(null,mode,quil.core$macros.filter_modes) | (0)));\n});\n\nquil.core$macros.display_filter.cljs$core$IFn$_invoke$arity$2 = (function (mode,level){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.filter_modes);\nreturn quil.core$macros.current_graphics.call(null).filter((mode__$1 | (0)),level);\n});\n\nquil.core$macros.display_filter.cljs$lang$maxFixedArity = (2);\n/**\n * Calculates the closest int value that is less than or equal to the\n *   value of the parameter. For example, (floor 9.03) returns the value 9.\n */\nquil.core$macros.floor = (function quil$core$macros$floor(n){\nreturn quil.sketch.current_applet.call(null).floor(n);\n});\n/**\n * Returns a boolean value representing whether the applet has focus.\n */\nquil.core$macros.focused = (function quil$core$macros$focused(){\nreturn quil.sketch.current_applet.call(null).focused;\n});\n/**\n * The system variable frameCount contains the number of frames\n *   displayed since the program started. Inside setup() the value is 0\n *   and after the first iteration of draw it is 1, etc.\n */\nquil.core$macros.frame_count = (function quil$core$macros$frame_count(){\nreturn quil.sketch.current_applet.call(null).frameCount;\n});\n/**\n * Returns the current framerate\n */\nquil.core$macros.current_frame_rate = (function quil$core$macros$current_frame_rate(){\nreturn quil.sketch.current_applet.call(null).__frameRate;\n});\n/**\n * Specifies a new target framerate (number of frames to be displayed every\n *   second). If the processor is not fast enough to maintain the\n *   specified rate, it will not be achieved. For example, the function\n *   call (frame-rate 30) will attempt to refresh 30 times a second. It\n *   is recommended to set the frame rate within setup. The default rate\n *   is 60 frames per second.\n */\nquil.core$macros.frame_rate = (function quil$core$macros$frame_rate(new_rate){\ncljs.core.reset_BANG_.call(null,quil.sketch.current_applet.call(null).target_frame_rate,new_rate);\n\nreturn quil.sketch.current_applet.call(null).frameRate(new_rate);\n});\n/**\n * Sets a perspective matrix defined through the parameters. Works\n *   like glFrustum, except it wipes out the current perspective matrix\n *   rather than muliplying itself with it.\n */\nquil.core$macros.frustum = (function quil$core$macros$frustum(left,right,bottom,top,near,far){\nreturn quil.core$macros.current_graphics.call(null).frustum(left,right,bottom,top,near,far);\n});\n/**\n * Reads the color of any pixel or grabs a section of an image. If no\n *   parameters are specified, a copy of entire image is returned. Get the\n *   value of one pixel by specifying an x,y coordinate. Get a section of\n *   the image by specifying an additional width and height parameter.\n *   If the pixel requested is outside of the image window, black is returned.\n *   The numbers returned are scaled according to the current color ranges,\n *   but only RGB values are returned by this function. For example, even though\n *   you may have drawn a shape with (color-mode :hsb), the numbers returned\n *   will be in RGB.\n * \n *   Getting the color of a single pixel with (get x y) is easy, but not\n *   as fast as grabbing the data directly using the pixels fn.\n * \n *   If no img specified - current-graphics is used.\n */\nquil.core$macros.get_pixel = (function quil$core$macros$get_pixel(var_args){\nvar args331 = [];\nvar len__11134__auto___334 = arguments.length;\nvar i__11135__auto___335 = (0);\nwhile(true){\nif((i__11135__auto___335 < len__11134__auto___334)){\nargs331.push((arguments[i__11135__auto___335]));\n\nvar G__336 = (i__11135__auto___335 + (1));\ni__11135__auto___335 = G__336;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__333 = args331.length;\nswitch (G__333) {\ncase (0):\nreturn quil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (5):\nreturn quil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args331.length)].join('')));\n\n}\n});\n\nquil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.get_pixel.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$1 = (function (img){\nreturn img.get();\n});\n\nquil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.core$macros.get_pixel.call(null,quil.core$macros.current_graphics.call(null),x,y);\n});\n\nquil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$3 = (function (img,x,y){\nreturn img.get((x | (0)),(y | (0)));\n});\n\nquil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$4 = (function (x,y,w,h){\nreturn quil.core$macros.get_pixel.call(null,quil.core$macros.current_graphics.call(null),x,y,w,h);\n});\n\nquil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$5 = (function (img,x,y,w,h){\nreturn img.get((x | (0)),(y | (0)),(w | (0)),(h | (0)));\n});\n\nquil.core$macros.get_pixel.cljs$lang$maxFixedArity = (5);\n/**\n * Extracts the green value from a color, scaled to match current\n *   color-mode. This value is always returned as a float so be careful\n *   not to assign it to an int value.\n */\nquil.core$macros.green = (function quil$core$macros$green(col){\nreturn quil.core$macros.current_graphics.call(null).green(cljs.core.unchecked_int.call(null,col));\n});\n/**\n * Converts a byte, char, int, or color to a String containing the\n *   equivalent hexadecimal notation. For example color(0, 102, 153) will\n *   convert to the String \"FF006699\". This function can help make your\n *   geeky debugging sessions much happier. \n */\nquil.core$macros.hex = (function quil$core$macros$hex(var_args){\nvar args338 = [];\nvar len__11134__auto___341 = arguments.length;\nvar i__11135__auto___342 = (0);\nwhile(true){\nif((i__11135__auto___342 < len__11134__auto___341)){\nargs338.push((arguments[i__11135__auto___342]));\n\nvar G__343 = (i__11135__auto___342 + (1));\ni__11135__auto___342 = G__343;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__340 = args338.length;\nswitch (G__340) {\ncase (1):\nreturn quil.core$macros.hex.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.hex.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args338.length)].join('')));\n\n}\n});\n\nquil.core$macros.hex.cljs$core$IFn$_invoke$arity$1 = (function (val){\nreturn quil.sketch.current_applet.call(null).hex(val);\n});\n\nquil.core$macros.hex.cljs$core$IFn$_invoke$arity$2 = (function (val,num_digits){\nreturn quil.sketch.current_applet.call(null).hex(val,num_digits);\n});\n\nquil.core$macros.hex.cljs$lang$maxFixedArity = (2);\n/**\n * Height of the display window. The value of height is zero until\n *   size is called.\n */\nquil.core$macros.height = (function quil$core$macros$height(){\nreturn quil.sketch.current_applet.call(null).height;\n});\n/**\n * Set various hints and hacks for the renderer. This is used to\n *   handle obscure rendering features that cannot be implemented in a\n *   consistent manner across renderers. Many options will often graduate\n *   to standard features instead of hints over time.\n * \n *   Options:\n * \n *   :enable-native-fonts - Use the native version fonts when they are\n *  installed, rather than the bitmapped version from a .vlw\n *  file. This is useful with the default (or JAVA2D) renderer\n *  setting, as it will improve font rendering speed. This is not\n *  enabled by default, because it can be misleading while testing\n *  because the type will look great on your machine (because you have\n *  the font installed) but lousy on others' machines if the identical\n *  font is unavailable. This option can only be set per-sketch, and\n *  must be called before any use of text-font.\n * \n *   :disable-native-fonts - Disables native font support.\n * \n *   :disable-depth-test - Disable the zbuffer, allowing you to draw on\n *  top of everything at will. When depth testing is disabled, items\n *  will be drawn to the screen sequentially, like a painting. This\n *  hint is most often used to draw in 3D, then draw in 2D on top of\n *  it (for instance, to draw GUI controls in 2D on top of a 3D\n *  interface). Starting in release 0149, this will also clear the\n *  depth buffer. Restore the default with :enable-depth-test\n *  but note that with the depth buffer cleared, any 3D drawing that\n *  happens later in draw will ignore existing shapes on the screen.\n * \n *   :enable-depth-test - Enables the zbuffer.\n * \n *   :enable-depth-sort - Enable primitive z-sorting of triangles and\n *  lines in :p3d and :opengl rendering modes. This can slow\n *  performance considerably, and the algorithm is not yet perfect.\n * \n *   :disable-depth-sort - Disables hint :enable-depth-sort\n * \n *   :disable-opengl-errors - Speeds up the OPENGL renderer setting\n *   by not checking for errors while running.\n * \n *   :enable-opengl-errors - Turns on OpenGL error checking\n * \n *   :enable-depth-mask\n *   :disable-depth-mask\n * \n *   :enable-optimized-stroke\n *   :disable-optimized-stroke\n *   :enable-retina-pixels\n *   :disable-retina-pixels\n *   :enable-stroke-perspective\n *   :disable-stroke-perspective\n *   :enable-stroke-pure\n *   :disable-stroke-pure\n *   :enable-texture-mipmaps\n *   :disable-texture-mipmaps\n */\nquil.core$macros.hint = (function quil$core$macros$hint(hint_type){\nvar hint_type__$1 = (((hint_type instanceof cljs.core.Keyword))?cljs.core.get.call(null,quil.core$macros.hint_options,hint_type):hint_type);\nreturn quil.core$macros.current_graphics.call(null).hint((hint_type__$1 | (0)));\n});\n/**\n * Returns the current hour as a value from 0 - 23.\n */\nquil.core$macros.hour = (function quil$core$macros$hour(){\nreturn quil.sketch.current_applet.call(null).hour();\n});\n/**\n * Extracts the hue value from a color.\n */\nquil.core$macros.hue = (function quil$core$macros$hue(col){\nreturn quil.core$macros.current_graphics.call(null).hue(cljs.core.unchecked_int.call(null,col));\n});\n/**\n * Displays images to the screen. Processing currently works with GIF,\n *   JPEG, and Targa images. The color of an image may be modified with\n *   the tint function and if a GIF has transparency, it will maintain\n *   its transparency. The img parameter specifies the image to display\n *   and the x and y parameters define the location of the image from its\n *   upper-left corner. The image is displayed at its original size\n *   unless the width and height parameters specify a different size. The\n *   image-mode fn changes the way the parameters work. A call to\n *   (image-mode :corners) will change the width and height parameters to\n *   define the x and y values of the opposite corner of the image.\n * \n *   Starting with release 0124, when using the default (JAVA2D)\n *   renderer, smooth will also improve image quality of resized\n *   images.\n */\nquil.core$macros.image = (function quil$core$macros$image(var_args){\nvar args345 = [];\nvar len__11134__auto___348 = arguments.length;\nvar i__11135__auto___349 = (0);\nwhile(true){\nif((i__11135__auto___349 < len__11134__auto___348)){\nargs345.push((arguments[i__11135__auto___349]));\n\nvar G__350 = (i__11135__auto___349 + (1));\ni__11135__auto___349 = G__350;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__347 = args345.length;\nswitch (G__347) {\ncase (3):\nreturn quil.core$macros.image.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (5):\nreturn quil.core$macros.image.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args345.length)].join('')));\n\n}\n});\n\nquil.core$macros.image.cljs$core$IFn$_invoke$arity$3 = (function (img,x,y){\nreturn quil.core$macros.current_graphics.call(null).image(img,x,y);\n});\n\nquil.core$macros.image.cljs$core$IFn$_invoke$arity$5 = (function (img,x,y,c,d){\nreturn quil.core$macros.current_graphics.call(null).image(img,x,y,c,d);\n});\n\nquil.core$macros.image.cljs$lang$maxFixedArity = (5);\n/**\n * Originally named filter in Processing Language.\n *   Filters given image with the specified mode and level.\n *   Level defines the quality of the filter and mode may be one of\n *   the following keywords:\n * \n *   :threshold - converts the image to black and white pixels depending\n *             if they are above or below the threshold defined by\n *             the level parameter. The level must be between\n *             0.0 (black) and 1.0 (white). If no level is specified,\n *             0.5 is used.\n *   :gray      - converts any colors in the image to grayscale\n *             equivalents. Doesn't work with level.\n *   :invert    - sets each pixel to its inverse value. Doesn't work with\n *             level.\n *   :posterize - limits each channel of the image to the number of\n *             colors specified as the level parameter. The parameter can\n *             be set to values between 2 and 255, but results are most\n *             noticeable in the lower ranges.\n *   :blur      - executes a Guassian blur with the level parameter\n *             specifying the extent of the blurring. If no level\n *             parameter is used, the blur is equivalent to Guassian\n *             blur of radius 1.\n *   :opaque    - sets the alpha channel to entirely opaque. Doesn't work\n *             with level.\n *   :erode     - reduces the light areas. Doesn't work with level.\n *   :dilate    - increases the light areas.  Doesn't work with level.\n */\nquil.core$macros.image_filter = (function quil$core$macros$image_filter(var_args){\nvar args352 = [];\nvar len__11134__auto___355 = arguments.length;\nvar i__11135__auto___356 = (0);\nwhile(true){\nif((i__11135__auto___356 < len__11134__auto___355)){\nargs352.push((arguments[i__11135__auto___356]));\n\nvar G__357 = (i__11135__auto___356 + (1));\ni__11135__auto___356 = G__357;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__354 = args352.length;\nswitch (G__354) {\ncase (2):\nreturn quil.core$macros.image_filter.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.image_filter.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args352.length)].join('')));\n\n}\n});\n\nquil.core$macros.image_filter.cljs$core$IFn$_invoke$arity$2 = (function (img,mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.filter_modes);\nreturn img.filter((mode__$1 | (0)));\n});\n\nquil.core$macros.image_filter.cljs$core$IFn$_invoke$arity$3 = (function (img,mode,level){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.filter_modes);\nreturn img.filter((mode__$1 | (0)),level);\n});\n\nquil.core$macros.image_filter.cljs$lang$maxFixedArity = (3);\n/**\n * Modifies the location from which images draw. The default mode is :corner.\n * Available modes are:\n * \n *   :corner  - specifies the location to be the upper left corner and\n *           uses the fourth and fifth parameters of image to set the\n *           image's width and height.\n * \n *   :corners - uses the second and third parameters of image to set the\n *           location of one corner of the image and uses the fourth\n *           and fifth parameters to set the opposite corner.\n * \n *   :center  - draw images centered at the given x and y position.\n */\nquil.core$macros.image_mode = (function quil$core$macros$image_mode(mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.image_modes);\nreturn quil.core$macros.current_graphics.call(null).imageMode((mode__$1 | (0)));\n});\n/**\n * The variable keyCode is used to detect special keys such as the UP,\n *   DOWN, LEFT, RIGHT arrow keys and ALT, CONTROL, SHIFT. When checking\n *   for these keys, it's first necessary to check and see if the key is\n *   coded. This is done with the conditional (= (key) CODED).\n * \n *   The keys included in the ASCII specification (BACKSPACE, TAB, ENTER,\n *   RETURN, ESC, and DELETE) do not require checking to see if they key\n *   is coded, and you should simply use the key variable instead of\n *   key-code If you're making cross-platform projects, note that the\n *   ENTER key is commonly used on PCs and Unix and the RETURN key is\n *   used instead on Macintosh. Check for both ENTER and RETURN to make\n *   sure your program will work for all platforms.\n * \n *   For users familiar with Java, the values for UP and DOWN are simply\n *   shorter versions of Java's KeyEvent.VK_UP and\n *   KeyEvent.VK_DOWN. Other keyCode values can be found in the Java\n *   KeyEvent reference.\n */\nquil.core$macros.key_code = (function quil$core$macros$key_code(){\nreturn quil.sketch.current_applet.call(null).keyCode;\n});\n/**\n * true if any key is currently pressed, false otherwise.\n */\nquil.core$macros.key_pressed_QMARK_ = (function quil$core$macros$key_pressed_QMARK_(){\nreturn quil.sketch.current_applet.call(null).keyPressed;\n});\n/**\n * Sets the falloff rates for point lights, spot lights, and ambient\n *   lights. The parameters are used to determine the falloff with the\n *   following equation:\n * \n *   d = distance from light position to vertex position\n *   falloff = 1 / (CONSTANT + d * LINEAR + (d*d) * QUADRATIC)\n * \n *   Like fill, it affects only the elements which are created after it\n *   in the code. The default value is (light-falloff 1.0 0.0 0.0).\n *   Thinking about an ambient light with a falloff can be tricky. It is\n *   used, for example, if you wanted a region of your scene to be lit\n *   ambiently one color and another region to be lit ambiently by\n *   another color, you would use an ambient light with location and\n *   falloff. You can think of it as a point light that doesn't care\n *   which direction a surface is facing.\n */\nquil.core$macros.light_falloff = (function quil$core$macros$light_falloff(constant,linear,quadratic){\nreturn quil.core$macros.current_graphics.call(null).lightFalloff(constant,linear,quadratic);\n});\n/**\n * Calculates a color or colors between two color at a specific\n *   increment. The amt parameter is the amount to interpolate between\n *   the two values where 0.0 equal to the first point, 0.1 is very near\n *   the first point, 0.5 is half-way in between, etc.\n */\nquil.core$macros.lerp_color = (function quil$core$macros$lerp_color(c1,c2,amt){\nreturn quil.core$macros.current_graphics.call(null).lerpColor(cljs.core.unchecked_int.call(null,c1),cljs.core.unchecked_int.call(null,c2),amt);\n});\n/**\n * Calculates a number between two numbers at a specific\n *   increment. The amt parameter is the amount to interpolate between\n *   the two values where 0.0 equal to the first point, 0.1 is very near\n *   the first point, 0.5 is half-way in between, etc. The lerp function\n *   is convenient for creating motion along a straight path and for\n *   drawing dotted lines.\n */\nquil.core$macros.lerp = (function quil$core$macros$lerp(start,stop,amt){\nreturn quil.sketch.current_applet.call(null).lerp(start,stop,amt);\n});\n/**\n * Sets the default ambient light, directional light, falloff, and\n *   specular values. The defaults are:\n * \n *   (ambient-light 128 128 128)\n *   (directional-light 128 128 128 0 0 -1)\n *   (light-falloff 1 0 0)\n *   (light-specular 0 0 0).\n * \n *   Lights need to be included in the draw to remain persistent in a\n *   looping program. Placing them in the setup of a looping program\n *   will cause them to only have an effect the first time through the\n *   loop.\n */\nquil.core$macros.lights = (function quil$core$macros$lights(){\nreturn quil.core$macros.current_graphics.call(null).lights();\n});\n/**\n * Sets the specular color for lights. Like fill, it affects only the\n *   elements which are created after it in the code. Specular refers to\n *   light which bounces off a surface in a perferred direction (rather\n *   than bouncing in all directions like a diffuse light) and is used\n *   for creating highlights. The specular quality of a light interacts\n *   with the specular material qualities set through the specular and\n *   shininess functions.\n */\nquil.core$macros.light_specular = (function quil$core$macros$light_specular(r,g,b){\nreturn quil.core$macros.current_graphics.call(null).lightSpecular(r,g,b);\n});\n/**\n * Draws a line (a direct path between two points) to the screen. The\n *   version of line with four parameters draws the line in 2D. To color\n *   a line, use the stroke function. A line cannot be filled, therefore\n *   the fill method will not affect the color of a line. 2D lines are\n *   drawn with a width of one pixel by default, but this can be changed\n *   with the stroke-weight function. The version with six parameters\n *   allows the line to be placed anywhere within XYZ space. \n */\nquil.core$macros.line = (function quil$core$macros$line(var_args){\nvar args359 = [];\nvar len__11134__auto___362 = arguments.length;\nvar i__11135__auto___363 = (0);\nwhile(true){\nif((i__11135__auto___363 < len__11134__auto___362)){\nargs359.push((arguments[i__11135__auto___363]));\n\nvar G__364 = (i__11135__auto___363 + (1));\ni__11135__auto___363 = G__364;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__361 = args359.length;\nswitch (G__361) {\ncase (2):\nreturn quil.core$macros.line.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.line.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (6):\nreturn quil.core$macros.line.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args359.length)].join('')));\n\n}\n});\n\nquil.core$macros.line.cljs$core$IFn$_invoke$arity$2 = (function (p1,p2){\nreturn cljs.core.apply.call(null,quil.core$macros.line,cljs.core.concat.call(null,p1,p2));\n});\n\nquil.core$macros.line.cljs$core$IFn$_invoke$arity$4 = (function (x1,y1,x2,y2){\nreturn quil.core$macros.current_graphics.call(null).line(x1,y1,x2,y2);\n});\n\nquil.core$macros.line.cljs$core$IFn$_invoke$arity$6 = (function (x1,y1,z1,x2,y2,z2){\nreturn quil.core$macros.current_graphics.call(null).line(x1,y1,z1,x2,y2,z2);\n});\n\nquil.core$macros.line.cljs$lang$maxFixedArity = (6);\n/**\n * Loads a font into a variable of type PFont. To load correctly,\n *   fonts must be located in the data directory of the current sketch.\n *   To create a font to use with Processing use the create-font fn.\n * \n *   Like load-image and other methods that load data, the load-font fn\n *   should not be used inside draw, because it will slow down the sketch\n *   considerably, as the font will be re-loaded from the disk (or\n *   network) on each frame.\n * \n *   For most renderers, Processing displays fonts using the .vlw font\n *   format, which uses images for each letter, rather than defining them\n *   through vector data. When hint :enable-native-fonts is used with the\n *   JAVA2D renderer, the native version of a font will be used if it is\n *   installed on the user's machine.\n * \n *   Using create-font (instead of load-font) enables vector data to be\n *   used with the JAVA2D (default) renderer setting. This can be helpful\n *   when many font sizes are needed, or when using any renderer based on\n *   JAVA2D, such as the PDF library.\n */\nquil.core$macros.load_font = (function quil$core$macros$load_font(filename){\nreturn quil.sketch.current_applet.call(null).loadFont([cljs.core.str(filename)].join(''));\n});\n/**\n * Loads an image into a variable of type PImage. Four types of\n *   images ( .gif, .jpg, .tga, .png) images may be loaded. To load\n *   correctly, images must be located in the data directory of the\n *   current sketch. In most cases, load all images in setup to preload\n *   them at the start of the program. Loading images inside draw will\n *   reduce the speed of a program.\n * \n *   The filename parameter can also be a URL to a file found online.\n * \n *   If an image is not loaded successfully, the null value is returned\n *   and an error message will be printed to the console. The error\n *   message does not halt the program, however the null value may cause\n *   a NullPointerException if your code does not check whether the value\n *   returned from load-image is nil.\n * \n *   Depending on the type of error, a PImage object may still be\n *   returned, but the width and height of the image will be set to\n *   -1. This happens if bad image data is returned or cannot be decoded\n *   properly. Sometimes this happens with image URLs that produce a 403\n *   error or that redirect to a password prompt, because load-image\n *   will attempt to interpret the HTML as image data.\n */\nquil.core$macros.load_image = (function quil$core$macros$load_image(filename){\nreturn quil.sketch.current_applet.call(null).loadImage([cljs.core.str(filename)].join(''));\n});\n/**\n * Loads a shader into the PShader object. Shaders are compatible with the\n *   P2D and P3D renderers, but not with the default renderer.\n */\nquil.core$macros.load_shader = (function quil$core$macros$load_shader(var_args){\nvar args366 = [];\nvar len__11134__auto___369 = arguments.length;\nvar i__11135__auto___370 = (0);\nwhile(true){\nif((i__11135__auto___370 < len__11134__auto___369)){\nargs366.push((arguments[i__11135__auto___370]));\n\nvar G__371 = (i__11135__auto___370 + (1));\ni__11135__auto___370 = G__371;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__368 = args366.length;\nswitch (G__368) {\ncase (1):\nreturn quil.core$macros.load_shader.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.load_shader.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args366.length)].join('')));\n\n}\n});\n\nquil.core$macros.load_shader.cljs$core$IFn$_invoke$arity$1 = (function (fragment_filename){\nreturn quil.core$macros.current_graphics.call(null).loadShader(fragment_filename);\n});\n\nquil.core$macros.load_shader.cljs$core$IFn$_invoke$arity$2 = (function (fragment_filename,vertex_filename){\nreturn quil.core$macros.current_graphics.call(null).loadShader(fragment_filename,vertex_filename);\n});\n\nquil.core$macros.load_shader.cljs$lang$maxFixedArity = (2);\n/**\n * Load a geometry from a file as a PShape.\n */\nquil.core$macros.load_shape = (function quil$core$macros$load_shape(filename){\nreturn quil.sketch.current_applet.call(null).loadShape(filename);\n});\n/**\n * Calculates the natural logarithm (the base-e logarithm) of a\n *   number. This function expects the values greater than 0.0.\n */\nquil.core$macros.log = (function quil$core$macros$log(val){\nreturn quil.sketch.current_applet.call(null).log(val);\n});\n/**\n * Calculates the magnitude (or length) of a vector. A vector is a\n *   direction in space commonly used in computer graphics and linear\n *   algebra. Because it has no start position, the magnitude of a vector\n *   can be thought of as the distance from coordinate (0,0) to its (x,y)\n *   value. Therefore, mag is a shortcut for writing (dist 0 0 x y).\n */\nquil.core$macros.mag = (function quil$core$macros$mag(var_args){\nvar args373 = [];\nvar len__11134__auto___376 = arguments.length;\nvar i__11135__auto___377 = (0);\nwhile(true){\nif((i__11135__auto___377 < len__11134__auto___376)){\nargs373.push((arguments[i__11135__auto___377]));\n\nvar G__378 = (i__11135__auto___377 + (1));\ni__11135__auto___377 = G__378;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__375 = args373.length;\nswitch (G__375) {\ncase (2):\nreturn quil.core$macros.mag.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.mag.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args373.length)].join('')));\n\n}\n});\n\nquil.core$macros.mag.cljs$core$IFn$_invoke$arity$2 = (function (a,b){\nreturn quil.sketch.current_applet.call(null).mag(a,b);\n});\n\nquil.core$macros.mag.cljs$core$IFn$_invoke$arity$3 = (function (a,b,c){\nreturn quil.sketch.current_applet.call(null).mag(a,b,c);\n});\n\nquil.core$macros.mag.cljs$lang$maxFixedArity = (3);\n/**\n * Re-maps a number from one range to another.\n * \n *   Numbers outside the range are not clamped to 0 and 1, because\n *   out-of-range values are often intentional and useful.\n */\nquil.core$macros.map_range = (function quil$core$macros$map_range(val,low1,high1,low2,high2){\nreturn quil.sketch.current_applet.call(null).map(val,low1,high1,low2,high2);\n});\n/**\n * Returns the number of milliseconds (thousandths of a second) since\n *   starting the sketch. This information is often used for timing\n *   animation sequences.\n */\nquil.core$macros.millis = (function quil$core$macros$millis(){\nreturn quil.sketch.current_applet.call(null).millis();\n});\n/**\n * Returns the current minute as a value from 0 - 59\n */\nquil.core$macros.minute = (function quil$core$macros$minute(){\nreturn quil.sketch.current_applet.call(null).minute();\n});\n/**\n * Returns the three-dimensional x, y, z position in model space. This\n *   returns the x value for a given coordinate based on the current set\n *   of transformations (scale, rotate, translate, etc.) The x value can\n *   be used to place an object in space relative to the location of the\n *   original point once the transformations are no longer in use.\n */\nquil.core$macros.model_x = (function quil$core$macros$model_x(x,y,z){\nreturn quil.core$macros.current_graphics.call(null).modelX(x,y,z);\n});\n/**\n * Returns the three-dimensional x, y, z position in model space. This\n *   returns the y value for a given coordinate based on the current set\n *   of transformations (scale, rotate, translate, etc.) The y value can\n *   be used to place an object in space relative to the location of the\n *   original point once the transformations are no longer in use.\n */\nquil.core$macros.model_y = (function quil$core$macros$model_y(x,y,z){\nreturn quil.core$macros.current_graphics.call(null).modelY(x,y,z);\n});\n/**\n * Returns the three-dimensional x, y, z position in model space. This\n *   returns the z value for a given coordinate based on the current set\n *   of transformations (scale, rotate, translate, etc.) The z value can\n *   be used to place an object in space relative to the location of the\n *   original point once the transformations are no longer in use.\n */\nquil.core$macros.model_z = (function quil$core$macros$model_z(x,y,z){\nreturn quil.core$macros.current_graphics.call(null).modelZ(x,y,z);\n});\n/**\n * Returns the current month as a value from 1 - 12.\n */\nquil.core$macros.month = (function quil$core$macros$month(){\nreturn quil.sketch.current_applet.call(null).month();\n});\n/**\n * The value of the system variable mouseButton is either :left, :right,\n *   or :center depending on which button is pressed. nil if no button pressed\n */\nquil.core$macros.mouse_button = (function quil$core$macros$mouse_button(){\nvar button_code = quil.sketch.current_applet.call(null).mouseButton;\nvar pred__383 = cljs.core._EQ_;\nvar expr__384 = button_code;\nif(cljs.core.truth_(pred__383.call(null,(37),expr__384))){\nreturn new cljs.core.Keyword(null,\"left\",\"left\",(-399115937));\n} else {\nif(cljs.core.truth_(pred__383.call(null,(39),expr__384))){\nreturn new cljs.core.Keyword(null,\"right\",\"right\",(-452581833));\n} else {\nif(cljs.core.truth_(pred__383.call(null,(3),expr__384))){\nreturn new cljs.core.Keyword(null,\"center\",\"center\",(-748944368));\n} else {\nreturn null;\n}\n}\n}\n});\n/**\n * Variable storing if a mouse button is pressed. The value of the\n *   system variable mousePressed is true if a mouse button is pressed\n *   and false if a button is not pressed.\n */\nquil.core$macros.mouse_pressed_QMARK_ = (function quil$core$macros$mouse_pressed_QMARK_(){\nreturn quil.sketch.current_applet.call(null).mousePressed;\n});\n/**\n * Current horizontal coordinate of the mouse.\n */\nquil.core$macros.mouse_x = (function quil$core$macros$mouse_x(){\nreturn quil.sketch.current_applet.call(null).mouseX;\n});\n/**\n * Current vertical coordinate of the mouse.\n */\nquil.core$macros.mouse_y = (function quil$core$macros$mouse_y(){\nreturn quil.sketch.current_applet.call(null).mouseY;\n});\n/**\n * Hides the cursor from view. Will not work when running the in full\n *   screen (Present) mode.\n */\nquil.core$macros.no_cursor = (function quil$core$macros$no_cursor(){\nreturn quil.sketch.current_applet.call(null).noCursor();\n});\n/**\n * Disables filling geometry. If both no-stroke and no-fill are called,\n *   nothing will be drawn to the screen.\n */\nquil.core$macros.no_fill = (function quil$core$macros$no_fill(){\nquil.core$macros.current_graphics.call(null).noFill();\n\nreturn (quil.core$macros.current_graphics.call(null)[quil.core$macros.no_fill_prop] = true);\n});\n/**\n * Returns the Perlin noise value at specified coordinates. Perlin\n *   noise is a random sequence generator producing a more natural\n *   ordered, harmonic succession of numbers compared to the standard\n *   random function. It was invented by Ken Perlin in the 1980s and\n *   been used since in graphical applications to produce procedural\n *   textures, natural motion, shapes, terrains etc.\n * \n *   The main difference to the random function is that Perlin noise is\n *   defined in an infinite n-dimensional space where each pair of\n *   coordinates corresponds to a fixed semi-random value (fixed only for\n *   the lifespan of the program). The resulting value will always be\n *   between 0.0 and 1.0. Processing can compute 1D, 2D and 3D noise,\n *   depending on the number of coordinates given. The noise value can be\n *   animated by moving through the noise space and the 2nd and 3rd\n *   dimensions can also be interpreted as time.\n * \n *   The actual noise is structured similar to an audio signal, in\n *   respect to the function's use of frequencies. Similar to the concept\n *   of harmonics in physics, perlin noise is computed over several\n *   octaves which are added together for the final result.\n * \n *   Another way to adjust the character of the resulting sequence is the\n *   scale of the input coordinates. As the function works within an\n *   infinite space the value of the coordinates doesn't matter as such,\n *   only the distance between successive coordinates does (eg. when\n *   using noise within a loop). As a general rule the smaller the\n *   difference between coordinates, the smoother the resulting noise\n *   sequence will be. Steps of 0.005-0.03 work best for most\n *   applications, but this will differ depending on use.\n */\nquil.core$macros.noise = (function quil$core$macros$noise(var_args){\nvar args386 = [];\nvar len__11134__auto___389 = arguments.length;\nvar i__11135__auto___390 = (0);\nwhile(true){\nif((i__11135__auto___390 < len__11134__auto___389)){\nargs386.push((arguments[i__11135__auto___390]));\n\nvar G__391 = (i__11135__auto___390 + (1));\ni__11135__auto___390 = G__391;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__388 = args386.length;\nswitch (G__388) {\ncase (1):\nreturn quil.core$macros.noise.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.noise.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.noise.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args386.length)].join('')));\n\n}\n});\n\nquil.core$macros.noise.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn quil.sketch.current_applet.call(null).noise(x);\n});\n\nquil.core$macros.noise.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.sketch.current_applet.call(null).noise(x,y);\n});\n\nquil.core$macros.noise.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.sketch.current_applet.call(null).noise(x,y,z);\n});\n\nquil.core$macros.noise.cljs$lang$maxFixedArity = (3);\n/**\n * Adjusts the character and level of detail produced by the Perlin\n *   noise function. Similar to harmonics in physics, noise is computed\n *   over several octaves. Lower octaves contribute more to the output\n *   signal and as such define the overal intensity of the noise, whereas\n *   higher octaves create finer grained details in the noise\n *   sequence. By default, noise is computed over 4 octaves with each\n *   octave contributing exactly half than its predecessor, starting at\n *   50% strength for the 1st octave. This falloff amount can be changed\n *   by adding an additional function parameter. Eg. a falloff factor of\n *   0.75 means each octave will now have 75% impact (25% less) of the\n *   previous lower octave. Any value between 0.0 and 1.0 is valid,\n *   however note that values greater than 0.5 might result in greater\n *   than 1.0 values returned by noise.\n * \n *   By changing these parameters, the signal created by the noise\n *   function can be adapted to fit very specific needs and\n *   characteristics.\n */\nquil.core$macros.noise_detail = (function quil$core$macros$noise_detail(var_args){\nvar args393 = [];\nvar len__11134__auto___396 = arguments.length;\nvar i__11135__auto___397 = (0);\nwhile(true){\nif((i__11135__auto___397 < len__11134__auto___396)){\nargs393.push((arguments[i__11135__auto___397]));\n\nvar G__398 = (i__11135__auto___397 + (1));\ni__11135__auto___397 = G__398;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__395 = args393.length;\nswitch (G__395) {\ncase (1):\nreturn quil.core$macros.noise_detail.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.noise_detail.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args393.length)].join('')));\n\n}\n});\n\nquil.core$macros.noise_detail.cljs$core$IFn$_invoke$arity$1 = (function (octaves){\nreturn quil.sketch.current_applet.call(null).noiseDetail((octaves | (0)));\n});\n\nquil.core$macros.noise_detail.cljs$core$IFn$_invoke$arity$2 = (function (octaves,falloff){\nreturn quil.sketch.current_applet.call(null).noiseDetail((octaves | (0)),falloff);\n});\n\nquil.core$macros.noise_detail.cljs$lang$maxFixedArity = (2);\n/**\n * Sets the seed value for noise. By default, noise produces different\n *   results each time the program is run. Set the value parameter to a\n *   constant to return the same pseudo-random numbers each time the\n *   software is run.\n */\nquil.core$macros.noise_seed = (function quil$core$macros$noise_seed(val){\nreturn quil.sketch.current_applet.call(null).noiseSeed((val | (0)));\n});\n/**\n * Disable all lighting. Lighting is turned off by default and enabled\n *   with the lights fn. This function can be used to disable lighting so\n *   that 2D geometry (which does not require lighting) can be drawn\n *   after a set of lighted 3D geometry.\n */\nquil.core$macros.no_lights = (function quil$core$macros$no_lights(){\nreturn quil.core$macros.current_graphics.call(null).noLights();\n});\n/**\n * Stops Processing from continuously executing the code within\n *   draw. If start-loop is called, the code in draw will begin to run\n *   continuously again. If using no-loop in setup, it should be the last\n *   line inside the block.\n * \n *   When no-loop is used, it's not possible to manipulate or access the\n *   screen inside event handling functions such as mouse-pressed or\n *   key-pressed. Instead, use those functions to call redraw or\n *   loop which will run draw, which can update the screen\n *   properly. This means that when no-loop has been called, no drawing\n *   can happen, and functions like save-frame may not be used.\n * \n *   Note that if the sketch is resized, redraw will be called to\n *   update the sketch, even after no-oop has been\n *   specified. Otherwise, the sketch would enter an odd state until\n *   loop was called.\n */\nquil.core$macros.no_loop = (function quil$core$macros$no_loop(){\nreturn quil.sketch.current_applet.call(null).noLoop();\n});\n/**\n * Normalize a value to exist between 0 and 1 (inclusive).\n */\nquil.core$macros.norm = (function quil$core$macros$norm(val,start,stop){\nreturn quil.sketch.current_applet.call(null).norm(val,start,stop);\n});\n/**\n * Sets the current normal vector. This is for drawing three\n *   dimensional shapes and surfaces and specifies a vector perpendicular\n *   to the surface of the shape which determines how lighting affects\n *   it. Processing attempts to automatically assign normals to shapes,\n *   but since that's imperfect, this is a better option when you want\n *   more control. This function is identical to glNormal3f() in OpenGL.\n */\nquil.core$macros.normal = (function quil$core$macros$normal(nx,ny,nz){\nreturn quil.core$macros.current_graphics.call(null).normal(nx,ny,nz);\n});\n/**\n * Draws all geometry with jagged (aliased) edges. Must be called inside\n *   :settings handler.\n */\nquil.core$macros.no_smooth = (function quil$core$macros$no_smooth(){\nreturn quil.core$macros.current_graphics.call(null).noSmooth();\n});\n/**\n * Disables drawing the stroke (outline). If both no-stroke and\n *   no-fill are called, nothing will be drawn to the screen.\n */\nquil.core$macros.no_stroke = (function quil$core$macros$no_stroke(){\nreturn quil.core$macros.current_graphics.call(null).noStroke();\n});\n/**\n * Removes the current fill value for displaying images and reverts to\n *   displaying images with their original hues.\n */\nquil.core$macros.no_tint = (function quil$core$macros$no_tint(){\nreturn quil.core$macros.current_graphics.call(null).noTint();\n});\n/**\n * Sets an orthographic projection and defines a parallel clipping\n *   volume. All objects with the same dimension appear the same size,\n *   regardless of whether they are near or far from the camera. The\n *   parameters to this function specify the clipping volume where left\n *   and right are the minimum and maximum x values, top and bottom are\n *   the minimum and maximum y values, and near and far are the minimum\n *   and maximum z values. If no parameters are given, the default is\n *   used: (ortho 0 width 0 height -10 10)\n */\nquil.core$macros.ortho = (function quil$core$macros$ortho(var_args){\nvar args400 = [];\nvar len__11134__auto___403 = arguments.length;\nvar i__11135__auto___404 = (0);\nwhile(true){\nif((i__11135__auto___404 < len__11134__auto___403)){\nargs400.push((arguments[i__11135__auto___404]));\n\nvar G__405 = (i__11135__auto___404 + (1));\ni__11135__auto___404 = G__405;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__402 = args400.length;\nswitch (G__402) {\ncase (0):\nreturn quil.core$macros.ortho.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (4):\nreturn quil.core$macros.ortho.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (6):\nreturn quil.core$macros.ortho.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args400.length)].join('')));\n\n}\n});\n\nquil.core$macros.ortho.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.current_graphics.call(null).ortho();\n});\n\nquil.core$macros.ortho.cljs$core$IFn$_invoke$arity$4 = (function (left,right,bottom,top){\nreturn quil.core$macros.current_graphics.call(null).ortho(left,right,bottom,top);\n});\n\nquil.core$macros.ortho.cljs$core$IFn$_invoke$arity$6 = (function (left,right,bottom,top,near,far){\nreturn quil.core$macros.current_graphics.call(null).ortho(left,right,bottom,top,near,far);\n});\n\nquil.core$macros.ortho.cljs$lang$maxFixedArity = (6);\n/**\n * Sets a perspective projection applying foreshortening, making\n *   distant objects appear smaller than closer ones. The parameters\n *   define a viewing volume with the shape of truncated pyramid. Objects\n *   near to the front of the volume appear their actual size, while\n *   farther objects appear smaller. This projection simulates the\n *   perspective of the world more accurately than orthographic\n *   projection. The version of perspective without parameters sets the\n *   default perspective and the version with four parameters allows the\n *   programmer to set the area precisely. The default values are:\n *   perspective(PI/3.0, width/height, cameraZ/10.0, cameraZ*10.0) where\n *   cameraZ is ((height/2.0) / tan(PI*60.0/360.0));\n */\nquil.core$macros.perspective = (function quil$core$macros$perspective(var_args){\nvar args407 = [];\nvar len__11134__auto___410 = arguments.length;\nvar i__11135__auto___411 = (0);\nwhile(true){\nif((i__11135__auto___411 < len__11134__auto___410)){\nargs407.push((arguments[i__11135__auto___411]));\n\nvar G__412 = (i__11135__auto___411 + (1));\ni__11135__auto___411 = G__412;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__409 = args407.length;\nswitch (G__409) {\ncase (0):\nreturn quil.core$macros.perspective.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (4):\nreturn quil.core$macros.perspective.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args407.length)].join('')));\n\n}\n});\n\nquil.core$macros.perspective.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.current_graphics.call(null).perspective();\n});\n\nquil.core$macros.perspective.cljs$core$IFn$_invoke$arity$4 = (function (fovy,aspect,z_near,z_far){\nreturn quil.core$macros.current_graphics.call(null).perspective(fovy,aspect,z_near,z_far);\n});\n\nquil.core$macros.perspective.cljs$lang$maxFixedArity = (4);\n/**\n * Array containing the values for all the pixels in the display\n *   window or image. This array is therefore the size of the display window. If\n *   this array is modified, the update-pixels fn must be called to update\n *   the changes. Calls .loadPixels before obtaining the pixel array.\n */\nquil.core$macros.pixels = (function quil$core$macros$pixels(var_args){\nvar args414 = [];\nvar len__11134__auto___417 = arguments.length;\nvar i__11135__auto___418 = (0);\nwhile(true){\nif((i__11135__auto___418 < len__11134__auto___417)){\nargs414.push((arguments[i__11135__auto___418]));\n\nvar G__419 = (i__11135__auto___418 + (1));\ni__11135__auto___418 = G__419;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__416 = args414.length;\nswitch (G__416) {\ncase (0):\nreturn quil.core$macros.pixels.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.pixels.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args414.length)].join('')));\n\n}\n});\n\nquil.core$macros.pixels.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.pixels.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.pixels.cljs$core$IFn$_invoke$arity$1 = (function (img){\nimg.loadPixels();\n\nvar pix_array = img.pixels.toArray();\nimg.stored_pix_array = pix_array;\n\nreturn pix_array;\n});\n\nquil.core$macros.pixels.cljs$lang$maxFixedArity = (1);\n/**\n * Horizontal coordinate of the mouse in the previous frame\n */\nquil.core$macros.pmouse_x = (function quil$core$macros$pmouse_x(){\nreturn quil.sketch.current_applet.call(null).pmouseX;\n});\n/**\n * Vertical coordinate of the mouse in the previous frame\n */\nquil.core$macros.pmouse_y = (function quil$core$macros$pmouse_y(){\nreturn quil.sketch.current_applet.call(null).pmouseY;\n});\n/**\n * Draws a point, a coordinate in space at the dimension of one\n *   pixel. The first parameter is the horizontal value for the point,\n *   the second value is the vertical value for the point, and the\n *   optional third value is the depth value. Drawing this shape in 3D\n *   using the z parameter requires the :P3D or :opengl renderer to be\n *   used.\n */\nquil.core$macros.point = (function quil$core$macros$point(var_args){\nvar args421 = [];\nvar len__11134__auto___424 = arguments.length;\nvar i__11135__auto___425 = (0);\nwhile(true){\nif((i__11135__auto___425 < len__11134__auto___424)){\nargs421.push((arguments[i__11135__auto___425]));\n\nvar G__426 = (i__11135__auto___425 + (1));\ni__11135__auto___425 = G__426;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__423 = args421.length;\nswitch (G__423) {\ncase (2):\nreturn quil.core$macros.point.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.point.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args421.length)].join('')));\n\n}\n});\n\nquil.core$macros.point.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.core$macros.current_graphics.call(null).point(x,y);\n});\n\nquil.core$macros.point.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.current_graphics.call(null).point(x,y,z);\n});\n\nquil.core$macros.point.cljs$lang$maxFixedArity = (3);\n/**\n * Adds a point light. Lights need to be included in the draw() to\n *   remain persistent in a looping program. Placing them in the setup()\n *   of a looping program will cause them to only have an effect the\n *   first time through the loop. The affect of the r, g, and b\n *   parameters is determined by the current color mode. The x, y, and z\n *   parameters set the position of the light\n */\nquil.core$macros.point_light = (function quil$core$macros$point_light(r,g,b,x,y,z){\nreturn quil.core$macros.current_graphics.call(null).pointLight(r,g,b,x,y,z);\n});\n/**\n * Pops the current transformation matrix off the matrix\n *   stack. Understanding pushing and popping requires understanding the\n *   concept of a matrix stack. The push-matrix fn saves the current\n *   coordinate system to the stack and pop-matrix restores the prior\n *   coordinate system. push-matrix and pop-matrix are used in conjuction\n *   with the other transformation methods and may be embedded to control\n *   the scope of the transformations.\n */\nquil.core$macros.pop_matrix = (function quil$core$macros$pop_matrix(){\nreturn quil.core$macros.current_graphics.call(null).popMatrix();\n});\n/**\n * Restores the prior settings on the 'style stack'. Used in\n *   conjunction with push-style. Together they allow you to change the\n *   style settings and later return to what you had. When a new style is\n *   started with push-style, it builds on the current style information.\n *   The push-style and pop-style functions can be nested to provide more\n *   control\n */\nquil.core$macros.pop_style = (function quil$core$macros$pop_style(){\nreturn quil.core$macros.current_graphics.call(null).popStyle();\n});\n/**\n * Facilitates exponential expressions. The pow() function is an\n *   efficient way of multiplying numbers by themselves (or their\n *   reciprocal) in large quantities. For example, (pow 3 5) is\n *   equivalent to the expression (* 3 3 3 3 3) and (pow 3 -5) is\n *   equivalent to (/ 1 (* 3 3 3 3 3)).\n */\nquil.core$macros.pow = (function quil$core$macros$pow(num,exponent){\nreturn quil.sketch.current_applet.call(null).pow(num,exponent);\n});\n/**\n * Prints the current camera matrix to std out. Useful for debugging.\n */\nquil.core$macros.print_camera = (function quil$core$macros$print_camera(){\nreturn quil.core$macros.current_graphics.call(null).printCamera();\n});\n/**\n * Prints the current matrix to std out. Useful for debugging.\n */\nquil.core$macros.print_matrix = (function quil$core$macros$print_matrix(){\nreturn quil.core$macros.current_graphics.call(null).printMatrix();\n});\n/**\n * Prints the current projection matrix to std out. Useful for\n *   debugging\n */\nquil.core$macros.print_projection = (function quil$core$macros$print_projection(){\nreturn quil.core$macros.current_graphics.call(null).printProjection();\n});\n/**\n * Pushes the current transformation matrix onto the matrix\n *   stack. Understanding push-matrix and pop-matrix requires\n *   understanding the concept of a matrix stack. The push-matrix\n *   function saves the current coordinate system to the stack and\n *   pop-matrix restores the prior coordinate system. push-matrix and\n *   pop-matrix are used in conjuction with the other transformation\n *   methods and may be embedded to control the scope of the\n *   transformations.\n */\nquil.core$macros.push_matrix = (function quil$core$macros$push_matrix(){\nreturn quil.core$macros.current_graphics.call(null).pushMatrix();\n});\n/**\n * Saves the current style settings onto a 'style stack'. Use with\n *   pop-style which restores the prior settings. Note that these\n *   functions are always used together. They allow you to change the\n *   style settings and later return to what you had. When a new style is\n *   started with push-style, it builds on the current style\n *   information. The push-style and pop-style fns can be embedded to\n *   provide more control.\n * \n *   The style information controlled by the following functions are\n *   included in the style: fill, stroke, tint, stroke-weight,\n *   stroke-cap, stroke-join, image-mode, rect-mode, ellipse-mode,\n *   shape-mode, color-mode, text-align, text-font, text-mode, text-size,\n *   text-leading, emissive, specular, shininess, and ambient\n */\nquil.core$macros.push_style = (function quil$core$macros$push_style(){\nreturn quil.core$macros.current_graphics.call(null).pushStyle();\n});\n/**\n * A quad is a quadrilateral, a four sided polygon. It is similar to a\n *   rectangle, but the angles between its edges are not constrained to\n *   be ninety degrees. The first pair of parameters (x1,y1) sets the\n *   first vertex and the subsequent pairs should proceed clockwise or\n *   counter-clockwise around the defined shape.\n */\nquil.core$macros.quad = (function quil$core$macros$quad(x1,y1,x2,y2,x3,y3,x4,y4){\nreturn quil.core$macros.current_graphics.call(null).quad(x1,y1,x2,y2,x3,y3,x4,y4);\n});\n/**\n * Specifies vertex coordinates for quadratic Bezier curves. Each call to\n *   quadratic-vertex defines the position of one control points and one\n *   anchor point of a Bezier curve, adding a new segment to a line or shape.\n *   The first time quadratic-vertex is used within a begin-shape call, it\n *   must be prefaced with a call to vertex to set the first anchor point.\n *   This function must be used between begin-shape and end-shape and only\n *   when there is no MODE parameter specified to begin-shape. Using the 3D\n *   version requires rendering with :p3d.\n */\nquil.core$macros.quadratic_vertex = (function quil$core$macros$quadratic_vertex(var_args){\nvar args428 = [];\nvar len__11134__auto___431 = arguments.length;\nvar i__11135__auto___432 = (0);\nwhile(true){\nif((i__11135__auto___432 < len__11134__auto___431)){\nargs428.push((arguments[i__11135__auto___432]));\n\nvar G__433 = (i__11135__auto___432 + (1));\ni__11135__auto___432 = G__433;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__430 = args428.length;\nswitch (G__430) {\ncase (4):\nreturn quil.core$macros.quadratic_vertex.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (6):\nreturn quil.core$macros.quadratic_vertex.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args428.length)].join('')));\n\n}\n});\n\nquil.core$macros.quadratic_vertex.cljs$core$IFn$_invoke$arity$4 = (function (cx,cy,x3,y3){\nreturn quil.core$macros.current_graphics.call(null).quadraticVertex(cx,cy,x3,y3);\n});\n\nquil.core$macros.quadratic_vertex.cljs$core$IFn$_invoke$arity$6 = (function (cx,cy,cz,x3,y3,z3){\nreturn quil.core$macros.current_graphics.call(null).quadraticVertex(cx,cy,cz,x3,y3,z3);\n});\n\nquil.core$macros.quadratic_vertex.cljs$lang$maxFixedArity = (6);\nquil.core$macros.radians = (function quil$core$macros$radians(degrees){\nreturn quil.sketch.current_applet.call(null).radians(degrees);\n});\n/**\n * Generates random numbers. Each time the random function is called,\n *   it returns an unexpected value within the specified range. If one\n *   parameter is passed to the function it will return a float between\n *   zero and the value of the high parameter. The function call (random\n *   5) returns values between 0 and 5 (starting at zero, up to but not\n *   including 5). If two parameters are passed, it will return a float\n *   with a value between the parameters. The function call\n *   (random -5 10.2) returns values starting at -5 up to (but not\n *   including) 10.2.\n */\nquil.core$macros.random = (function quil$core$macros$random(var_args){\nvar args435 = [];\nvar len__11134__auto___438 = arguments.length;\nvar i__11135__auto___439 = (0);\nwhile(true){\nif((i__11135__auto___439 < len__11134__auto___438)){\nargs435.push((arguments[i__11135__auto___439]));\n\nvar G__440 = (i__11135__auto___439 + (1));\ni__11135__auto___439 = G__440;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__437 = args435.length;\nswitch (G__437) {\ncase (1):\nreturn quil.core$macros.random.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.random.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args435.length)].join('')));\n\n}\n});\n\nquil.core$macros.random.cljs$core$IFn$_invoke$arity$1 = (function (max){\nreturn quil.sketch.current_applet.call(null).random(max);\n});\n\nquil.core$macros.random.cljs$core$IFn$_invoke$arity$2 = (function (min,max){\nreturn quil.sketch.current_applet.call(null).random(min,max);\n});\n\nquil.core$macros.random.cljs$lang$maxFixedArity = (2);\n/**\n * Returns a float from a random series of numbers having a mean of 0 and\n *   standard deviation of 1. Each time the randomGaussian() function is called,\n *   it returns a number fitting a Gaussian, or normal, distribution.\n *   There is theoretically no minimum or maximum value that randomGaussian()\n *   might return. Rather, there is just a very low probability that values far\n *   from the mean will be returned; and a higher probability that numbers near\n *   the mean will be returned. .\n */\nquil.core$macros.random_gaussian = (function quil$core$macros$random_gaussian(){\nreturn quil.sketch.current_applet.call(null).randomGaussian();\n});\n/**\n * Sets the seed value for random. By default, random produces\n *   different results each time the program is run. Set the value\n *   parameter to a constant to return the same pseudo-random numbers\n *   each time the software is run.\n */\nquil.core$macros.random_seed = (function quil$core$macros$random_seed(w){\nreturn quil.sketch.current_applet.call(null).randomSeed(w);\n});\n/**\n * Contains the value of the most recent key on the keyboard that was\n *   used (either pressed or released).\n * \n *   For non-ASCII keys, use the keyCode variable. The keys included in\n *   the ASCII specification (BACKSPACE, TAB, ENTER, RETURN, ESC, and\n *   DELETE) do not require checking to see if they key is coded, and you\n *   should simply use the key variable instead of keyCode If you're\n *   making cross-platform projects, note that the ENTER key is commonly\n *   used on PCs and Unix and the RETURN key is used instead on\n *   Macintosh. Check for both ENTER and RETURN to make sure your program\n *   will work for all platforms.\n */\nquil.core$macros.raw_key = (function quil$core$macros$raw_key(){\nreturn quil.sketch.current_applet.call(null).key;\n});\n/**\n * Draws a rectangle to the screen. A rectangle is a four-sided shape\n *   with every angle at ninety degrees. By default, the first two\n *   parameters set the location of the upper-left corner, the third\n *   sets the width, and the fourth sets the height. These parameters\n *   may be changed with rect-mode.\n * \n *   To draw a rounded rectangle, add a fifth parameter, which is used as\n *   the radius value for all four corners. To use a different radius value\n *   for each corner, include eight parameters.\n */\nquil.core$macros.rect = (function quil$core$macros$rect(var_args){\nvar args442 = [];\nvar len__11134__auto___445 = arguments.length;\nvar i__11135__auto___446 = (0);\nwhile(true){\nif((i__11135__auto___446 < len__11134__auto___445)){\nargs442.push((arguments[i__11135__auto___446]));\n\nvar G__447 = (i__11135__auto___446 + (1));\ni__11135__auto___446 = G__447;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__444 = args442.length;\nswitch (G__444) {\ncase (4):\nreturn quil.core$macros.rect.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (5):\nreturn quil.core$macros.rect.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ncase (8):\nreturn quil.core$macros.rect.cljs$core$IFn$_invoke$arity$8((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args442.length)].join('')));\n\n}\n});\n\nquil.core$macros.rect.cljs$core$IFn$_invoke$arity$4 = (function (x,y,width,height){\nreturn quil.core$macros.current_graphics.call(null).rect(x,y,width,height);\n});\n\nquil.core$macros.rect.cljs$core$IFn$_invoke$arity$5 = (function (x,y,width,height,r){\nreturn quil.core$macros.current_graphics.call(null).rect(x,y,width,height,r);\n});\n\nquil.core$macros.rect.cljs$core$IFn$_invoke$arity$8 = (function (x,y,width,height,top_left_r,top_right_r,bottom_right_r,bottom_left_r){\nreturn quil.core$macros.current_graphics.call(null).rect(x,y,width,height,top_left_r,top_right_r,bottom_right_r,bottom_left_r);\n});\n\nquil.core$macros.rect.cljs$lang$maxFixedArity = (8);\n/**\n * Modifies the location from which rectangles draw. The default mode\n *   is :corner. Available modes are:\n * \n * \n *   :corner  - Specifies the location to be the upper left corner of the\n *           shape and uses the third and fourth parameters of rect to\n *           specify the width and height.\n * \n *   :corners - Uses the first and second parameters of rect to set the\n *           location of one corner and uses the third and fourth\n *           parameters to set the opposite corner.\n * \n *   :center  - Draws the image from its center point and uses the third\n *           and forth parameters of rect to specify the image's width\n *           and height.\n * \n *   :radius  - Draws the image from its center point and uses the third\n *           and forth parameters of rect() to specify half of the\n *           image's width and height.\n */\nquil.core$macros.rect_mode = (function quil$core$macros$rect_mode(mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.rect_modes);\nreturn quil.core$macros.current_graphics.call(null).rectMode((mode__$1 | (0)));\n});\n/**\n * Extracts the red value from a color, scaled to match current color-mode.\n */\nquil.core$macros.red = (function quil$core$macros$red(c){\nreturn quil.core$macros.current_graphics.call(null).red(cljs.core.unchecked_int.call(null,c));\n});\n/**\n * Executes the code within the draw fn one time. This functions\n *   allows the program to update the display window only when necessary,\n *   for example when an event registered by mouse-pressed or\n *   key-pressed occurs.\n * \n *   In structuring a program, it only makes sense to call redraw\n *   within events such as mouse-pressed. This is because redraw does\n *   not run draw immediately (it only sets a flag that indicates an\n *   update is needed).\n * \n *   Calling redraw within draw has no effect because draw is\n *   continuously called anyway.\n */\nquil.core$macros.redraw = (function quil$core$macros$redraw(){\nreturn quil.sketch.current_applet.call(null).redraw();\n});\n/**\n * This function load images on a separate thread so that your sketch\n *   does not freeze while images load during setup. While the image is\n *   loading, its width and height will be 0. If an error occurs while\n *   loading the image, its width and height will be set to -1. You'll\n *   know when the image has loaded properly because its width and height\n *   will be greater than 0. Asynchronous image loading (particularly\n *   when downloading from a server) can dramatically improve\n *   performance.\n */\nquil.core$macros.request_image = (function quil$core$macros$request_image(filename){\nreturn quil.sketch.current_applet.call(null).requestImage([cljs.core.str(filename)].join(''));\n});\n/**\n * Replaces the current matrix with the identity matrix. The\n *   equivalent function in OpenGL is glLoadIdentity()\n */\nquil.core$macros.reset_matrix = (function quil$core$macros$reset_matrix(){\nreturn quil.core$macros.current_graphics.call(null).resetMatrix();\n});\n/**\n * Resize the image to a new width and height.\n *   To make the image scale proportionally, use 0 as the value for the wide or\n *   high parameter. For instance, to make the width of an image 150 pixels,\n *   and change the height using the same proportion, use resize(150, 0).\n * \n *   Even though a PGraphics is technically a PImage, it is not possible\n *   to rescale the image data found in a PGraphics.\n *   (It's simply not possible to do this consistently across renderers:\n *   technically infeasible with P3D, or what would it even do with PDF?)\n *   If you want to resize PGraphics content, first get a copy of its image data\n *   using the get() method, and call resize() on the PImage that is returned.\n */\nquil.core$macros.resize = (function quil$core$macros$resize(img,w,h){\nreturn img.resize(w,h);\n});\n/**\n * Rotates a shape the amount specified by the angle parameter. Angles\n *   should be specified in radians (values from 0 to TWO-PI) or\n *   converted to radians with the radians function.\n * \n *   Objects are always rotated around their relative position to the\n *   origin and positive numbers rotate objects in a clockwise\n *   direction. Transformations apply to everything that happens after\n *   and subsequent calls to the function accumulates the effect. For\n *   example, calling (rotate HALF-PI) and then (rotate HALF-PI) is the\n *   same as (rotate PI). All tranformations are reset when draw begins\n *   again.\n * \n *   Technically, rotate multiplies the current transformation matrix by\n *   a rotation matrix. This function can be further controlled by the\n *   push-matrix and pop-matrix.\n */\nquil.core$macros.rotate = (function quil$core$macros$rotate(var_args){\nvar args449 = [];\nvar len__11134__auto___452 = arguments.length;\nvar i__11135__auto___453 = (0);\nwhile(true){\nif((i__11135__auto___453 < len__11134__auto___452)){\nargs449.push((arguments[i__11135__auto___453]));\n\nvar G__454 = (i__11135__auto___453 + (1));\ni__11135__auto___453 = G__454;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__451 = args449.length;\nswitch (G__451) {\ncase (1):\nreturn quil.core$macros.rotate.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.rotate.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args449.length)].join('')));\n\n}\n});\n\nquil.core$macros.rotate.cljs$core$IFn$_invoke$arity$1 = (function (angle){\nreturn quil.core$macros.current_graphics.call(null).rotate(angle);\n});\n\nquil.core$macros.rotate.cljs$core$IFn$_invoke$arity$4 = (function (angle,vx,vy,vz){\nreturn quil.core$macros.current_graphics.call(null).rotate(angle,vx,vy,vz);\n});\n\nquil.core$macros.rotate.cljs$lang$maxFixedArity = (4);\n/**\n * Rotates a shape around the x-axis the amount specified by the angle\n *   parameter. Angles should be specified in radians (values from 0 to\n *   (* PI 2)) or converted to radians with the radians function. Objects\n *   are always rotated around their relative position to the origin and\n *   positive numbers rotate objects in a counterclockwise\n *   direction. Transformations apply to everything that happens after\n *   and subsequent calls to the function accumulates the effect. For\n *   example, calling (rotate-x HALF-PI) and then (rotate-x HALF-PI) is\n *   the same as (rotate-x PI). If rotate-x is called within the draw fn,\n *   the transformation is reset when the loop begins again. This\n *   function requires either the :p3d or :opengl renderer.\n */\nquil.core$macros.rotate_x = (function quil$core$macros$rotate_x(angle){\nreturn quil.core$macros.current_graphics.call(null).rotateX(angle);\n});\n/**\n * Rotates a shape around the y-axis the amount specified by the angle\n *   parameter. Angles should be specified in radians (values from 0\n *   to (* PI 2)) or converted to radians with the radians function.\n *   Objects are always rotated around their relative position to the\n *   origin and positive numbers rotate objects in a counterclockwise\n *   direction. Transformations apply to everything that happens after\n *   and subsequent calls to the function accumulates the effect. For\n *   example, calling (rotate-y HALF-PI) and then (rotate-y HALF-PI) is\n *   the same as (rotate-y PI). If rotate-y is called within the draw fn,\n *   the transformation is reset when the loop begins again. This\n *   function requires either the :p3d or :opengl renderer.\n */\nquil.core$macros.rotate_y = (function quil$core$macros$rotate_y(angle){\nreturn quil.core$macros.current_graphics.call(null).rotateY(angle);\n});\n/**\n * Rotates a shape around the z-axis the amount specified by the angle\n *   parameter. Angles should be specified in radians (values from 0\n *   to (* PI 2)) or converted to radians with the radians function.\n *   Objects are always rotated around their relative position to the\n *   origin and positive numbers rotate objects in a counterclockwise\n *   direction. Transformations apply to everything that happens after\n *   and subsequent calls to the function accumulates the effect. For\n *   example, calling (rotate-z HALF-PI) and then (rotate-z HALF-PI) is\n *   the same as (rotate-z PI). If rotate-y is called within the draw fn,\n *   the transformation is reset when the loop begins again. This\n *   function requires either the :p3d or :opengl renderer.\n */\nquil.core$macros.rotate_z = (function quil$core$macros$rotate_z(angle){\nreturn quil.core$macros.current_graphics.call(null).rotateZ(angle);\n});\n/**\n * Calculates the integer closest to the value parameter. For example,\n *   (round 9.2) returns the value 9.\n */\nquil.core$macros.round = (function quil$core$macros$round(val){\nreturn quil.sketch.current_applet.call(null).round(val);\n});\n/**\n * Extracts the saturation value from a color.\n */\nquil.core$macros.saturation = (function quil$core$macros$saturation(c){\nreturn quil.core$macros.current_graphics.call(null).saturation(cljs.core.unchecked_int.call(null,c));\n});\n/**\n * Saves an image from the display window. Images are saved in TIFF,\n *   TARGA, JPEG, and PNG format depending on the extension within the\n *   filename parameter. For example, image.tif will have a TIFF image\n *   and image.png will save a PNG image. If no extension is included in\n *   the filename, the image will save in TIFF format and .tif will be\n *   added to the name. All images saved from the main drawing window\n *   will be opaque. To save images without a background, use\n *   create-graphics.\n */\nquil.core$macros.save = (function quil$core$macros$save(filename){\nreturn quil.core$macros.current_graphics.call(null).save([cljs.core.str(filename)].join(''));\n});\n/**\n * Saves an image identical to the current display window as a\n *   file. May be called multple times - each file saved will have a\n *   unique name. Name and image formate may be modified by passing a\n *   string parameter of the form \"foo-####.ext\" where foo- can be any\n *   arbitrary string, #### will be replaced with the current frame id\n *   and .ext is one of .tiff, .targa, .png, .jpeg or .jpg\n * \n *   Examples:\n *   (save-frame)\n *   (save-frame \"pretty-pic-####.jpg\")\n */\nquil.core$macros.save_frame = (function quil$core$macros$save_frame(var_args){\nvar args456 = [];\nvar len__11134__auto___459 = arguments.length;\nvar i__11135__auto___460 = (0);\nwhile(true){\nif((i__11135__auto___460 < len__11134__auto___459)){\nargs456.push((arguments[i__11135__auto___460]));\n\nvar G__461 = (i__11135__auto___460 + (1));\ni__11135__auto___460 = G__461;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__458 = args456.length;\nswitch (G__458) {\ncase (0):\nreturn quil.core$macros.save_frame.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.save_frame.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args456.length)].join('')));\n\n}\n});\n\nquil.core$macros.save_frame.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.sketch.current_applet.call(null).saveFrame();\n});\n\nquil.core$macros.save_frame.cljs$core$IFn$_invoke$arity$1 = (function (name){\nreturn quil.sketch.current_applet.call(null).saveFrame([cljs.core.str(name)].join(''));\n});\n\nquil.core$macros.save_frame.cljs$lang$maxFixedArity = (1);\n/**\n * Increases or decreases the size of a shape by expanding and\n *   contracting vertices. Objects always scale from their relative\n *   origin to the coordinate system. Scale values are specified as\n *   decimal percentages. For example, the function call (scale 2)\n *   increases the dimension of a shape by 200%. Transformations apply to\n *   everything that happens after and subsequent calls to the function\n *   multiply the effect. For example, calling (scale 2) and then\n *   (scale 1.5) is the same as (scale 3). If scale is called within\n *   draw, the transformation is reset when the loop begins again. Using\n *   this fuction with the z parameter requires specfying :p3d or :opengl\n *   as the renderer. This function can be further controlled by\n *   push-matrix and pop-matrix.\n */\nquil.core$macros.scale = (function quil$core$macros$scale(var_args){\nvar args463 = [];\nvar len__11134__auto___466 = arguments.length;\nvar i__11135__auto___467 = (0);\nwhile(true){\nif((i__11135__auto___467 < len__11134__auto___466)){\nargs463.push((arguments[i__11135__auto___467]));\n\nvar G__468 = (i__11135__auto___467 + (1));\ni__11135__auto___467 = G__468;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__465 = args463.length;\nswitch (G__465) {\ncase (1):\nreturn quil.core$macros.scale.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.scale.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.scale.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args463.length)].join('')));\n\n}\n});\n\nquil.core$macros.scale.cljs$core$IFn$_invoke$arity$1 = (function (s){\nreturn quil.core$macros.current_graphics.call(null).scale(s);\n});\n\nquil.core$macros.scale.cljs$core$IFn$_invoke$arity$2 = (function (sx,sy){\nreturn quil.core$macros.current_graphics.call(null).scale(sx,sy);\n});\n\nquil.core$macros.scale.cljs$core$IFn$_invoke$arity$3 = (function (sx,sy,sz){\nreturn quil.core$macros.current_graphics.call(null).scale(sx,sy,sz);\n});\n\nquil.core$macros.scale.cljs$lang$maxFixedArity = (3);\n/**\n * Takes a three-dimensional x, y, z position and returns the x value\n *   for where it will appear on a (two-dimensional) screen, once\n *   affected by translate, scale or any other transformations\n */\nquil.core$macros.screen_x = (function quil$core$macros$screen_x(var_args){\nvar args470 = [];\nvar len__11134__auto___473 = arguments.length;\nvar i__11135__auto___474 = (0);\nwhile(true){\nif((i__11135__auto___474 < len__11134__auto___473)){\nargs470.push((arguments[i__11135__auto___474]));\n\nvar G__475 = (i__11135__auto___474 + (1));\ni__11135__auto___474 = G__475;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__472 = args470.length;\nswitch (G__472) {\ncase (2):\nreturn quil.core$macros.screen_x.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.screen_x.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args470.length)].join('')));\n\n}\n});\n\nquil.core$macros.screen_x.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.core$macros.current_graphics.call(null).screenX(x,y);\n});\n\nquil.core$macros.screen_x.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.current_graphics.call(null).screenX(x,y,z);\n});\n\nquil.core$macros.screen_x.cljs$lang$maxFixedArity = (3);\n/**\n * Takes a three-dimensional x, y, z position and returns the y value\n *   for where it will appear on a (two-dimensional) screen, once\n *   affected by translate, scale or any other transformations\n */\nquil.core$macros.screen_y = (function quil$core$macros$screen_y(var_args){\nvar args477 = [];\nvar len__11134__auto___480 = arguments.length;\nvar i__11135__auto___481 = (0);\nwhile(true){\nif((i__11135__auto___481 < len__11134__auto___480)){\nargs477.push((arguments[i__11135__auto___481]));\n\nvar G__482 = (i__11135__auto___481 + (1));\ni__11135__auto___481 = G__482;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__479 = args477.length;\nswitch (G__479) {\ncase (2):\nreturn quil.core$macros.screen_y.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.screen_y.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args477.length)].join('')));\n\n}\n});\n\nquil.core$macros.screen_y.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.core$macros.current_graphics.call(null).screenY(x,y);\n});\n\nquil.core$macros.screen_y.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.current_graphics.call(null).screenY(x,y,z);\n});\n\nquil.core$macros.screen_y.cljs$lang$maxFixedArity = (3);\n/**\n * Given an x, y, z coordinate, returns its z value.\n * This value can be used to determine if an x, y, z coordinate is in\n * front or in back of another (x, y, z) coordinate. The units are\n * based on how the zbuffer is set up, and don't relate to anything\n * 'real'. They're only useful for in comparison to another value\n * obtained from screen-z, or directly out of the zbuffer\n */\nquil.core$macros.screen_z = (function quil$core$macros$screen_z(x,y,z){\nreturn quil.core$macros.current_graphics.call(null).screenZ(x,y,z);\n});\n/**\n * Returns the current second as a value from 0 - 59.\n */\nquil.core$macros.seconds = (function quil$core$macros$seconds(){\nreturn quil.sketch.current_applet.call(null).second();\n});\n/**\n * Changes the color of any pixel in the display window. The x and y\n *   parameters specify the pixel to change and the color parameter\n *   specifies the color value. The color parameter is affected by the\n *   current color mode (the default is RGB values from 0 to 255).\n * \n *   Setting the color of a single pixel with (set x, y) is easy, but not\n *   as fast as putting the data directly into pixels[].\n * \n *   This function ignores imageMode().\n * \n *   Due to what appears to be a bug in Apple's Java implementation, the\n *   point() and set() methods are extremely slow in some circumstances\n *   when used with the default renderer. Using :p2d or :p3d will fix the\n *   problem. Grouping many calls to point or set-pixel together can also\n *   help. (Bug 1094)\n */\nquil.core$macros.set_pixel = (function quil$core$macros$set_pixel(var_args){\nvar args484 = [];\nvar len__11134__auto___487 = arguments.length;\nvar i__11135__auto___488 = (0);\nwhile(true){\nif((i__11135__auto___488 < len__11134__auto___487)){\nargs484.push((arguments[i__11135__auto___488]));\n\nvar G__489 = (i__11135__auto___488 + (1));\ni__11135__auto___488 = G__489;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__486 = args484.length;\nswitch (G__486) {\ncase (3):\nreturn quil.core$macros.set_pixel.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.set_pixel.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args484.length)].join('')));\n\n}\n});\n\nquil.core$macros.set_pixel.cljs$core$IFn$_invoke$arity$3 = (function (x,y,c){\nreturn quil.core$macros.set_pixel.call(null,quil.core$macros.current_graphics.call(null),x,y,c);\n});\n\nquil.core$macros.set_pixel.cljs$core$IFn$_invoke$arity$4 = (function (img,x,y,c){\nreturn img.set((x | (0)),(y | (0)),(c | (0)));\n});\n\nquil.core$macros.set_pixel.cljs$lang$maxFixedArity = (4);\n/**\n * Writes an image directly into the display window. The x and y\n *   parameters define the coordinates for the upper-left corner of the\n *   image.\n */\nquil.core$macros.set_image = (function quil$core$macros$set_image(x,y,src){\nreturn quil.core$macros.current_graphics.call(null).set((x | (0)),(y | (0)),src);\n});\n/**\n * Displays shapes to the screen. The shapes must have been loaded\n *   with load-shape. Processing currently works with SVG shapes\n *   only. The sh parameter specifies the shape to display and the x and\n *   y parameters define the location of the shape from its upper-left\n *   corner. The shape is displayed at its original size unless the width\n *   and height parameters specify a different size. The shape-mode\n *   fn changes the way the parameters work. A call to\n *   (shape-mode :corners), for example, will change the width and height\n *   parameters to define the x and y values of the opposite corner of\n *   the shape.\n * \n *   Note complex shapes may draw awkwardly with the renderers :p2d, :p3d, and\n *   :opengl. Those renderers do not yet support shapes that have holes\n *   or complicated breaks.\n */\nquil.core$macros.shape = (function quil$core$macros$shape(var_args){\nvar args491 = [];\nvar len__11134__auto___494 = arguments.length;\nvar i__11135__auto___495 = (0);\nwhile(true){\nif((i__11135__auto___495 < len__11134__auto___494)){\nargs491.push((arguments[i__11135__auto___495]));\n\nvar G__496 = (i__11135__auto___495 + (1));\ni__11135__auto___495 = G__496;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__493 = args491.length;\nswitch (G__493) {\ncase (1):\nreturn quil.core$macros.shape.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.shape.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (5):\nreturn quil.core$macros.shape.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args491.length)].join('')));\n\n}\n});\n\nquil.core$macros.shape.cljs$core$IFn$_invoke$arity$1 = (function (sh){\nreturn quil.core$macros.current_graphics.call(null).shape(sh);\n});\n\nquil.core$macros.shape.cljs$core$IFn$_invoke$arity$3 = (function (sh,x,y){\nreturn quil.core$macros.current_graphics.call(null).shape(sh,x,y);\n});\n\nquil.core$macros.shape.cljs$core$IFn$_invoke$arity$5 = (function (sh,x,y,width,height){\nreturn quil.core$macros.current_graphics.call(null).shape(sh,x,y,width,height);\n});\n\nquil.core$macros.shape.cljs$lang$maxFixedArity = (5);\n/**\n * Shears a shape around the x-axis the amount specified by the angle\n *   parameter. Angles should be specified in radians (values from 0 to\n *   PI*2) or converted to radians with the radians() function. Objects\n *   are always sheared around their relative position to the origin and\n *   positive numbers shear objects in a clockwise direction.\n *   Transformations apply to everything that happens after and\n *   subsequent calls to the function accumulates the effect. For\n *   example, calling (shear-x (/ PI 2)) and then (shear-x (/ PI 2)) is\n *   the same as (shear-x PI). If shear-x is called within the draw fn,\n *   the transformation is reset when the loop begins again. This\n *   function works in P2D or JAVA2D mode.\n * \n *   Technically, shear-x multiplies the current transformation matrix\n *   by a rotation matrix. This function can be further controlled by the\n *   push-matrix and pop-matrix fns.\n */\nquil.core$macros.shear_x = (function quil$core$macros$shear_x(angle){\nreturn quil.core$macros.current_graphics.call(null).shearX(angle);\n});\n/**\n * Shears a shape around the y-axis the amount specified by the angle\n *   parameter. Angles should be specified in radians (values from 0 to\n *   PI*2) or converted to radians with the radians() function. Objects\n *   are always sheared around their relative position to the origin and\n *   positive numbers shear objects in a clockwise direction.\n *   Transformations apply to everything that happens after and\n *   subsequent calls to the function accumulates the effect. For\n *   example, calling (shear-y (/ PI 2)) and then (shear-y (/ PI 2)) is\n *   the same as (shear-y PI). If shear-y is called within the draw fn,\n *   the transformation is reset when the loop begins again. This\n *   function works in P2D or JAVA2D mode.\n * \n *   Technically, shear-y multiplies the current transformation matrix\n *   by a rotation matrix. This function can be further controlled by the\n *   push-matrix and pop-matrix fns.\n */\nquil.core$macros.shear_y = (function quil$core$macros$shear_y(angle){\nreturn quil.core$macros.current_graphics.call(null).shearY(angle);\n});\n/**\n * Modifies the location from which shapes draw. Available modes are\n *   :corner, :corners and :center. Default is :corner.\n * \n *   :corner  - specifies the location to be the upper left corner of the\n *           shape and uses the third and fourth parameters of shape\n *           to specify the width and height.\n * \n *   :corners - uses the first and second parameters of shape to set\n *           the location of one corner and uses the third and fourth\n *           parameters to set the opposite corner.\n * \n *   :center  - draws the shape from its center point and uses the third\n *           and forth parameters of shape to specify the width and\n *           height. \n */\nquil.core$macros.shape_mode = (function quil$core$macros$shape_mode(mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.p_shape_modes);\nreturn quil.core$macros.current_graphics.call(null).shapeMode((mode__$1 | (0)));\n});\n/**\n * Sets the amount of gloss in the surface of shapes. Used in\n *   combination with ambient, specular, and emissive in setting\n *   the material properties of shapes.\n */\nquil.core$macros.shininess = (function quil$core$macros$shininess(shine){\nreturn quil.core$macros.current_graphics.call(null).shininess(shine);\n});\n/**\n * Calculates the sine of an angle. This function expects the values\n *   of the angle parameter to be provided in radians (values from 0 to\n *   6.28). A float within the range -1 to 1 is returned.\n */\nquil.core$macros.sin = (function quil$core$macros$sin(angle){\nreturn quil.sketch.current_applet.call(null).sin(angle);\n});\n/**\n * Draws all geometry with smooth (anti-aliased) edges. This will slow\n *   down the frame rate of the application, but will enhance the visual\n *   refinement.\n * \n *   Must be called inside :settings handler.\n * \n *   The level parameter (int) increases the level of smoothness with the\n *   P2D and P3D renderers. This is the level of over sampling applied to\n *   the graphics buffer. The value '2' will double the rendering size\n *   before scaling it down to the display size. This is called '2x\n *   anti-aliasing.' The value 4 is used for 4x anti-aliasing and 8 is\n *   specified for 8x anti-aliasing. If level is set to 0, it will disable\n *   all smoothing; it's the equivalent of the function noSmooth().\n *   The maximum anti-aliasing level is determined by the hardware of the\n *   machine that is running the software.\n * \n *   Note that smooth will also improve image quality of resized images.\n */\nquil.core$macros.smooth = (function quil$core$macros$smooth(var_args){\nvar args498 = [];\nvar len__11134__auto___501 = arguments.length;\nvar i__11135__auto___502 = (0);\nwhile(true){\nif((i__11135__auto___502 < len__11134__auto___501)){\nargs498.push((arguments[i__11135__auto___502]));\n\nvar G__503 = (i__11135__auto___502 + (1));\ni__11135__auto___502 = G__503;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__500 = args498.length;\nswitch (G__500) {\ncase (0):\nreturn quil.core$macros.smooth.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.smooth.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args498.length)].join('')));\n\n}\n});\n\nquil.core$macros.smooth.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.current_graphics.call(null).smooth();\n});\n\nquil.core$macros.smooth.cljs$core$IFn$_invoke$arity$1 = (function (level){\nreturn quil.core$macros.current_graphics.call(null).smooth((level | (0)));\n});\n\nquil.core$macros.smooth.cljs$lang$maxFixedArity = (1);\n/**\n * Sets the specular color of the materials used for shapes drawn to\n *   the screen, which sets the color of hightlights. Specular refers to\n *   light which bounces off a surface in a perferred direction (rather\n *   than bouncing in all directions like a diffuse light). Used in\n *   combination with emissive, ambient, and shininess in setting\n *   the material properties of shapes.\n */\nquil.core$macros.specular = (function quil$core$macros$specular(var_args){\nvar args505 = [];\nvar len__11134__auto___508 = arguments.length;\nvar i__11135__auto___509 = (0);\nwhile(true){\nif((i__11135__auto___509 < len__11134__auto___508)){\nargs505.push((arguments[i__11135__auto___509]));\n\nvar G__510 = (i__11135__auto___509 + (1));\ni__11135__auto___509 = G__510;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__507 = args505.length;\nswitch (G__507) {\ncase (1):\nreturn quil.core$macros.specular.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.specular.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args505.length)].join('')));\n\n}\n});\n\nquil.core$macros.specular.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nreturn quil.core$macros.current_graphics.call(null).specular(gray);\n});\n\nquil.core$macros.specular.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.current_graphics.call(null).specular(x,y,z);\n});\n\nquil.core$macros.specular.cljs$lang$maxFixedArity = (3);\n/**\n * Generates a hollow ball made from tessellated triangles.\n */\nquil.core$macros.sphere = (function quil$core$macros$sphere(radius){\nreturn quil.core$macros.current_graphics.call(null).sphere(radius);\n});\n/**\n * Controls the detail used to render a sphere by adjusting the number\n *   of vertices of the sphere mesh. The default resolution is 30, which\n *   creates a fairly detailed sphere definition with vertices every\n *   360/30 = 12 degrees. If you're going to render a great number of\n *   spheres per frame, it is advised to reduce the level of detail using\n *   this function. The setting stays active until sphere-detail is\n *   called again with a new parameter and so should not be called prior\n *   to every sphere statement, unless you wish to render spheres with\n *   different settings, e.g. using less detail for smaller spheres or\n *   ones further away from the camera. To controla the detail of the\n *   horizontal and vertical resolution independently, use the version of\n *   the functions with two parameters.\n */\nquil.core$macros.sphere_detail = (function quil$core$macros$sphere_detail(var_args){\nvar args512 = [];\nvar len__11134__auto___515 = arguments.length;\nvar i__11135__auto___516 = (0);\nwhile(true){\nif((i__11135__auto___516 < len__11134__auto___515)){\nargs512.push((arguments[i__11135__auto___516]));\n\nvar G__517 = (i__11135__auto___516 + (1));\ni__11135__auto___516 = G__517;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__514 = args512.length;\nswitch (G__514) {\ncase (1):\nreturn quil.core$macros.sphere_detail.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.sphere_detail.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args512.length)].join('')));\n\n}\n});\n\nquil.core$macros.sphere_detail.cljs$core$IFn$_invoke$arity$1 = (function (res){\nreturn quil.core$macros.current_graphics.call(null).sphereDetail((res | (0)));\n});\n\nquil.core$macros.sphere_detail.cljs$core$IFn$_invoke$arity$2 = (function (ures,vres){\nreturn quil.core$macros.current_graphics.call(null).sphereDetail((ures | (0)),(vres | (0)));\n});\n\nquil.core$macros.sphere_detail.cljs$lang$maxFixedArity = (2);\n/**\n * Adds a spot light. Lights need to be included in the draw to\n *   remain persistent in a looping program. Placing them in the setup\n *   of a looping program will cause them to only have an effect the\n *   first time through the loop. The affect of the r, g, and b\n *   parameters is determined by the current color mode. The x, y, and z\n *   parameters specify the position of the light and nx, ny, nz specify\n *   the direction or light. The angle parameter affects angle of the\n *   spotlight cone.\n */\nquil.core$macros.spot_light = (function quil$core$macros$spot_light(var_args){\nvar args519 = [];\nvar len__11134__auto___528 = arguments.length;\nvar i__11135__auto___529 = (0);\nwhile(true){\nif((i__11135__auto___529 < len__11134__auto___528)){\nargs519.push((arguments[i__11135__auto___529]));\n\nvar G__530 = (i__11135__auto___529 + (1));\ni__11135__auto___529 = G__530;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__521 = args519.length;\nswitch (G__521) {\ncase (11):\nreturn quil.core$macros.spot_light.cljs$core$IFn$_invoke$arity$11((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]));\n\nbreak;\ncase (5):\nreturn quil.core$macros.spot_light.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args519.length)].join('')));\n\n}\n});\n\nquil.core$macros.spot_light.cljs$core$IFn$_invoke$arity$11 = (function (r,g,b,x,y,z,nx,ny,nz,angle,concentration){\nreturn quil.core$macros.current_graphics.call(null).spotLight(r,g,b,x,y,z,nx,ny,nz,angle,concentration);\n});\n\nquil.core$macros.spot_light.cljs$core$IFn$_invoke$arity$5 = (function (p__522,p__523,p__524,angle,concentration){\nvar vec__525 = p__522;\nvar r = cljs.core.nth.call(null,vec__525,(0),null);\nvar g = cljs.core.nth.call(null,vec__525,(1),null);\nvar b = cljs.core.nth.call(null,vec__525,(2),null);\nvar vec__526 = p__523;\nvar x = cljs.core.nth.call(null,vec__526,(0),null);\nvar y = cljs.core.nth.call(null,vec__526,(1),null);\nvar z = cljs.core.nth.call(null,vec__526,(2),null);\nvar vec__527 = p__524;\nvar nx = cljs.core.nth.call(null,vec__527,(0),null);\nvar ny = cljs.core.nth.call(null,vec__527,(1),null);\nvar nz = cljs.core.nth.call(null,vec__527,(2),null);\nreturn quil.core$macros.current_graphics.call(null).spotLight(r,g,b,x,y,z,nx,ny,nz,angle,concentration);\n});\n\nquil.core$macros.spot_light.cljs$lang$maxFixedArity = (11);\n/**\n * Squares a number (multiplies a number by itself). The result is\n *   always a positive number, as multiplying two negative numbers always\n *   yields a positive result. For example, -1 * -1 = 1.\n */\nquil.core$macros.sq = (function quil$core$macros$sq(a){\nreturn quil.sketch.current_applet.call(null).sq(a);\n});\n/**\n * Calculates the square root of a number. The square root of a number\n *   is always positive, even though there may be a valid negative\n *   root. The square root s of number a is such that (= a (* s s)) . It\n *   is the opposite of squaring.\n */\nquil.core$macros.sqrt = (function quil$core$macros$sqrt(a){\nreturn quil.sketch.current_applet.call(null).sqrt(a);\n});\n/**\n * Causes Processing to continuously execute the code within\n *   draw. If no-loop is called, the code in draw stops executing.\n */\nquil.core$macros.start_loop = (function quil$core$macros$start_loop(){\nreturn quil.sketch.current_applet.call(null).loop();\n});\n/**\n * Sets the color used to draw lines and borders around\n *   shapes. Converts all args to floats\n */\nquil.core$macros.stroke_float = (function quil$core$macros$stroke_float(var_args){\nvar args532 = [];\nvar len__11134__auto___535 = arguments.length;\nvar i__11135__auto___536 = (0);\nwhile(true){\nif((i__11135__auto___536 < len__11134__auto___535)){\nargs532.push((arguments[i__11135__auto___536]));\n\nvar G__537 = (i__11135__auto___536 + (1));\ni__11135__auto___536 = G__537;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__534 = args532.length;\nswitch (G__534) {\ncase (1):\nreturn quil.core$macros.stroke_float.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.stroke_float.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.stroke_float.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.stroke_float.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args532.length)].join('')));\n\n}\n});\n\nquil.core$macros.stroke_float.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nreturn quil.core$macros.current_graphics.call(null).stroke(gray);\n});\n\nquil.core$macros.stroke_float.cljs$core$IFn$_invoke$arity$2 = (function (gray,alpha){\nreturn quil.core$macros.current_graphics.call(null).stroke(gray,alpha);\n});\n\nquil.core$macros.stroke_float.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.current_graphics.call(null).stroke(x,y,z);\n});\n\nquil.core$macros.stroke_float.cljs$core$IFn$_invoke$arity$4 = (function (x,y,z,a){\nreturn quil.core$macros.current_graphics.call(null).stroke(x,y,z,a);\n});\n\nquil.core$macros.stroke_float.cljs$lang$maxFixedArity = (4);\n/**\n * Sets the color used to draw lines and borders around\n *   shapes. Converts rgb to int and alpha to a float.\n */\nquil.core$macros.stroke_int = (function quil$core$macros$stroke_int(var_args){\nvar args539 = [];\nvar len__11134__auto___542 = arguments.length;\nvar i__11135__auto___543 = (0);\nwhile(true){\nif((i__11135__auto___543 < len__11134__auto___542)){\nargs539.push((arguments[i__11135__auto___543]));\n\nvar G__544 = (i__11135__auto___543 + (1));\ni__11135__auto___543 = G__544;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__541 = args539.length;\nswitch (G__541) {\ncase (1):\nreturn quil.core$macros.stroke_int.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.stroke_int.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args539.length)].join('')));\n\n}\n});\n\nquil.core$macros.stroke_int.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core$macros.current_graphics.call(null).stroke(cljs.core.unchecked_int.call(null,rgb));\n});\n\nquil.core$macros.stroke_int.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core$macros.current_graphics.call(null).stroke(cljs.core.unchecked_int.call(null,rgb),alpha);\n});\n\nquil.core$macros.stroke_int.cljs$lang$maxFixedArity = (2);\n/**\n * Sets the color used to draw lines and borders around shapes. This\n *   color is either specified in terms of the RGB or HSB color depending\n *   on the current color-mode (the default color space is RGB, with\n *   each value in the range from 0 to 255).\n */\nquil.core$macros.stroke = (function quil$core$macros$stroke(var_args){\nvar args546 = [];\nvar len__11134__auto___549 = arguments.length;\nvar i__11135__auto___550 = (0);\nwhile(true){\nif((i__11135__auto___550 < len__11134__auto___549)){\nargs546.push((arguments[i__11135__auto___550]));\n\nvar G__551 = (i__11135__auto___550 + (1));\ni__11135__auto___550 = G__551;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__548 = args546.length;\nswitch (G__548) {\ncase (1):\nreturn quil.core$macros.stroke.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.stroke.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.stroke.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.stroke.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args546.length)].join('')));\n\n}\n});\n\nquil.core$macros.stroke.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core$macros.stroke_float.call(null,rgb);\n});\n\nquil.core$macros.stroke.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core$macros.stroke_float.call(null,rgb,alpha);\n});\n\nquil.core$macros.stroke.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.stroke_float.call(null,x,y,z);\n});\n\nquil.core$macros.stroke.cljs$core$IFn$_invoke$arity$4 = (function (x,y,z,a){\nreturn quil.core$macros.stroke_float.call(null,x,y,z,a);\n});\n\nquil.core$macros.stroke.cljs$lang$maxFixedArity = (4);\n/**\n * Sets the style for rendering line endings. These ends are either\n *   squared, extended, or rounded and specified with the corresponding\n *   parameters :square, :project, and :round. The default cap is :round.\n */\nquil.core$macros.stroke_cap = (function quil$core$macros$stroke_cap(cap_mode){\nvar cap_mode__$1 = quil.util.resolve_constant_key.call(null,cap_mode,quil.core$macros.stroke_cap_modes);\nreturn quil.core$macros.current_graphics.call(null).strokeCap([cljs.core.str(cap_mode__$1)].join(''));\n});\n/**\n * Sets the style of the joints which connect line\n *   segments. These joints are either mitered, beveled, or rounded and\n *   specified with the corresponding parameters :miter, :bevel, and\n *   :round. The default joint is :miter.\n * \n *   This function is not available with the :p2d, :p3d, or :opengl\n *   renderers.\n */\nquil.core$macros.stroke_join = (function quil$core$macros$stroke_join(join_mode){\nvar join_mode__$1 = quil.util.resolve_constant_key.call(null,join_mode,quil.core$macros.stroke_join_modes);\nreturn quil.core$macros.current_graphics.call(null).strokeJoin([cljs.core.str(join_mode__$1)].join(''));\n});\n/**\n * Sets the width of the stroke used for lines, points, and the border\n *   around shapes. All widths are set in units of pixels. \n */\nquil.core$macros.stroke_weight = (function quil$core$macros$stroke_weight(weight){\nreturn quil.core$macros.current_graphics.call(null).strokeWeight(weight);\n});\n/**\n * Calculates the ratio of the sine and cosine of an angle. This\n *   function expects the values of the angle parameter to be provided in\n *   radians (values from 0 to PI*2). Values are returned in the range\n *   infinity to -infinity.\n */\nquil.core$macros.tan = (function quil$core$macros$tan(angle){\nreturn quil.sketch.current_applet.call(null).tan(angle);\n});\n/**\n * Returns the target framerate specified with the fn frame-rate\n */\nquil.core$macros.target_frame_rate = (function quil$core$macros$target_frame_rate(){\nreturn cljs.core.deref.call(null,quil.sketch.current_applet.call(null).target_frame_rate);\n});\n/**\n * Returns whether fill is disabled for current graphics.\n */\nquil.core$macros.no_fill_QMARK_ = (function quil$core$macros$no_fill_QMARK_(graphics){\nreturn (graphics[quil.core$macros.no_fill_prop]) === true;\n});\n/**\n * Draws a char to the screen in the specified position. See text fn\n *   for more details.\n */\nquil.core$macros.text_char = (function quil$core$macros$text_char(var_args){\nvar args553 = [];\nvar len__11134__auto___556 = arguments.length;\nvar i__11135__auto___557 = (0);\nwhile(true){\nif((i__11135__auto___557 < len__11134__auto___556)){\nargs553.push((arguments[i__11135__auto___557]));\n\nvar G__558 = (i__11135__auto___557 + (1));\ni__11135__auto___557 = G__558;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__555 = args553.length;\nswitch (G__555) {\ncase (3):\nreturn quil.core$macros.text_char.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.text_char.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args553.length)].join('')));\n\n}\n});\n\nquil.core$macros.text_char.cljs$core$IFn$_invoke$arity$3 = (function (c,x,y){\nif(cljs.core.truth_(quil.core$macros.no_fill_QMARK_.call(null,quil.core$macros.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core$macros.current_graphics.call(null).text(cljs.core.char$.call(null,c),x,y);\n}\n});\n\nquil.core$macros.text_char.cljs$core$IFn$_invoke$arity$4 = (function (c,x,y,z){\nif(cljs.core.truth_(quil.core$macros.no_fill_QMARK_.call(null,quil.core$macros.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core$macros.current_graphics.call(null).text(cljs.core.char$.call(null,c),x,y,z);\n}\n});\n\nquil.core$macros.text_char.cljs$lang$maxFixedArity = (4);\n/**\n * Draws a number to the screen in the specified position. See text fn\n *   for more details.\n */\nquil.core$macros.text_num = (function quil$core$macros$text_num(var_args){\nvar args560 = [];\nvar len__11134__auto___563 = arguments.length;\nvar i__11135__auto___564 = (0);\nwhile(true){\nif((i__11135__auto___564 < len__11134__auto___563)){\nargs560.push((arguments[i__11135__auto___564]));\n\nvar G__565 = (i__11135__auto___564 + (1));\ni__11135__auto___564 = G__565;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__562 = args560.length;\nswitch (G__562) {\ncase (3):\nreturn quil.core$macros.text_num.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.text_num.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args560.length)].join('')));\n\n}\n});\n\nquil.core$macros.text_num.cljs$core$IFn$_invoke$arity$3 = (function (num,x,y){\nif(cljs.core.truth_(quil.core$macros.no_fill_QMARK_.call(null,quil.core$macros.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core$macros.current_graphics.call(null).text(num,x,y);\n}\n});\n\nquil.core$macros.text_num.cljs$core$IFn$_invoke$arity$4 = (function (num,x,y,z){\nif(cljs.core.truth_(quil.core$macros.no_fill_QMARK_.call(null,quil.core$macros.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core$macros.current_graphics.call(null).text(num,x,y,z);\n}\n});\n\nquil.core$macros.text_num.cljs$lang$maxFixedArity = (4);\n/**\n * Draws text to the screen in the position specified by the x and y\n *   parameters and the optional z parameter. A default font will be used\n *   unless a font is set with the text-font fn. Change the color of the\n *   text with the fill fn. The text displays in relation to the\n *   text-align fn, which gives the option to draw to the left, right, and\n *   center of the coordinates.\n * \n *   The x1, y1, x2 and y2 parameters define a\n *   rectangular area to display within and may only be used with string\n *   data. For text drawn inside a rectangle, the coordinates are\n *   interpreted based on the current rect-mode setting.\n */\nquil.core$macros.text = (function quil$core$macros$text(var_args){\nvar args567 = [];\nvar len__11134__auto___570 = arguments.length;\nvar i__11135__auto___571 = (0);\nwhile(true){\nif((i__11135__auto___571 < len__11134__auto___570)){\nargs567.push((arguments[i__11135__auto___571]));\n\nvar G__572 = (i__11135__auto___571 + (1));\ni__11135__auto___571 = G__572;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__569 = args567.length;\nswitch (G__569) {\ncase (3):\nreturn quil.core$macros.text.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.text.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (5):\nreturn quil.core$macros.text.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args567.length)].join('')));\n\n}\n});\n\nquil.core$macros.text.cljs$core$IFn$_invoke$arity$3 = (function (s,x,y){\nif(cljs.core.truth_(quil.core$macros.no_fill_QMARK_.call(null,quil.core$macros.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core$macros.current_graphics.call(null).text(s,x,y);\n}\n});\n\nquil.core$macros.text.cljs$core$IFn$_invoke$arity$4 = (function (s,x,y,z){\nif(cljs.core.truth_(quil.core$macros.no_fill_QMARK_.call(null,quil.core$macros.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core$macros.current_graphics.call(null).text(s,x,y,z);\n}\n});\n\nquil.core$macros.text.cljs$core$IFn$_invoke$arity$5 = (function (s,x1,y1,x2,y2){\nif(cljs.core.truth_(quil.core$macros.no_fill_QMARK_.call(null,quil.core$macros.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core$macros.current_graphics.call(null).text(s,x1,y1,x2,y2);\n}\n});\n\nquil.core$macros.text.cljs$lang$maxFixedArity = (5);\n/**\n * Sets the current alignment for drawing text. Available modes are:\n * \n *   horizontal - :left, :center, and :right\n *   vertical   - :top, :bottom, :center, and :baseline\n * \n *   An optional second parameter specifies the vertical alignment\n *   mode. :baseline is the default. The :top and :center parameters are\n *   straightforward. The :bottom parameter offsets the line based on the\n *   current text-descent. For multiple lines, the final line will be\n *   aligned to the bottom, with the previous lines appearing above it.\n * \n *   When using text with width and height parameters, :baseline is\n *   ignored, and treated as :top. (Otherwise, text would by default draw\n *   outside the box, since :baseline is the default setting. :baseline is\n *   not a useful drawing mode for text drawn in a rectangle.)\n * \n *   The vertical alignment is based on the value of text-ascent, which\n *   many fonts do not specify correctly. It may be necessary to use a\n *   hack and offset by a few pixels by hand so that the offset looks\n *   correct. To do this as less of a hack, use some percentage of\n *   text-ascent or text-descent so that the hack works even if you\n *   change the size of the font.\n */\nquil.core$macros.text_align = (function quil$core$macros$text_align(var_args){\nvar args574 = [];\nvar len__11134__auto___577 = arguments.length;\nvar i__11135__auto___578 = (0);\nwhile(true){\nif((i__11135__auto___578 < len__11134__auto___577)){\nargs574.push((arguments[i__11135__auto___578]));\n\nvar G__579 = (i__11135__auto___578 + (1));\ni__11135__auto___578 = G__579;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__576 = args574.length;\nswitch (G__576) {\ncase (1):\nreturn quil.core$macros.text_align.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.text_align.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args574.length)].join('')));\n\n}\n});\n\nquil.core$macros.text_align.cljs$core$IFn$_invoke$arity$1 = (function (align){\nvar align__$1 = quil.util.resolve_constant_key.call(null,align,quil.core$macros.horizontal_alignment_modes);\nreturn quil.core$macros.current_graphics.call(null).textAlign((align__$1 | (0)));\n});\n\nquil.core$macros.text_align.cljs$core$IFn$_invoke$arity$2 = (function (align_x,align_y){\nvar align_x__$1 = quil.util.resolve_constant_key.call(null,align_x,quil.core$macros.horizontal_alignment_modes);\nvar align_y__$1 = quil.util.resolve_constant_key.call(null,align_y,quil.core$macros.vertical_alignment_modes);\nreturn quil.core$macros.current_graphics.call(null).textAlign((align_x__$1 | (0)),(align_y__$1 | (0)));\n});\n\nquil.core$macros.text_align.cljs$lang$maxFixedArity = (2);\n/**\n * Returns the ascent of the current font at its current size. This\n *   information is useful for determining the height of the font above\n *   the baseline. For example, adding the text-ascent and text-descent\n *   values will give you the total height of the line.\n */\nquil.core$macros.text_ascent = (function quil$core$macros$text_ascent(){\nreturn quil.core$macros.current_graphics.call(null).textAscent();\n});\n/**\n * Returns descent of the current font at its current size. This\n *   information is useful for determining the height of the font below\n *   the baseline. For example, adding the text-ascent and text-descent\n *   values will give you the total height of the line.\n */\nquil.core$macros.text_descent = (function quil$core$macros$text_descent(){\nreturn quil.core$macros.current_graphics.call(null).textDescent();\n});\n/**\n * Sets the current font that will be drawn with the text\n *   function. Fonts must be loaded with load-font before it can be\n *   used. This font will be used in all subsequent calls to the text\n *   function. If no size parameter is input, the font will appear at its\n *   original size until it is changed with text-size.\n * \n *   Because fonts are usually bitmaped, you should create fonts at the\n *   sizes that will be used most commonly. Using textFont without the\n *   size parameter will result in the cleanest-looking text.\n * \n *   With the default (JAVA2D) and PDF renderers, it's also possible to\n *   enable the use of native fonts via the command\n *   (hint :enable-native-fonts). This will produce vector text in JAVA2D\n *   sketches and PDF output in cases where the vector data is available:\n *   when the font is still installed, or the font is created via the\n *   create-font fn\n */\nquil.core$macros.text_font = (function quil$core$macros$text_font(var_args){\nvar args581 = [];\nvar len__11134__auto___584 = arguments.length;\nvar i__11135__auto___585 = (0);\nwhile(true){\nif((i__11135__auto___585 < len__11134__auto___584)){\nargs581.push((arguments[i__11135__auto___585]));\n\nvar G__586 = (i__11135__auto___585 + (1));\ni__11135__auto___585 = G__586;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__583 = args581.length;\nswitch (G__583) {\ncase (1):\nreturn quil.core$macros.text_font.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.text_font.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args581.length)].join('')));\n\n}\n});\n\nquil.core$macros.text_font.cljs$core$IFn$_invoke$arity$1 = (function (font){\nreturn quil.core$macros.current_graphics.call(null).textFont(font);\n});\n\nquil.core$macros.text_font.cljs$core$IFn$_invoke$arity$2 = (function (font,size){\nreturn quil.core$macros.current_graphics.call(null).textFont(font,(size | (0)));\n});\n\nquil.core$macros.text_font.cljs$lang$maxFixedArity = (2);\n/**\n * Sets the spacing between lines of text in units of pixels. This\n *   setting will be used in all subsequent calls to the text function.\n */\nquil.core$macros.text_leading = (function quil$core$macros$text_leading(leading){\nreturn quil.core$macros.current_graphics.call(null).textLeading(leading);\n});\n/**\n * Sets the way text draws to the screen - available modes\n *   are :model and :shape\n * \n *   In the default configuration (the :model mode), it's possible to\n *   rotate, scale, and place letters in two and three dimensional space.\n * \n *   The :shape mode draws text using the glyph outlines of individual\n *   characters rather than as textures. This mode is only supported with\n *   the PDF and OPENGL renderer settings. With the PDF renderer, you\n *   must specify the :shape text-mode before any other drawing occurs.\n *   If the outlines are not available, then :shape will be ignored and\n *   :model will be used instead.\n * \n *   The :shape option in OPENGL mode can be combined with begin-raw to\n *   write vector-accurate text to 2D and 3D output files, for instance\n *   DXF or PDF. :shape is not currently optimized for OPENGL, so if\n *   recording shape data, use :model until you're ready to capture the\n *   geometry with begin-raw.\n */\nquil.core$macros.text_mode = (function quil$core$macros$text_mode(mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.text_modes);\nreturn quil.core$macros.current_graphics.call(null).textMode((mode__$1 | (0)));\n});\n/**\n * Sets the current font size. This size will be used in all\n *   subsequent calls to the text fn. Font size is measured in\n *   units of pixels.\n */\nquil.core$macros.text_size = (function quil$core$macros$text_size(size){\nreturn quil.core$macros.current_graphics.call(null).textSize(size);\n});\n/**\n * Sets a texture to be applied to vertex points. The texture fn must\n *   be called between begin-shape and end-shape and before any calls to\n *   vertex.\n * \n *   When textures are in use, the fill color is ignored. Instead, use\n *   tint to specify the color of the texture as it is applied to the\n *   shape.\n */\nquil.core$macros.texture = (function quil$core$macros$texture(img){\nreturn quil.core$macros.current_graphics.call(null).texture(img);\n});\n/**\n * Sets the coordinate space for texture mapping. There are two\n *   options, :image and :normal.\n * \n *   :image refers to the actual coordinates of the image and :normal\n *   refers to a normalized space of values ranging from 0 to 1. The\n *   default mode is :image. In :image, if an image is 100 x 200 pixels,\n *   mapping the image onto the entire size of a quad would require the\n *   points (0,0) (0,100) (100,200) (0,200). The same mapping in\n *   NORMAL_SPACE is (0,0) (0,1) (1,1) (0,1).\n */\nquil.core$macros.texture_mode = (function quil$core$macros$texture_mode(mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.texture_modes);\nreturn quil.core$macros.current_graphics.call(null).textureMode((mode__$1 | (0)));\n});\n/**\n * Calculates and returns the width of any text string.\n */\nquil.core$macros.text_width = (function quil$core$macros$text_width(data){\nreturn quil.core$macros.current_graphics.call(null).textWidth(data);\n});\n/**\n * Sets the fill value for displaying images. Images can be tinted to\n *   specified colors or made transparent by setting the alpha.\n * \n *   To make an image transparent, but not change it's color, use white\n *   as the tint color and specify an alpha value. For instance,\n *   tint(255, 128) will make an image 50% transparent (unless\n *   colorMode() has been used).\n * \n *   The value for the parameter gray must be less than or equal to the\n *   current maximum value as specified by colorMode(). The default\n *   maximum value is 255.\n * \n *   Also used to control the coloring of textures in 3D.\n */\nquil.core$macros.tint_float = (function quil$core$macros$tint_float(var_args){\nvar args588 = [];\nvar len__11134__auto___591 = arguments.length;\nvar i__11135__auto___592 = (0);\nwhile(true){\nif((i__11135__auto___592 < len__11134__auto___591)){\nargs588.push((arguments[i__11135__auto___592]));\n\nvar G__593 = (i__11135__auto___592 + (1));\ni__11135__auto___592 = G__593;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__590 = args588.length;\nswitch (G__590) {\ncase (1):\nreturn quil.core$macros.tint_float.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.tint_float.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.tint_float.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.tint_float.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args588.length)].join('')));\n\n}\n});\n\nquil.core$macros.tint_float.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nreturn quil.core$macros.current_graphics.call(null).tint(gray);\n});\n\nquil.core$macros.tint_float.cljs$core$IFn$_invoke$arity$2 = (function (gray,alpha){\nreturn quil.core$macros.current_graphics.call(null).tint(gray,alpha);\n});\n\nquil.core$macros.tint_float.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core$macros.current_graphics.call(null).tint(r,g,b);\n});\n\nquil.core$macros.tint_float.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,a){\nreturn quil.core$macros.current_graphics.call(null).tint(g,g,b,a);\n});\n\nquil.core$macros.tint_float.cljs$lang$maxFixedArity = (4);\n/**\n * Sets the fill value for displaying images. Images can be tinted to\n *   specified colors or made transparent by setting the alpha.\n * \n *   To make an image transparent, but not change it's color, use white\n *   as the tint color and specify an alpha value. For instance,\n *   tint(255, 128) will make an image 50% transparent (unless\n *   colorMode() has been used).\n * \n *   The value for the parameter gray must be less than or equal to the\n *   current maximum value as specified by colorMode(). The default\n *   maximum value is 255.\n * \n *   Also used to control the coloring of textures in 3D.\n */\nquil.core$macros.tint_int = (function quil$core$macros$tint_int(var_args){\nvar args595 = [];\nvar len__11134__auto___598 = arguments.length;\nvar i__11135__auto___599 = (0);\nwhile(true){\nif((i__11135__auto___599 < len__11134__auto___598)){\nargs595.push((arguments[i__11135__auto___599]));\n\nvar G__600 = (i__11135__auto___599 + (1));\ni__11135__auto___599 = G__600;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__597 = args595.length;\nswitch (G__597) {\ncase (1):\nreturn quil.core$macros.tint_int.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.tint_int.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args595.length)].join('')));\n\n}\n});\n\nquil.core$macros.tint_int.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core$macros.current_graphics.call(null).tint(cljs.core.unchecked_int.call(null,rgb));\n});\n\nquil.core$macros.tint_int.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core$macros.current_graphics.call(null).tint(cljs.core.unchecked_int.call(null,rgb),alpha);\n});\n\nquil.core$macros.tint_int.cljs$lang$maxFixedArity = (2);\n/**\n * Sets the fill value for displaying images. Images can be tinted to\n *   specified colors or made transparent by setting the alpha.\n * \n *   To make an image transparent, but not change it's color, use white\n *   as the tint color and specify an alpha value. For instance,\n *   tint(255, 128) will make an image 50% transparent (unless\n *   colorMode() has been used).\n * \n *   The value for the parameter gray must be less than or equal to the\n *   current maximum value as specified by colorMode(). The default\n *   maximum value is 255.\n * \n *   Also used to control the coloring of textures in 3D.\n */\nquil.core$macros.tint = (function quil$core$macros$tint(var_args){\nvar args602 = [];\nvar len__11134__auto___605 = arguments.length;\nvar i__11135__auto___606 = (0);\nwhile(true){\nif((i__11135__auto___606 < len__11134__auto___605)){\nargs602.push((arguments[i__11135__auto___606]));\n\nvar G__607 = (i__11135__auto___606 + (1));\ni__11135__auto___606 = G__607;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__604 = args602.length;\nswitch (G__604) {\ncase (1):\nreturn quil.core$macros.tint.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.tint.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.tint.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.tint.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args602.length)].join('')));\n\n}\n});\n\nquil.core$macros.tint.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core$macros.current_graphics.call(null).tint(rgb);\n});\n\nquil.core$macros.tint.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core$macros.current_graphics.call(null).tint(rgb,alpha);\n});\n\nquil.core$macros.tint.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core$macros.tint_float.call(null,r,g,b);\n});\n\nquil.core$macros.tint.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,a){\nreturn quil.core$macros.tint_float.call(null,r,g,b,a);\n});\n\nquil.core$macros.tint.cljs$lang$maxFixedArity = (4);\n/**\n * Specifies an amount to displace objects within the display\n *   window. The x parameter specifies left/right translation, the y\n *   parameter specifies up/down translation, and the z parameter\n *   specifies translations toward/away from the screen.  Transformations\n *   apply to everything that happens after and subsequent calls to the\n *   function accumulates the effect. For example, calling (translate 50\n *   0) and then (translate 20, 0) is the same as (translate 70, 0). If\n *   translate is called within draw, the transformation is reset when\n *   the loop begins again. This function can be further controlled by\n *   the push-matrix and pop-matrix.\n */\nquil.core$macros.translate = (function quil$core$macros$translate(var_args){\nvar args609 = [];\nvar len__11134__auto___612 = arguments.length;\nvar i__11135__auto___613 = (0);\nwhile(true){\nif((i__11135__auto___613 < len__11134__auto___612)){\nargs609.push((arguments[i__11135__auto___613]));\n\nvar G__614 = (i__11135__auto___613 + (1));\ni__11135__auto___613 = G__614;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__611 = args609.length;\nswitch (G__611) {\ncase (1):\nreturn quil.core$macros.translate.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.translate.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.translate.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args609.length)].join('')));\n\n}\n});\n\nquil.core$macros.translate.cljs$core$IFn$_invoke$arity$1 = (function (v){\nreturn cljs.core.apply.call(null,quil.core$macros.translate,v);\n});\n\nquil.core$macros.translate.cljs$core$IFn$_invoke$arity$2 = (function (tx,ty){\nreturn quil.core$macros.current_graphics.call(null).translate(tx,ty);\n});\n\nquil.core$macros.translate.cljs$core$IFn$_invoke$arity$3 = (function (tx,ty,tz){\nreturn quil.core$macros.current_graphics.call(null).translate(tx,ty,tz);\n});\n\nquil.core$macros.translate.cljs$lang$maxFixedArity = (3);\n/**\n * A triangle is a plane created by connecting three points. The first\n *   two arguments specify the first point, the middle two arguments\n *   specify the second point, and the last two arguments specify the\n *   third point.\n */\nquil.core$macros.triangle = (function quil$core$macros$triangle(x1,y1,x2,y2,x3,y3){\nreturn quil.core$macros.current_graphics.call(null).triangle(x1,y1,x2,y2,x3,y3);\n});\n/**\n * Unpack a binary string to an integer. See binary for converting\n *   integers to strings.\n */\nquil.core$macros.unbinary = (function quil$core$macros$unbinary(str_val){\nreturn quil.sketch.current_applet.call(null).unbinary([cljs.core.str(str_val)].join(''));\n});\n/**\n * Converts a String representation of a hexadecimal number to its\n *   equivalent integer value.\n */\nquil.core$macros.unhex = (function quil$core$macros$unhex(hex_str){\nreturn quil.sketch.current_applet.call(null).unhex([cljs.core.str(hex_str)].join(''));\n});\n/**\n * Updates the display window or image with the data in the pixels array.\n *   Use in conjunction with (pixels). If you're only reading pixels from\n *   the array, there's no need to call update-pixels unless there are\n *   changes.\n * \n *   Certain renderers may or may not seem to require pixels or\n *   update-pixels. However, the rule is that any time you want to\n *   manipulate the pixels array, you must first call pixels, and\n *   after changes have been made, call update-pixels. Even if the\n *   renderer may not seem to use this function in the current Processing\n *   release, this will always be subject to change.\n */\nquil.core$macros.update_pixels = (function quil$core$macros$update_pixels(var_args){\nvar args616 = [];\nvar len__11134__auto___619 = arguments.length;\nvar i__11135__auto___620 = (0);\nwhile(true){\nif((i__11135__auto___620 < len__11134__auto___619)){\nargs616.push((arguments[i__11135__auto___620]));\n\nvar G__621 = (i__11135__auto___620 + (1));\ni__11135__auto___620 = G__621;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__618 = args616.length;\nswitch (G__618) {\ncase (0):\nreturn quil.core$macros.update_pixels.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.update_pixels.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args616.length)].join('')));\n\n}\n});\n\nquil.core$macros.update_pixels.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.update_pixels.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.update_pixels.cljs$core$IFn$_invoke$arity$1 = (function (img){\nvar temp__10134__auto___623 = img.stored_pix_array;\nif(cljs.core.truth_(temp__10134__auto___623)){\nvar pix_array_624 = temp__10134__auto___623;\nimg.pixels.set(pix_array_624);\n\nimg.stored_pix_array = null;\n} else {\n}\n\nreturn img.updatePixels();\n});\n\nquil.core$macros.update_pixels.cljs$lang$maxFixedArity = (1);\n/**\n * All shapes are constructed by connecting a series of\n *   vertices. vertex is used to specify the vertex coordinates for\n *   points, lines, triangles, quads, and polygons and is used\n *   exclusively within the begin-shape and end-shape fns.\n * \n *   Drawing a vertex in 3D using the z parameter requires the :p3d or\n *   :opengl renderers to be used.\n * \n *   This function is also used to map a texture onto the geometry. The\n *   texture fn declares the texture to apply to the geometry and the u\n *   and v coordinates set define the mapping of this texture to the\n *   form. By default, the coordinates used for u and v are specified in\n *   relation to the image's size in pixels, but this relation can be\n *   changed with texture-mode.\n */\nquil.core$macros.vertex = (function quil$core$macros$vertex(var_args){\nvar args625 = [];\nvar len__11134__auto___628 = arguments.length;\nvar i__11135__auto___629 = (0);\nwhile(true){\nif((i__11135__auto___629 < len__11134__auto___628)){\nargs625.push((arguments[i__11135__auto___629]));\n\nvar G__630 = (i__11135__auto___629 + (1));\ni__11135__auto___629 = G__630;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__627 = args625.length;\nswitch (G__627) {\ncase (2):\nreturn quil.core$macros.vertex.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.vertex.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.vertex.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (5):\nreturn quil.core$macros.vertex.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args625.length)].join('')));\n\n}\n});\n\nquil.core$macros.vertex.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.core$macros.current_graphics.call(null).vertex(x,y);\n});\n\nquil.core$macros.vertex.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.current_graphics.call(null).vertex(x,y,z);\n});\n\nquil.core$macros.vertex.cljs$core$IFn$_invoke$arity$4 = (function (x,y,u,v){\nreturn quil.core$macros.current_graphics.call(null).vertex(x,y,u,v);\n});\n\nquil.core$macros.vertex.cljs$core$IFn$_invoke$arity$5 = (function (x,y,z,u,v){\nreturn quil.core$macros.current_graphics.call(null).vertex(x,y,z,u,v);\n});\n\nquil.core$macros.vertex.cljs$lang$maxFixedArity = (5);\n/**\n * Returns the current year as an integer (2003, 2004, 2005, etc).\n */\nquil.core$macros.year = (function quil$core$macros$year(){\nreturn quil.sketch.current_applet.call(null).year();\n});\n/**\n * Width of the display window. The value of width is zero until size is\n *   called.\n */\nquil.core$macros.width = (function quil$core$macros$width(){\nreturn quil.sketch.current_applet.call(null).width;\n});\n/**\n * Temporarily set the fill color for the body of this macro.\n * The code outside of with-fill form will have the previous fill color set.\n * \n * The fill color has to be in a vector!\n * Example: (with-fill [255] ...)\n *          (with-fill [10 80 98] ...)\n */\nquil.core$macros.with_fill = (function quil$core$macros$with_fill(var_args){\nvar args__11136__auto__ = [];\nvar len__11134__auto___636 = arguments.length;\nvar i__11135__auto___637 = (0);\nwhile(true){\nif((i__11135__auto___637 < len__11134__auto___636)){\nargs__11136__auto__.push((arguments[i__11135__auto___637]));\n\nvar G__638 = (i__11135__auto___637 + (1));\ni__11135__auto___637 = G__638;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__11137__auto__ = ((((3) < args__11136__auto__.length))?(new cljs.core.IndexedSeq(args__11136__auto__.slice((3)),(0),null)):null);\nreturn quil.core$macros.with_fill.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__11137__auto__);\n});\n\nquil.core$macros.with_fill.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,fill_args,body){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"let\",\"let\",(358118826),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"old-fill__11__auto__\",\"old-fill__11__auto__\",(-1432464131),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"current-fill\",\"quil.core/current-fill\",(269663137),null))))))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"apply\",\"apply\",(-1334050276),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"fill\",\"quil.core/fill\",(814613078),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,fill_args)))),body,cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"fill\",\"quil.core/fill\",(814613078),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"old-fill__11__auto__\",\"old-fill__11__auto__\",(-1432464131),null)))))));\n});\n\nquil.core$macros.with_fill.cljs$lang$maxFixedArity = (3);\n\nquil.core$macros.with_fill.cljs$lang$applyTo = (function (seq632){\nvar G__633 = cljs.core.first.call(null,seq632);\nvar seq632__$1 = cljs.core.next.call(null,seq632);\nvar G__634 = cljs.core.first.call(null,seq632__$1);\nvar seq632__$2 = cljs.core.next.call(null,seq632__$1);\nvar G__635 = cljs.core.first.call(null,seq632__$2);\nvar seq632__$3 = cljs.core.next.call(null,seq632__$2);\nreturn quil.core$macros.with_fill.cljs$core$IFn$_invoke$arity$variadic(G__633,G__634,G__635,seq632__$3);\n});\n\nquil.core$macros.with_fill.cljs$lang$macro = true;\n/**\n * Temporarily set the stroke color for the body of this macro.\n * The code outside of with-stroke form will have the previous stroke color set.\n * \n * The stroke color has to be in a vector!\n * Example: (with-stroke [255] ...)\n *          (with-stroke [10 80 98] ...)\n */\nquil.core$macros.with_stroke = (function quil$core$macros$with_stroke(var_args){\nvar args__11136__auto__ = [];\nvar len__11134__auto___643 = arguments.length;\nvar i__11135__auto___644 = (0);\nwhile(true){\nif((i__11135__auto___644 < len__11134__auto___643)){\nargs__11136__auto__.push((arguments[i__11135__auto___644]));\n\nvar G__645 = (i__11135__auto___644 + (1));\ni__11135__auto___644 = G__645;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__11137__auto__ = ((((3) < args__11136__auto__.length))?(new cljs.core.IndexedSeq(args__11136__auto__.slice((3)),(0),null)):null);\nreturn quil.core$macros.with_stroke.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__11137__auto__);\n});\n\nquil.core$macros.with_stroke.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,stroke_args,body){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"let\",\"let\",(358118826),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"old-stroke__12__auto__\",\"old-stroke__12__auto__\",(-1181229123),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"current-stroke\",\"quil.core/current-stroke\",(-1148124489),null))))))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"apply\",\"apply\",(-1334050276),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"stroke\",\"quil.core/stroke\",(577473004),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,stroke_args)))),body,cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"stroke\",\"quil.core/stroke\",(577473004),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"old-stroke__12__auto__\",\"old-stroke__12__auto__\",(-1181229123),null)))))));\n});\n\nquil.core$macros.with_stroke.cljs$lang$maxFixedArity = (3);\n\nquil.core$macros.with_stroke.cljs$lang$applyTo = (function (seq639){\nvar G__640 = cljs.core.first.call(null,seq639);\nvar seq639__$1 = cljs.core.next.call(null,seq639);\nvar G__641 = cljs.core.first.call(null,seq639__$1);\nvar seq639__$2 = cljs.core.next.call(null,seq639__$1);\nvar G__642 = cljs.core.first.call(null,seq639__$2);\nvar seq639__$3 = cljs.core.next.call(null,seq639__$2);\nreturn quil.core$macros.with_stroke.cljs$core$IFn$_invoke$arity$variadic(G__640,G__641,G__642,seq639__$3);\n});\n\nquil.core$macros.with_stroke.cljs$lang$macro = true;\n/**\n * Performs body with translation, restores current transformation on\n *   exit.\n */\nquil.core$macros.with_translation = (function quil$core$macros$with_translation(var_args){\nvar args__11136__auto__ = [];\nvar len__11134__auto___650 = arguments.length;\nvar i__11135__auto___651 = (0);\nwhile(true){\nif((i__11135__auto___651 < len__11134__auto___650)){\nargs__11136__auto__.push((arguments[i__11135__auto___651]));\n\nvar G__652 = (i__11135__auto___651 + (1));\ni__11135__auto___651 = G__652;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__11137__auto__ = ((((3) < args__11136__auto__.length))?(new cljs.core.IndexedSeq(args__11136__auto__.slice((3)),(0),null)):null);\nreturn quil.core$macros.with_translation.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__11137__auto__);\n});\n\nquil.core$macros.with_translation.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,translation_vector,body){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"let\",\"let\",(358118826),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"tr__13__auto__\",\"tr__13__auto__\",(1325556268),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,translation_vector))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"push-matrix\",\"quil.core/push-matrix\",(1356326676),null))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"try\",\"try\",(-1273693247),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"translate\",\"quil.core/translate\",(150889028),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"tr__13__auto__\",\"tr__13__auto__\",(1325556268),null))))),body,cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"finally\",\"finally\",(-1065347064),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"pop-matrix\",\"quil.core/pop-matrix\",(310892617),null)))))))))))));\n});\n\nquil.core$macros.with_translation.cljs$lang$maxFixedArity = (3);\n\nquil.core$macros.with_translation.cljs$lang$applyTo = (function (seq646){\nvar G__647 = cljs.core.first.call(null,seq646);\nvar seq646__$1 = cljs.core.next.call(null,seq646);\nvar G__648 = cljs.core.first.call(null,seq646__$1);\nvar seq646__$2 = cljs.core.next.call(null,seq646__$1);\nvar G__649 = cljs.core.first.call(null,seq646__$2);\nvar seq646__$3 = cljs.core.next.call(null,seq646__$2);\nreturn quil.core$macros.with_translation.cljs$core$IFn$_invoke$arity$variadic(G__647,G__648,G__649,seq646__$3);\n});\n\nquil.core$macros.with_translation.cljs$lang$macro = true;\n/**\n * Performs body with rotation, restores current transformation on exit.\n *   Accepts a vector [angle] or [angle x-axis y-axis z-axis].\n * \n *   Example:\n *  (with-rotation [angle]\n *    (vertex 1 2))\n */\nquil.core$macros.with_rotation = (function quil$core$macros$with_rotation(var_args){\nvar args__11136__auto__ = [];\nvar len__11134__auto___657 = arguments.length;\nvar i__11135__auto___658 = (0);\nwhile(true){\nif((i__11135__auto___658 < len__11134__auto___657)){\nargs__11136__auto__.push((arguments[i__11135__auto___658]));\n\nvar G__659 = (i__11135__auto___658 + (1));\ni__11135__auto___658 = G__659;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__11137__auto__ = ((((3) < args__11136__auto__.length))?(new cljs.core.IndexedSeq(args__11136__auto__.slice((3)),(0),null)):null);\nreturn quil.core$macros.with_rotation.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__11137__auto__);\n});\n\nquil.core$macros.with_rotation.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,rotation,body){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"let\",\"let\",(358118826),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"tr__14__auto__\",\"tr__14__auto__\",(448676950),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,rotation))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"push-matrix\",\"quil.core/push-matrix\",(1356326676),null))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"try\",\"try\",(-1273693247),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"apply\",\"apply\",(-1334050276),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"rotate\",\"quil.core/rotate\",(-1944995048),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"tr__14__auto__\",\"tr__14__auto__\",(448676950),null))))),body,cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"finally\",\"finally\",(-1065347064),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"pop-matrix\",\"quil.core/pop-matrix\",(310892617),null)))))))))))));\n});\n\nquil.core$macros.with_rotation.cljs$lang$maxFixedArity = (3);\n\nquil.core$macros.with_rotation.cljs$lang$applyTo = (function (seq653){\nvar G__654 = cljs.core.first.call(null,seq653);\nvar seq653__$1 = cljs.core.next.call(null,seq653);\nvar G__655 = cljs.core.first.call(null,seq653__$1);\nvar seq653__$2 = cljs.core.next.call(null,seq653__$1);\nvar G__656 = cljs.core.first.call(null,seq653__$2);\nvar seq653__$3 = cljs.core.next.call(null,seq653__$2);\nreturn quil.core$macros.with_rotation.cljs$core$IFn$_invoke$arity$variadic(G__654,G__655,G__656,seq653__$3);\n});\n\nquil.core$macros.with_rotation.cljs$lang$macro = true;\n/**\n * All subsequent calls of any drawing function will draw on given\n *   graphics. 'with-graphics' cannot be nested (you can draw simultaneously\n *   only on 1 graphics)\n */\nquil.core$macros.with_graphics = (function quil$core$macros$with_graphics(var_args){\nvar args__11136__auto__ = [];\nvar len__11134__auto___664 = arguments.length;\nvar i__11135__auto___665 = (0);\nwhile(true){\nif((i__11135__auto___665 < len__11134__auto___664)){\nargs__11136__auto__.push((arguments[i__11135__auto___665]));\n\nvar G__666 = (i__11135__auto___665 + (1));\ni__11135__auto___665 = G__666;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__11137__auto__ = ((((3) < args__11136__auto__.length))?(new cljs.core.IndexedSeq(args__11136__auto__.slice((3)),(0),null)):null);\nreturn quil.core$macros.with_graphics.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__11137__auto__);\n});\n\nquil.core$macros.with_graphics.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,graphics,body){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"binding\",\"binding\",(-2114503176),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"*graphics*\",\"quil.core/*graphics*\",(-1088142302),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,graphics))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\".beginDraw\",\".beginDraw\",(1110767550),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,graphics)))),body,cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\".endDraw\",\".endDraw\",(795589408),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,graphics))))));\n});\n\nquil.core$macros.with_graphics.cljs$lang$maxFixedArity = (3);\n\nquil.core$macros.with_graphics.cljs$lang$applyTo = (function (seq660){\nvar G__661 = cljs.core.first.call(null,seq660);\nvar seq660__$1 = cljs.core.next.call(null,seq660);\nvar G__662 = cljs.core.first.call(null,seq660__$1);\nvar seq660__$2 = cljs.core.next.call(null,seq660__$1);\nvar G__663 = cljs.core.first.call(null,seq660__$2);\nvar seq660__$3 = cljs.core.next.call(null,seq660__$2);\nreturn quil.core$macros.with_graphics.cljs$core$IFn$_invoke$arity$variadic(G__661,G__662,G__663,seq660__$3);\n});\n\nquil.core$macros.with_graphics.cljs$lang$macro = true;\n/**\n * Create and start a new visualisation applet. Can be used to create\n *   new sketches programmatically. See documentation for 'defsketch' for\n *   list of available options.\n */\nquil.core$macros.sketch = (function quil$core$macros$sketch(var_args){\nvar args__11136__auto__ = [];\nvar len__11134__auto___668 = arguments.length;\nvar i__11135__auto___669 = (0);\nwhile(true){\nif((i__11135__auto___669 < len__11134__auto___668)){\nargs__11136__auto__.push((arguments[i__11135__auto___669]));\n\nvar G__670 = (i__11135__auto___669 + (1));\ni__11135__auto___669 = G__670;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__11137__auto__ = ((((0) < args__11136__auto__.length))?(new cljs.core.IndexedSeq(args__11136__auto__.slice((0)),(0),null)):null);\nreturn quil.core$macros.sketch.cljs$core$IFn$_invoke$arity$variadic(argseq__11137__auto__);\n});\n\nquil.core$macros.sketch.cljs$core$IFn$_invoke$arity$variadic = (function (opts){\nreturn cljs.core.apply.call(null,quil.sketch.sketch,opts);\n});\n\nquil.core$macros.sketch.cljs$lang$maxFixedArity = (0);\n\nquil.core$macros.sketch.cljs$lang$applyTo = (function (seq667){\nreturn quil.core$macros.sketch.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq.call(null,seq667));\n});\n/**\n * Define and start a sketch and bind it to a var with the symbol\n *   app-name. If any of the options to the various callbacks are\n *   symbols, it wraps them in a call to var to ensure they aren't\n *   inlined and that redefinitions to the original fns are reflected in\n *   the visualisation.\n * \n *   Available options:\n * \n * :size           - A vector of width and height for the sketch or :fullscreen.\n *                   Defaults to [500 300]. If you're using :fullscreen you may\n *                   want to enable present mode - :features [:present]\n * \n * :renderer       - Specifies the renderer type. One of :p2d, :p3d, :java2d,\n *                   :opengl, :pdf). Defaults to :java2d. :dxf renderer\n *                   can't be used as sketch renderer. Use begin-raw method\n *                   instead. In clojurescript only :p2d and :p3d renderers\n *                   are supported.\n * \n * :output-file    - Specifies an output file path. Only used in :pdf mode.\n *                   Not supported in clojurescript.\n * \n * :title          - A string which will be displayed at the top of\n *                   the sketch window. Not supported in clojurescript.\n * \n * :features       - A vector of keywords customizing sketch behaviour.\n *                   Supported features:\n * \n *                   :keep-on-top - Sketch window will always be above other\n *                                  windows. Note: some platforms might not\n *                                  support always-on-top windows.\n *                                  Not supported in clojurescript.\n * \n *                   :exit-on-close - Shutdown JVM  when sketch is closed.\n *                                    Not supported in clojurescript.\n * \n *                   :resizable - Makes sketch resizable.\n *                                Not supported in clojurescript.\n * \n *                   :no-safe-fns - Do not catch and print exceptions thrown\n *                                  inside functions provided to sketch (like\n *                                  draw, mouse-click, key-pressed and\n *                                  other). By default all exceptions thrown\n *                                  inside these functions are catched. This\n *                                  prevents sketch from breaking when bad\n *                                  function was provided and allows you to\n *                                  fix it and reload it on fly. You can\n *                                  disable this behaviour by enabling\n *                                  :no-safe-fns feature.\n *                                  Not supported in clojurescript.\n * \n *                   :present - Switch to present mode (fullscreen without\n *                              borders, OS panels). You may want to use\n *                              this feature together with :size :fullscreen.\n *                              Not supported in clojurescript.\n * \n *                   :no-start - Disables autostart if sketch was created using\n *                               defsketch macro. To start sketch you have to\n *                               call function created defsketch.\n *                               Supported only in clojurescript.\n * \n *                   :global-key-events - Allows a sketch to receive any\n *                                        keyboard event sent to the page,\n *                                        regardless of whether the canvas it is\n *                                        loaded in has focus or not.\n *                                        Supported only in clojurescript.\n * \n *                   Usage example: :features [:keep-on-top :present]\n * \n * :bgcolor        - Sets background color for unused space in present mode.\n *                   Color is specified in hex format: #XXXXXX.\n *                   Example: :bgcolor \"#00FFFF\" (cyan background)\n *                   Not supported in clojurescript.\n * \n * :display        - Sets what display should be used by this sketch.\n *                   Displays are numbered starting from 0. Example: :display 1.\n *                   Not supported in clojurescript.\n * \n * :setup          - A function to be called once when setting the sketch up.\n * \n * :draw           - A function to be repeatedly called at most n times per\n *                   second where n is the target frame-rate set for\n *                   the visualisation.\n * \n * :host           - String id of canvas element or DOM element itself.\n *                   Specifies host for the sketch. Must be specified in sketch,\n *                   may be omitted in defsketch. If ommitted in defsketch,\n *                   :host is set to the name of the sketch. If element with\n *                   specified id is not found on the page and page is empty -\n *                   new canvas element will be created. Used in clojurescript.\n * \n * :focus-gained   - Called when the sketch gains focus.\n *                   Not supported in clojurescript.\n * \n * :focus-lost     - Called when the sketch loses focus.\n *                   Not supported in clojurescript.\n * \n * :mouse-entered  - Called when the mouse enters the sketch window.\n * \n * :mouse-exited   - Called when the mouse leaves the sketch window\n * \n * :mouse-pressed  - Called every time a mouse button is pressed.\n * \n * :mouse-released - Called every time a mouse button is released.\n * \n * :mouse-clicked  - called once after a mouse button has been pressed\n *                   and then released.\n * \n * :mouse-moved    - Called every time the mouse moves and a button is\n *                   not pressed.\n * \n * :mouse-dragged  - Called every time the mouse moves and a button is\n *                   pressed.\n * \n * :mouse-wheel    - Called every time mouse wheel is rotated.\n *                   Takes 1 argument - wheel rotation, an int.\n *                   Negative values if the mouse wheel was rotated\n *                   up/away from the user, and positive values\n *                   if the mouse wheel was rotated down/ towards the user\n * \n * :key-pressed    - Called every time any key is pressed.\n * \n * :key-released   - Called every time any key is released.\n * \n * :key-typed      - Called once every time non-modifier keys are\n *                   pressed.\n * \n * :on-close       - Called once, when sketch is closed\n *                   Not supported in clojurescript.\n * \n * :middleware     - Vector of middleware to be applied to the sketch.\n *                   Middleware will be applied in the same order as in comp\n *                   function: [f g] will be applied as (f (g options)).\n * \n * :settings       - cousin of :setup. A function to be called once when\n *                   setting sketch up. Should be used only for (smooth) and\n *                   (no-smooth). Due to Processing limitations these functions\n *                   cannot be used neither in :setup nor in :draw.\n */\nquil.core$macros.defsketch = (function quil$core$macros$defsketch(var_args){\nvar args__11136__auto__ = [];\nvar len__11134__auto___675 = arguments.length;\nvar i__11135__auto___676 = (0);\nwhile(true){\nif((i__11135__auto___676 < len__11134__auto___675)){\nargs__11136__auto__.push((arguments[i__11135__auto___676]));\n\nvar G__677 = (i__11135__auto___676 + (1));\ni__11135__auto___676 = G__677;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__11137__auto__ = ((((3) < args__11136__auto__.length))?(new cljs.core.IndexedSeq(args__11136__auto__.slice((3)),(0),null)):null);\nreturn quil.core$macros.defsketch.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__11137__auto__);\n});\n\nquil.core$macros.defsketch.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,app_name,options){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.sketch$macros\",\"defsketch\",\"quil.sketch$macros/defsketch\",(2065609719),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,app_name),options));\n});\n\nquil.core$macros.defsketch.cljs$lang$maxFixedArity = (3);\n\nquil.core$macros.defsketch.cljs$lang$applyTo = (function (seq671){\nvar G__672 = cljs.core.first.call(null,seq671);\nvar seq671__$1 = cljs.core.next.call(null,seq671);\nvar G__673 = cljs.core.first.call(null,seq671__$1);\nvar seq671__$2 = cljs.core.next.call(null,seq671__$1);\nvar G__674 = cljs.core.first.call(null,seq671__$2);\nvar seq671__$3 = cljs.core.next.call(null,seq671__$2);\nreturn quil.core$macros.defsketch.cljs$core$IFn$_invoke$arity$variadic(G__672,G__673,G__674,seq671__$3);\n});\n\nquil.core$macros.defsketch.cljs$lang$macro = true;\n/**\n * Returns true if char c is a 'coded' char i.e. it is necessary to\n *   fetch the key-code as an integer and use that to determine the\n *   specific key pressed. See key-keyword.\n */\nquil.core$macros.key_coded_QMARK_ = (function quil$core$macros$key_coded_QMARK_(c){\nreturn cljs.core._EQ_.call(null,(65535),[cljs.core.str(c)].join('').charCodeAt());\n});\n/**\n * Returns a keyword representing the currently pressed key. Modifier\n *   keys are represented as: :up, :down, :left, :right, :alt, :control,\n *   :shift, :command, :f1-24\n */\nquil.core$macros.key_as_keyword = (function quil$core$macros$key_as_keyword(){\nvar key_char = quil.core$macros.raw_key.call(null);\nvar code = quil.core$macros.key_code.call(null);\nif(cljs.core.truth_(quil.core$macros.key_coded_QMARK_.call(null,key_char))){\nreturn cljs.core.get.call(null,quil.core$macros.KEY_CODES,code,new cljs.core.Keyword(null,\"unknown-key\",\"unknown-key\",(255305911)));\n} else {\nreturn cljs.core.keyword.call(null,[cljs.core.str(key_char)].join(''));\n}\n});\n"}}