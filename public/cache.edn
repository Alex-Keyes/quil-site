{{:name quil.sketch, :macros false} {:cache {:name quil.sketch, :doc nil, :excludes #{}, :use-macros nil, :require-macros nil, :uses nil, :requires nil, :imports nil}, :source "goog.provide(\"quil.sketch\");\n"}, {:name quil.util, :macros false} {:cache {:use-macros nil, :excludes #{}, :name quil.util, :imports nil, :requires {cstr clojure.string, clojure.string clojure.string}, :uses nil, :defs {clj-compilation? {:protocol-inline nil, :meta {:file quil.util, :line 71, :column 7, :end-line 71, :end-column 23, :arglists (quote ([]))}, :name quil.util/clj-compilation?, :variadic false, :file nil, :end-column 23, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 71, :end-line 71, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, make-quil-constant-map {:protocol-inline nil, :meta {:file quil.util, :line 98, :column 7, :end-line 98, :end-column 29, :arglists (quote ([target const-map-name const-map]))}, :name quil.util/make-quil-constant-map, :variadic false, :file nil, :end-column 29, :method-params ([target const-map-name const-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 98, :end-line 98, :max-fixed-arity 3, :fn-var true, :arglists (quote ([target const-map-name const-map]))}, print-definition-list {:protocol-inline nil, :meta {:file quil.util, :line 60, :column 7, :end-line 60, :end-column 28, :arglists (quote ([definitions]))}, :name quil.util/print-definition-list, :variadic false, :file nil, :end-column 28, :method-params ([definitions]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 60, :end-line 60, :max-fixed-arity 1, :fn-var true, :arglists (quote ([definitions]))}, generate-quil-constants {:protocol-inline nil, :meta {:file quil.util, :line 105, :column 11, :end-line 105, :end-column 34, :macro true, :arglists (quote ([target & opts])), :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env target opts)], :arglists ([&form &env target & opts]), :arglists-meta (nil)}}, :name quil.util/generate-quil-constants, :variadic true, :file nil, :end-column 34, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env target opts)], :arglists ([&form &env target & opts]), :arglists-meta (nil)}, :method-params [(&form &env target opts)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 105, :macro true, :end-line 105, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env target & opts])}, resolve-constant-key {:protocol-inline nil, :meta {:file quil.util, :line 27, :column 7, :end-line 27, :end-column 27, :arglists (quote ([key mappings])), :doc "Returns the val associated with key in mappings or key directly if it\n  is one of the vals in mappings. Otherwise throws an exception."}, :name quil.util/resolve-constant-key, :variadic false, :file nil, :end-column 27, :method-params ([key mappings]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 27, :end-line 27, :max-fixed-arity 2, :fn-var true, :arglists (quote ([key mappings])), :doc "Returns the val associated with key in mappings or key directly if it\n  is one of the vals in mappings. Otherwise throws an exception."}, no-fn {:protocol-inline nil, :meta {:file quil.util, :line 5, :column 7, :end-line 5, :end-column 12, :arglists (quote ([])), :doc "Function that does nothing."}, :name quil.util/no-fn, :variadic false, :file nil, :end-column 12, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5, :end-line 5, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Function that does nothing."}, prepare-quil-clj-constants {:protocol-inline nil, :meta {:file quil.util, :line 86, :column 7, :end-line 86, :end-column 33, :arglists (quote ([constants]))}, :name quil.util/prepare-quil-clj-constants, :variadic false, :file nil, :end-column 33, :method-params ([constants]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 86, :end-line 86, :max-fixed-arity 1, :fn-var true, :arglists (quote ([constants]))}, prepare-quil-cljs-constants {:protocol-inline nil, :meta {:file quil.util, :line 92, :column 7, :end-line 92, :end-column 34, :arglists (quote ([constants]))}, :name quil.util/prepare-quil-cljs-constants, :variadic false, :file nil, :end-column 34, :method-params ([constants]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 92, :end-line 92, :max-fixed-arity 1, :fn-var true, :arglists (quote ([constants]))}, length-of-longest-key {:protocol-inline nil, :meta {:file quil.util, :line 39, :column 8, :end-line 39, :end-column 29, :private true, :arglists (quote ([m])), :doc "Returns the length of the longest key of map m. Assumes m's keys are strings\n   and returns 0 if map is empty:\n   (length-of-longest-key {\"foo\" 1 \"barr\" 2 \"bazzz\" 3}) ;=> 5\n   (length-of-longest-key {}) ;=> 0"}, :private true, :name quil.util/length-of-longest-key, :variadic false, :file nil, :end-column 29, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 39, :end-line 39, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns the length of the longest key of map m. Assumes m's keys are strings\n   and returns 0 if map is empty:\n   (length-of-longest-key {\"foo\" 1 \"barr\" 2 \"bazzz\" 3}) ;=> 5\n   (length-of-longest-key {}) ;=> 0"}, gen-padding {:protocol-inline nil, :meta {:private true, :file quil.util, :end-column 19, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([len] [len pad] [s len pad]), :arglists ([len] [len pad] [s len pad]), :arglists-meta (nil nil nil)}, :column 8, :line 48, :end-line 48, :arglists (quote ([len] [len pad] [s len pad])), :doc "Generates a padding string starting concatting s with len times pad:\n   (gen-padding \"\" 5 \"b\") ;=> \"bbbbb\"\n   May be called without starting string s in which case it defaults to the\n   empty string and also without pad in which case it defaults to a single space"}, :private true, :name quil.util/gen-padding, :variadic false, :file nil, :end-column 19, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([len] [len pad] [s len pad]), :arglists ([len] [len pad] [s len pad]), :arglists-meta (nil nil nil)}, :method-params ([len] [len pad] [s len pad]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 48, :end-line 48, :max-fixed-arity 3, :fn-var true, :arglists ([len] [len pad] [s len pad]), :doc "Generates a padding string starting concatting s with len times pad:\n   (gen-padding \"\" 5 \"b\") ;=> \"bbbbb\"\n   May be called without starting string s in which case it defaults to the\n   empty string and also without pad in which case it defaults to a single space"}, prepare-quil-name {:protocol-inline nil, :meta {:file quil.util, :line 81, :column 7, :end-line 81, :end-column 24, :arglists (quote ([const-keyword]))}, :name quil.util/prepare-quil-name, :variadic false, :file nil, :end-column 24, :method-params ([const-keyword]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 81, :end-line 81, :max-fixed-arity 1, :fn-var true, :arglists (quote ([const-keyword]))}}, :require-macros nil, :cljs.analyzer/constants {:seen #{:else aget js/Processing.prototype.PConstants def :clj do}, :order [:else aget js/Processing.prototype.PConstants def :clj do]}, :doc "Utility fns"}, :source "goog.provide(\"quil.util\");\n/**\n * Function that does nothing.\n */\nquil.util.no_fn = (function quil$util$no_fn(){\nreturn null;\n});\n/**\n * Returns the val associated with key in mappings or key directly if it\n *   is one of the vals in mappings. Otherwise throws an exception.\n */\nquil.util.resolve_constant_key = (function quil$util$resolve_constant_key(key,mappings){\nif(cljs.core.truth_(cljs.core.get.call(null,mappings,key))){\nreturn cljs.core.get.call(null,mappings,key);\n} else {\nif(cljs.core.truth_(cljs.core.some.call(null,cljs.core.PersistentHashSet.fromArray([key], true),cljs.core.vals.call(null,mappings)))){\nreturn key;\n} else {\nthrow (new Error([cljs.core.str(\"Expecting a keyword, got: \"),cljs.core.str(key),cljs.core.str(\". Expected one of: \"),cljs.core.str(cljs.core.vec.call(null,cljs.core.sort.call(null,cljs.core.keys.call(null,mappings))))].join('')));\n\n}\n}\n});\n/**\n * Returns the length of the longest key of map m. Assumes m's keys are strings\n * and returns 0 if map is empty:\n * (length-of-longest-key {\"foo\" 1 \"barr\" 2 \"bazzz\" 3}) ;=> 5\n * (length-of-longest-key {}) ;=> 0\n */\nquil.util.length_of_longest_key = (function quil$util$length_of_longest_key(m){\nvar or__2423__auto__ = cljs.core.last.call(null,cljs.core.sort.call(null,cljs.core.map.call(null,(function (p1__1_SHARP_){\nreturn p1__1_SHARP_.length();\n}),cljs.core.keys.call(null,m))));\nif(cljs.core.truth_(or__2423__auto__)){\nreturn or__2423__auto__;\n} else {\nreturn (0);\n}\n});\n/**\n * Generates a padding string starting concatting s with len times pad:\n * (gen-padding \"\" 5 \"b\") ;=> \"bbbbb\"\n * May be called without starting string s in which case it defaults to the\n * empty string and also without pad in which case it defaults to a single space\n */\nquil.util.gen_padding = (function quil$util$gen_padding(var_args){\nvar args24 = [];\nvar len__3279__auto___27 = arguments.length;\nvar i__3280__auto___28 = (0);\nwhile(true){\nif((i__3280__auto___28 < len__3279__auto___27)){\nargs24.push((arguments[i__3280__auto___28]));\n\nvar G__29 = (i__3280__auto___28 + (1));\ni__3280__auto___28 = G__29;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__26 = args24.length;\nswitch (G__26) {\ncase (1):\nreturn quil.util.gen_padding.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.util.gen_padding.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.util.gen_padding.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args24.length)].join('')));\n\n}\n});\n\nquil.util.gen_padding.cljs$core$IFn$_invoke$arity$1 = (function (len){\nreturn quil.util.gen_padding.call(null,\"\",len,\" \");\n});\n\nquil.util.gen_padding.cljs$core$IFn$_invoke$arity$2 = (function (len,pad){\nreturn quil.util.gen_padding.call(null,\"\",len,pad);\n});\n\nquil.util.gen_padding.cljs$core$IFn$_invoke$arity$3 = (function (s,len,pad){\nif((len > (0))){\nreturn quil.util.gen_padding.call(null,[cljs.core.str(s),cljs.core.str(pad)].join(''),(len - (1)),pad);\n} else {\nreturn s;\n}\n});\n\nquil.util.gen_padding.cljs$lang$maxFixedArity = (3);\nquil.util.print_definition_list = (function quil$util$print_definition_list(definitions){\nvar longest_key = quil.util.length_of_longest_key.call(null,definitions);\nreturn cljs.core.dorun.call(null,cljs.core.map.call(null,((function (longest_key){\nreturn (function (p__33){\nvar vec__34 = p__33;\nvar k = cljs.core.nth.call(null,vec__34,(0),null);\nvar v = cljs.core.nth.call(null,vec__34,(1),null);\nvar len = k.length();\nvar diff = (longest_key - len);\nvar pad = quil.util.gen_padding.call(null,diff);\nreturn cljs.core.println.call(null,k,pad,\"- \",v);\n});})(longest_key))\n,definitions));\n});\nquil.util.clj_compilation_QMARK_ = (function quil$util$clj_compilation_QMARK_(){\nreturn false;\n});\nquil.util.prepare_quil_name = (function quil$util$prepare_quil_name(const_keyword){\nreturn clojure.string.replace.call(null,clojure.string.upper_case.call(null,cljs.core.name.call(null,const_keyword)),/-/,\"_\");\n});\nquil.util.prepare_quil_clj_constants = (function quil$util$prepare_quil_clj_constants(constants){\nreturn cljs.core.into.call(null,cljs.core.PersistentArrayMap.EMPTY,cljs.core.map.call(null,(function (p1__2_SHARP_){\nreturn (new cljs.core.PersistentVector(null,(2),(5),cljs.core.PersistentVector.EMPTY_NODE,[p1__2_SHARP_,cljs.core.symbol.call(null,[cljs.core.str(\"PConstants/\"),cljs.core.str(quil.util.prepare_quil_name.call(null,p1__2_SHARP_))].join(''))],null));\n}),constants));\n});\nquil.util.prepare_quil_cljs_constants = (function quil$util$prepare_quil_cljs_constants(constants){\nreturn cljs.core.into.call(null,cljs.core.PersistentArrayMap.EMPTY,cljs.core.map.call(null,(function (p1__3_SHARP_){\nreturn (new cljs.core.PersistentVector(null,(2),(5),cljs.core.PersistentVector.EMPTY_NODE,[p1__3_SHARP_,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"aget\",\"aget\",(1491056546),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"js\",\"Processing.prototype.PConstants\",\"js/Processing.prototype.PConstants\",(2034048972),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,quil.util.prepare_quil_name.call(null,p1__3_SHARP_))))],null));\n}),constants));\n});\nquil.util.make_quil_constant_map = (function quil$util$make_quil_constant_map(target,const_map_name,const_map){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"def\",\"def\",(597100991),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,const_map_name),cljs.core._conj.call(null,cljs.core.List.EMPTY,((cljs.core._EQ_.call(null,target,new cljs.core.Keyword(null,\"clj\",\"clj\",(-660495428))))?quil.util.prepare_quil_clj_constants.call(null,const_map):quil.util.prepare_quil_cljs_constants.call(null,const_map)))));\n});\nquil.util.generate_quil_constants = (function quil$util$generate_quil_constants(var_args){\nvar args__3281__auto__ = [];\nvar len__3279__auto___39 = arguments.length;\nvar i__3280__auto___40 = (0);\nwhile(true){\nif((i__3280__auto___40 < len__3279__auto___39)){\nargs__3281__auto__.push((arguments[i__3280__auto___40]));\n\nvar G__41 = (i__3280__auto___40 + (1));\ni__3280__auto___40 = G__41;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__3282__auto__ = ((((3) < args__3281__auto__.length))?(new cljs.core.IndexedSeq(args__3281__auto__.slice((3)),(0),null)):null);\nreturn quil.util.generate_quil_constants.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__3282__auto__);\n});\n\nquil.util.generate_quil_constants.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,target,opts){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"do\",\"do\",(1686842252),null)),cljs.core.map.call(null,(function (p1__4_SHARP_){\nreturn quil.util.make_quil_constant_map.call(null,target,cljs.core.first.call(null,p1__4_SHARP_),cljs.core.second.call(null,p1__4_SHARP_));\n}),cljs.core.partition.call(null,(2),opts))));\n});\n\nquil.util.generate_quil_constants.cljs$lang$maxFixedArity = (3);\n\nquil.util.generate_quil_constants.cljs$lang$applyTo = (function (seq35){\nvar G__36 = cljs.core.first.call(null,seq35);\nvar seq35__$1 = cljs.core.next.call(null,seq35);\nvar G__37 = cljs.core.first.call(null,seq35__$1);\nvar seq35__$2 = cljs.core.next.call(null,seq35__$1);\nvar G__38 = cljs.core.first.call(null,seq35__$2);\nvar seq35__$3 = cljs.core.next.call(null,seq35__$2);\nreturn quil.util.generate_quil_constants.cljs$core$IFn$_invoke$arity$variadic(G__36,G__37,G__38,seq35__$3);\n});\n\nquil.util.generate_quil_constants.cljs$lang$macro = true;\n"}, {:name quil.sketch, :macros true} {:cache {:use-macros nil, :excludes #{}, :name quil.sketch$macros, :imports nil, :requires nil, :uses nil, :defs {wrap-fns {:protocol-inline nil, :meta {:file quil.sketch, :line 7, :column 7, :end-line 7, :end-column 15, :arglists (quote ([opts])), :doc "Wrap fns allows dynamic redefinition of function such as draw, update\n  in cljs. This is achieved by wrapping all provided functions to\n  anonymous functions such that 'my-draw' function turns into\n  (fn [& args] (apply my-draw args)). This adds a level of indirection\n  so that when quil calls draw, it invokes anonymous function which in\n  turn always calls my-draw by name and if you redefine - new version\n  will be used. Hence we need this cryptic macro."}, :name quil.sketch$macros/wrap-fns, :variadic false, :file nil, :end-column 15, :method-params ([opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7, :end-line 7, :max-fixed-arity 1, :fn-var true, :arglists (quote ([opts])), :doc "Wrap fns allows dynamic redefinition of function such as draw, update\n  in cljs. This is achieved by wrapping all provided functions to\n  anonymous functions such that 'my-draw' function turns into\n  (fn [& args] (apply my-draw args)). This adds a level of indirection\n  so that when quil calls draw, it invokes anonymous function which in\n  turn always calls my-draw by name and if you redefine - new version\n  will be used. Hence we need this cryptic macro."}, defsketch {:protocol-inline nil, :meta {:file quil.sketch, :line 22, :column 11, :end-line 22, :end-column 20, :macro true, :arglists (quote ([app-name & options])), :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env app-name options)], :arglists ([&form &env app-name & options]), :arglists-meta (nil)}}, :name quil.sketch$macros/defsketch, :variadic true, :file nil, :end-column 20, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env app-name options)], :arglists ([&form &env app-name & options]), :arglists-meta (nil)}, :method-params [(&form &env app-name options)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 22, :macro true, :end-line 22, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env app-name & options])}, with-sketch {:protocol-inline nil, :meta {:file quil.sketch, :line 3, :column 11, :end-line 3, :end-column 22, :macro true, :arglists (quote ([applet & body])), :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env applet body)], :arglists ([&form &env applet & body]), :arglists-meta (nil)}}, :name quil.sketch$macros/with-sketch, :variadic true, :file nil, :end-column 22, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env applet body)], :arglists ([&form &env applet & body]), :arglists-meta (nil)}, :method-params [(&form &env applet body)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 3, :macro true, :end-line 3, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env applet & body])}}, :require-macros nil, :cljs.analyzer/constants {:seen #{p1__5__6__auto__ & :features fn? quil.sketch/*applet* = :fn args fn do when-not defn :export if :host some fn* :host-id :no-start binding quil.sketch/add-sketch-to-init-list apply quil.sketch/sketch}, :order [binding quil.sketch/*applet* if fn? fn & args apply :host do defn :export quil.sketch/sketch when-not some fn* p1__5__6__auto__ = :no-start :features quil.sketch/add-sketch-to-init-list :fn :host-id]}, :doc nil}, :source "goog.provide(\"quil.sketch$macros\");\nquil.sketch$macros.with_sketch = (function quil$sketch$macros$with_sketch(var_args){\nvar args__3281__auto__ = [];\nvar len__3279__auto___46 = arguments.length;\nvar i__3280__auto___47 = (0);\nwhile(true){\nif((i__3280__auto___47 < len__3279__auto___46)){\nargs__3281__auto__.push((arguments[i__3280__auto___47]));\n\nvar G__48 = (i__3280__auto___47 + (1));\ni__3280__auto___47 = G__48;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__3282__auto__ = ((((3) < args__3281__auto__.length))?(new cljs.core.IndexedSeq(args__3281__auto__.slice((3)),(0),null)):null);\nreturn quil.sketch$macros.with_sketch.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__3282__auto__);\n});\n\nquil.sketch$macros.with_sketch.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,applet,body){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"binding\",\"binding\",(-2114503176),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.sketch\",\"*applet*\",\"quil.sketch/*applet*\",(-1126699869),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,applet))))),body));\n});\n\nquil.sketch$macros.with_sketch.cljs$lang$maxFixedArity = (3);\n\nquil.sketch$macros.with_sketch.cljs$lang$applyTo = (function (seq42){\nvar G__43 = cljs.core.first.call(null,seq42);\nvar seq42__$1 = cljs.core.next.call(null,seq42);\nvar G__44 = cljs.core.first.call(null,seq42__$1);\nvar seq42__$2 = cljs.core.next.call(null,seq42__$1);\nvar G__45 = cljs.core.first.call(null,seq42__$2);\nvar seq42__$3 = cljs.core.next.call(null,seq42__$2);\nreturn quil.sketch$macros.with_sketch.cljs$core$IFn$_invoke$arity$variadic(G__43,G__44,G__45,seq42__$3);\n});\n\nquil.sketch$macros.with_sketch.cljs$lang$macro = true;\n/**\n * Wrap fns allows dynamic redefinition of function such as draw, update\n *   in cljs. This is achieved by wrapping all provided functions to\n *   anonymous functions such that 'my-draw' function turns into\n *   (fn [& args] (apply my-draw args)). This adds a level of indirection\n *   so that when quil calls draw, it invokes anonymous function which in\n *   turn always calls my-draw by name and if you redefine - new version\n *   will be used. Hence we need this cryptic macro.\n */\nquil.sketch$macros.wrap_fns = (function quil$sketch$macros$wrap_fns(opts){\nreturn cljs.core.into.call(null,cljs.core.PersistentArrayMap.EMPTY,(function (){var iter__3004__auto__ = (function quil$sketch$macros$wrap_fns_$_iter__57(s__58){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar s__58__$1 = s__58;\nwhile(true){\nvar temp__2279__auto__ = cljs.core.seq.call(null,s__58__$1);\nif(temp__2279__auto__){\nvar s__58__$2 = temp__2279__auto__;\nif(cljs.core.chunked_seq_QMARK_.call(null,s__58__$2)){\nvar c__3002__auto__ = cljs.core.chunk_first.call(null,s__58__$2);\nvar size__3003__auto__ = cljs.core.count.call(null,c__3002__auto__);\nvar b__60 = cljs.core.chunk_buffer.call(null,size__3003__auto__);\nif((function (){var i__59 = (0);\nwhile(true){\nif((i__59 < size__3003__auto__)){\nvar vec__63 = cljs.core._nth.call(null,c__3002__auto__,i__59);\nvar k = cljs.core.nth.call(null,vec__63,(0),null);\nvar v = cljs.core.nth.call(null,vec__63,(1),null);\ncljs.core.chunk_append.call(null,b__60,(((v instanceof cljs.core.Symbol))?new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [k,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"if\",\"if\",(1181717262),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"fn?\",\"fn?\",(1820990818),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,v)))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"fn\",\"fn\",(465265323),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"&\",\"&\",(-2144855648),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"args\",\"args\",(-1338879193),null)))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"apply\",\"apply\",(-1334050276),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,v),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"args\",\"args\",(-1338879193),null)))))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,v)))], null):new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [k,v], null)));\n\nvar G__65 = (i__59 + (1));\ni__59 = G__65;\ncontinue;\n} else {\nreturn true;\n}\nbreak;\n}\n})()){\nreturn cljs.core.chunk_cons.call(null,cljs.core.chunk.call(null,b__60),quil$sketch$macros$wrap_fns_$_iter__57.call(null,cljs.core.chunk_rest.call(null,s__58__$2)));\n} else {\nreturn cljs.core.chunk_cons.call(null,cljs.core.chunk.call(null,b__60),null);\n}\n} else {\nvar vec__64 = cljs.core.first.call(null,s__58__$2);\nvar k = cljs.core.nth.call(null,vec__64,(0),null);\nvar v = cljs.core.nth.call(null,vec__64,(1),null);\nreturn cljs.core.cons.call(null,(((v instanceof cljs.core.Symbol))?new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [k,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"if\",\"if\",(1181717262),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"fn?\",\"fn?\",(1820990818),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,v)))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"fn\",\"fn\",(465265323),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"&\",\"&\",(-2144855648),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"args\",\"args\",(-1338879193),null)))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"apply\",\"apply\",(-1334050276),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,v),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"args\",\"args\",(-1338879193),null)))))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,v)))], null):new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [k,v], null)),quil$sketch$macros$wrap_fns_$_iter__57.call(null,cljs.core.rest.call(null,s__58__$2)));\n}\n} else {\nreturn null;\n}\nbreak;\n}\n}),null,null));\n});\nreturn iter__3004__auto__.call(null,opts);\n})());\n});\nquil.sketch$macros.defsketch = (function quil$sketch$macros$defsketch(var_args){\nvar args__3281__auto__ = [];\nvar len__3279__auto___70 = arguments.length;\nvar i__3280__auto___71 = (0);\nwhile(true){\nif((i__3280__auto___71 < len__3279__auto___70)){\nargs__3281__auto__.push((arguments[i__3280__auto___71]));\n\nvar G__72 = (i__3280__auto___71 + (1));\ni__3280__auto___71 = G__72;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__3282__auto__ = ((((3) < args__3281__auto__.length))?(new cljs.core.IndexedSeq(args__3281__auto__.slice((3)),(0),null)):null);\nreturn quil.sketch$macros.defsketch.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__3282__auto__);\n});\n\nquil.sketch$macros.defsketch.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,app_name,options){\nvar raw_opts = cljs.core.apply.call(null,cljs.core.hash_map,options);\nvar opts = quil.sketch$macros.wrap_fns.call(null,cljs.core.merge.call(null,new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"host\",\"host\",(-1558485167)),[cljs.core.str(app_name)].join('')], null),raw_opts));\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"do\",\"do\",(1686842252),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"defn\",\"defn\",(-126010802),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.vary_meta.call(null,app_name,cljs.core.assoc,new cljs.core.Keyword(null,\"export\",\"export\",(214356590)),true)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null)))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.sketch\",\"sketch\",\"quil.sketch/sketch\",(-934423233),null)),cljs.core.apply.call(null,cljs.core.concat,cljs.core.seq.call(null,opts)))))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"when-not\",\"when-not\",(-1223136340),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"some\",\"some\",(-310548046),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"fn*\",\"fn*\",(-752876845),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"p1__5__6__auto__\",\"p1__5__6__auto__\",(1788844416),null)))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"=\",\"=\",(-1501502141),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Keyword(null,\"no-start\",\"no-start\",(1381488856))),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"p1__5__6__auto__\",\"p1__5__6__auto__\",(1788844416),null)))))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Keyword(null,\"features\",\"features\",(-1146962336)).cljs$core$IFn$_invoke$arity$1(opts))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.sketch\",\"add-sketch-to-init-list\",\"quil.sketch/add-sketch-to-init-list\",(-205126918),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.apply.call(null,cljs.core.array_map,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Keyword(null,\"fn\",\"fn\",(-1175266204))),cljs.core._conj.call(null,cljs.core.List.EMPTY,app_name),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Keyword(null,\"host-id\",\"host-id\",(742376279))),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Keyword(null,\"host\",\"host\",(-1558485167)).cljs$core$IFn$_invoke$arity$1(opts))))))))))))));\n});\n\nquil.sketch$macros.defsketch.cljs$lang$maxFixedArity = (3);\n\nquil.sketch$macros.defsketch.cljs$lang$applyTo = (function (seq66){\nvar G__67 = cljs.core.first.call(null,seq66);\nvar seq66__$1 = cljs.core.next.call(null,seq66);\nvar G__68 = cljs.core.first.call(null,seq66__$1);\nvar seq66__$2 = cljs.core.next.call(null,seq66__$1);\nvar G__69 = cljs.core.first.call(null,seq66__$2);\nvar seq66__$3 = cljs.core.next.call(null,seq66__$2);\nreturn quil.sketch$macros.defsketch.cljs$core$IFn$_invoke$arity$variadic(G__67,G__68,G__69,seq66__$3);\n});\n\nquil.sketch$macros.defsketch.cljs$lang$macro = true;\n"}, {:name quil.util, :macros true} {:cache {:use-macros nil, :excludes #{}, :name quil.util$macros, :imports nil, :requires {cstr clojure.string, clojure.string clojure.string}, :uses nil, :defs {clj-compilation? {:protocol-inline nil, :meta {:file quil.util, :line 71, :column 7, :end-line 71, :end-column 23, :arglists (quote ([]))}, :name quil.util$macros/clj-compilation?, :variadic false, :file nil, :end-column 23, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 71, :end-line 71, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, make-quil-constant-map {:protocol-inline nil, :meta {:file quil.util, :line 98, :column 7, :end-line 98, :end-column 29, :arglists (quote ([target const-map-name const-map]))}, :name quil.util$macros/make-quil-constant-map, :variadic false, :file nil, :end-column 29, :method-params ([target const-map-name const-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 98, :end-line 98, :max-fixed-arity 3, :fn-var true, :arglists (quote ([target const-map-name const-map]))}, print-definition-list {:protocol-inline nil, :meta {:file quil.util, :line 60, :column 7, :end-line 60, :end-column 28, :arglists (quote ([definitions]))}, :name quil.util$macros/print-definition-list, :variadic false, :file nil, :end-column 28, :method-params ([definitions]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 60, :end-line 60, :max-fixed-arity 1, :fn-var true, :arglists (quote ([definitions]))}, generate-quil-constants {:protocol-inline nil, :meta {:file quil.util, :line 105, :column 11, :end-line 105, :end-column 34, :macro true, :arglists (quote ([target & opts])), :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env target opts)], :arglists ([&form &env target & opts]), :arglists-meta (nil)}}, :name quil.util$macros/generate-quil-constants, :variadic true, :file nil, :end-column 34, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env target opts)], :arglists ([&form &env target & opts]), :arglists-meta (nil)}, :method-params [(&form &env target opts)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 105, :macro true, :end-line 105, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env target & opts])}, resolve-constant-key {:protocol-inline nil, :meta {:file quil.util, :line 27, :column 7, :end-line 27, :end-column 27, :arglists (quote ([key mappings])), :doc "Returns the val associated with key in mappings or key directly if it\n  is one of the vals in mappings. Otherwise throws an exception."}, :name quil.util$macros/resolve-constant-key, :variadic false, :file nil, :end-column 27, :method-params ([key mappings]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 27, :end-line 27, :max-fixed-arity 2, :fn-var true, :arglists (quote ([key mappings])), :doc "Returns the val associated with key in mappings or key directly if it\n  is one of the vals in mappings. Otherwise throws an exception."}, no-fn {:protocol-inline nil, :meta {:file quil.util, :line 5, :column 7, :end-line 5, :end-column 12, :arglists (quote ([])), :doc "Function that does nothing."}, :name quil.util$macros/no-fn, :variadic false, :file nil, :end-column 12, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5, :end-line 5, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Function that does nothing."}, prepare-quil-clj-constants {:protocol-inline nil, :meta {:file quil.util, :line 86, :column 7, :end-line 86, :end-column 33, :arglists (quote ([constants]))}, :name quil.util$macros/prepare-quil-clj-constants, :variadic false, :file nil, :end-column 33, :method-params ([constants]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 86, :end-line 86, :max-fixed-arity 1, :fn-var true, :arglists (quote ([constants]))}, prepare-quil-cljs-constants {:protocol-inline nil, :meta {:file quil.util, :line 92, :column 7, :end-line 92, :end-column 34, :arglists (quote ([constants]))}, :name quil.util$macros/prepare-quil-cljs-constants, :variadic false, :file nil, :end-column 34, :method-params ([constants]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 92, :end-line 92, :max-fixed-arity 1, :fn-var true, :arglists (quote ([constants]))}, length-of-longest-key {:protocol-inline nil, :meta {:file quil.util, :line 39, :column 8, :end-line 39, :end-column 29, :private true, :arglists (quote ([m])), :doc "Returns the length of the longest key of map m. Assumes m's keys are strings\n   and returns 0 if map is empty:\n   (length-of-longest-key {\"foo\" 1 \"barr\" 2 \"bazzz\" 3}) ;=> 5\n   (length-of-longest-key {}) ;=> 0"}, :private true, :name quil.util$macros/length-of-longest-key, :variadic false, :file nil, :end-column 29, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 39, :end-line 39, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns the length of the longest key of map m. Assumes m's keys are strings\n   and returns 0 if map is empty:\n   (length-of-longest-key {\"foo\" 1 \"barr\" 2 \"bazzz\" 3}) ;=> 5\n   (length-of-longest-key {}) ;=> 0"}, gen-padding {:protocol-inline nil, :meta {:private true, :file quil.util, :end-column 19, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([len] [len pad] [s len pad]), :arglists ([len] [len pad] [s len pad]), :arglists-meta (nil nil nil)}, :column 8, :line 48, :end-line 48, :arglists (quote ([len] [len pad] [s len pad])), :doc "Generates a padding string starting concatting s with len times pad:\n   (gen-padding \"\" 5 \"b\") ;=> \"bbbbb\"\n   May be called without starting string s in which case it defaults to the\n   empty string and also without pad in which case it defaults to a single space"}, :private true, :name quil.util$macros/gen-padding, :variadic false, :file nil, :end-column 19, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([len] [len pad] [s len pad]), :arglists ([len] [len pad] [s len pad]), :arglists-meta (nil nil nil)}, :method-params ([len] [len pad] [s len pad]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 48, :end-line 48, :max-fixed-arity 3, :fn-var true, :arglists ([len] [len pad] [s len pad]), :doc "Generates a padding string starting concatting s with len times pad:\n   (gen-padding \"\" 5 \"b\") ;=> \"bbbbb\"\n   May be called without starting string s in which case it defaults to the\n   empty string and also without pad in which case it defaults to a single space"}, prepare-quil-name {:protocol-inline nil, :meta {:file quil.util, :line 81, :column 7, :end-line 81, :end-column 24, :arglists (quote ([const-keyword]))}, :name quil.util$macros/prepare-quil-name, :variadic false, :file nil, :end-column 24, :method-params ([const-keyword]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 81, :end-line 81, :max-fixed-arity 1, :fn-var true, :arglists (quote ([const-keyword]))}}, :require-macros nil, :cljs.analyzer/constants {:seen #{:else aget js/Processing.prototype.PConstants def :clj do}, :order [:else aget js/Processing.prototype.PConstants def :clj do]}, :doc nil}, :source "goog.provide(\"quil.util$macros\");\n/**\n * Function that does nothing.\n */\nquil.util$macros.no_fn = (function quil$util$macros$no_fn(){\nreturn null;\n});\n/**\n * Returns the val associated with key in mappings or key directly if it\n *   is one of the vals in mappings. Otherwise throws an exception.\n */\nquil.util$macros.resolve_constant_key = (function quil$util$macros$resolve_constant_key(key,mappings){\nif(cljs.core.truth_(cljs.core.get.call(null,mappings,key))){\nreturn cljs.core.get.call(null,mappings,key);\n} else {\nif(cljs.core.truth_(cljs.core.some.call(null,cljs.core.PersistentHashSet.fromArray([key], true),cljs.core.vals.call(null,mappings)))){\nreturn key;\n} else {\nthrow (new Error([cljs.core.str(\"Expecting a keyword, got: \"),cljs.core.str(key),cljs.core.str(\". Expected one of: \"),cljs.core.str(cljs.core.vec.call(null,cljs.core.sort.call(null,cljs.core.keys.call(null,mappings))))].join('')));\n\n}\n}\n});\n/**\n * Returns the length of the longest key of map m. Assumes m's keys are strings\n * and returns 0 if map is empty:\n * (length-of-longest-key {\"foo\" 1 \"barr\" 2 \"bazzz\" 3}) ;=> 5\n * (length-of-longest-key {}) ;=> 0\n */\nquil.util$macros.length_of_longest_key = (function quil$util$macros$length_of_longest_key(m){\nvar or__2423__auto__ = cljs.core.last.call(null,cljs.core.sort.call(null,cljs.core.map.call(null,(function (p1__7_SHARP_){\nreturn p1__7_SHARP_.length();\n}),cljs.core.keys.call(null,m))));\nif(cljs.core.truth_(or__2423__auto__)){\nreturn or__2423__auto__;\n} else {\nreturn (0);\n}\n});\n/**\n * Generates a padding string starting concatting s with len times pad:\n * (gen-padding \"\" 5 \"b\") ;=> \"bbbbb\"\n * May be called without starting string s in which case it defaults to the\n * empty string and also without pad in which case it defaults to a single space\n */\nquil.util$macros.gen_padding = (function quil$util$macros$gen_padding(var_args){\nvar args73 = [];\nvar len__3279__auto___76 = arguments.length;\nvar i__3280__auto___77 = (0);\nwhile(true){\nif((i__3280__auto___77 < len__3279__auto___76)){\nargs73.push((arguments[i__3280__auto___77]));\n\nvar G__78 = (i__3280__auto___77 + (1));\ni__3280__auto___77 = G__78;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__75 = args73.length;\nswitch (G__75) {\ncase (1):\nreturn quil.util$macros.gen_padding.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.util$macros.gen_padding.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.util$macros.gen_padding.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args73.length)].join('')));\n\n}\n});\n\nquil.util$macros.gen_padding.cljs$core$IFn$_invoke$arity$1 = (function (len){\nreturn quil.util$macros.gen_padding.call(null,\"\",len,\" \");\n});\n\nquil.util$macros.gen_padding.cljs$core$IFn$_invoke$arity$2 = (function (len,pad){\nreturn quil.util$macros.gen_padding.call(null,\"\",len,pad);\n});\n\nquil.util$macros.gen_padding.cljs$core$IFn$_invoke$arity$3 = (function (s,len,pad){\nif((len > (0))){\nreturn quil.util$macros.gen_padding.call(null,[cljs.core.str(s),cljs.core.str(pad)].join(''),(len - (1)),pad);\n} else {\nreturn s;\n}\n});\n\nquil.util$macros.gen_padding.cljs$lang$maxFixedArity = (3);\nquil.util$macros.print_definition_list = (function quil$util$macros$print_definition_list(definitions){\nvar longest_key = quil.util$macros.length_of_longest_key.call(null,definitions);\nreturn cljs.core.dorun.call(null,cljs.core.map.call(null,((function (longest_key){\nreturn (function (p__82){\nvar vec__83 = p__82;\nvar k = cljs.core.nth.call(null,vec__83,(0),null);\nvar v = cljs.core.nth.call(null,vec__83,(1),null);\nvar len = k.length();\nvar diff = (longest_key - len);\nvar pad = quil.util$macros.gen_padding.call(null,diff);\nreturn cljs.core.println.call(null,k,pad,\"- \",v);\n});})(longest_key))\n,definitions));\n});\nquil.util$macros.clj_compilation_QMARK_ = (function quil$util$macros$clj_compilation_QMARK_(){\nreturn false;\n});\nquil.util$macros.prepare_quil_name = (function quil$util$macros$prepare_quil_name(const_keyword){\nreturn clojure.string.replace.call(null,clojure.string.upper_case.call(null,cljs.core.name.call(null,const_keyword)),/-/,\"_\");\n});\nquil.util$macros.prepare_quil_clj_constants = (function quil$util$macros$prepare_quil_clj_constants(constants){\nreturn cljs.core.into.call(null,cljs.core.PersistentArrayMap.EMPTY,cljs.core.map.call(null,(function (p1__8_SHARP_){\nreturn (new cljs.core.PersistentVector(null,(2),(5),cljs.core.PersistentVector.EMPTY_NODE,[p1__8_SHARP_,cljs.core.symbol.call(null,[cljs.core.str(\"PConstants/\"),cljs.core.str(quil.util$macros.prepare_quil_name.call(null,p1__8_SHARP_))].join(''))],null));\n}),constants));\n});\nquil.util$macros.prepare_quil_cljs_constants = (function quil$util$macros$prepare_quil_cljs_constants(constants){\nreturn cljs.core.into.call(null,cljs.core.PersistentArrayMap.EMPTY,cljs.core.map.call(null,(function (p1__9_SHARP_){\nreturn (new cljs.core.PersistentVector(null,(2),(5),cljs.core.PersistentVector.EMPTY_NODE,[p1__9_SHARP_,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"aget\",\"aget\",(1491056546),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"js\",\"Processing.prototype.PConstants\",\"js/Processing.prototype.PConstants\",(2034048972),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,quil.util$macros.prepare_quil_name.call(null,p1__9_SHARP_))))],null));\n}),constants));\n});\nquil.util$macros.make_quil_constant_map = (function quil$util$macros$make_quil_constant_map(target,const_map_name,const_map){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"def\",\"def\",(597100991),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,const_map_name),cljs.core._conj.call(null,cljs.core.List.EMPTY,((cljs.core._EQ_.call(null,target,new cljs.core.Keyword(null,\"clj\",\"clj\",(-660495428))))?quil.util$macros.prepare_quil_clj_constants.call(null,const_map):quil.util$macros.prepare_quil_cljs_constants.call(null,const_map)))));\n});\nquil.util$macros.generate_quil_constants = (function quil$util$macros$generate_quil_constants(var_args){\nvar args__3281__auto__ = [];\nvar len__3279__auto___88 = arguments.length;\nvar i__3280__auto___89 = (0);\nwhile(true){\nif((i__3280__auto___89 < len__3279__auto___88)){\nargs__3281__auto__.push((arguments[i__3280__auto___89]));\n\nvar G__90 = (i__3280__auto___89 + (1));\ni__3280__auto___89 = G__90;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__3282__auto__ = ((((3) < args__3281__auto__.length))?(new cljs.core.IndexedSeq(args__3281__auto__.slice((3)),(0),null)):null);\nreturn quil.util$macros.generate_quil_constants.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__3282__auto__);\n});\n\nquil.util$macros.generate_quil_constants.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,target,opts){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"do\",\"do\",(1686842252),null)),cljs.core.map.call(null,(function (p1__10_SHARP_){\nreturn quil.util$macros.make_quil_constant_map.call(null,target,cljs.core.first.call(null,p1__10_SHARP_),cljs.core.second.call(null,p1__10_SHARP_));\n}),cljs.core.partition.call(null,(2),opts))));\n});\n\nquil.util$macros.generate_quil_constants.cljs$lang$maxFixedArity = (3);\n\nquil.util$macros.generate_quil_constants.cljs$lang$applyTo = (function (seq84){\nvar G__85 = cljs.core.first.call(null,seq84);\nvar seq84__$1 = cljs.core.next.call(null,seq84);\nvar G__86 = cljs.core.first.call(null,seq84__$1);\nvar seq84__$2 = cljs.core.next.call(null,seq84__$1);\nvar G__87 = cljs.core.first.call(null,seq84__$2);\nvar seq84__$3 = cljs.core.next.call(null,seq84__$2);\nreturn quil.util$macros.generate_quil_constants.cljs$core$IFn$_invoke$arity$variadic(G__85,G__86,G__87,seq84__$3);\n});\n\nquil.util$macros.generate_quil_constants.cljs$lang$macro = true;\n"}, {:name quil.core, :macros true} {:cache {:use-macros nil, :excludes #{}, :name quil.core$macros, :imports nil, :requires {clojure.string clojure.string, org.processingjs.Processing org.processingjs.Processing, ap quil.sketch, quil.sketch quil.sketch, u quil.util, quil.util quil.util}, :uses nil, :defs {rotate-x {:category "Transform", :protocol-inline nil, :meta {:category "Transform", :added "1.0", :subcategory nil, :file quil.core, :end-column 11, :processing-name "rotateX()", :column 3, :requires-bindings true, :line 3417, :end-line 3417, :arglists (quote ([angle])), :doc "Rotates a shape around the x-axis the amount specified by the angle\n  parameter. Angles should be specified in radians (values from 0 to\n  (* PI 2)) or converted to radians with the radians function. Objects\n  are always rotated around their relative position to the origin and\n  positive numbers rotate objects in a counterclockwise\n  direction. Transformations apply to everything that happens after\n  and subsequent calls to the function accumulates the effect. For\n  example, calling (rotate-x HALF-PI) and then (rotate-x HALF-PI) is\n  the same as (rotate-x PI). If rotate-x is called within the draw fn,\n  the transformation is reset when the loop begins again. This\n  function requires either the :p3d or :opengl renderer."}, :added "1.0", :name quil.core$macros/rotate-x, :variadic false, :subcategory nil, :file nil, :end-column 11, :processing-name "rotateX()", :method-params ([angle]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3411, :end-line 3417, :max-fixed-arity 1, :fn-var true, :arglists (quote ([angle])), :doc "Rotates a shape around the x-axis the amount specified by the angle\n  parameter. Angles should be specified in radians (values from 0 to\n  (* PI 2)) or converted to radians with the radians function. Objects\n  are always rotated around their relative position to the origin and\n  positive numbers rotate objects in a counterclockwise\n  direction. Transformations apply to everything that happens after\n  and subsequent calls to the function accumulates the effect. For\n  example, calling (rotate-x HALF-PI) and then (rotate-x HALF-PI) is\n  the same as (rotate-x PI). If rotate-x is called within the draw fn,\n  the transformation is reset when the loop begins again. This\n  function requires either the :p3d or :opengl renderer."}, text-modes {:name quil.core$macros/text-modes, :file nil, :line 45, :column 1, :end-line 68, :end-column 12, :meta {:file quil.core, :line 68, :column 2, :end-line 68, :end-column 12}}, print-projection {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Camera", :file quil.core, :end-column 19, :processing-name "printProjection()", :column 3, :requires-bindings true, :line 3049, :end-line 3049, :arglists (quote ([])), :doc "Prints the current projection matrix to std out. Useful for\n  debugging"}, :added "1.0", :name quil.core$macros/print-projection, :variadic false, :subcategory "Camera", :file nil, :end-column 19, :processing-name "printProjection()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3043, :end-line 3049, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Prints the current projection matrix to std out. Useful for\n  debugging"}, raw-key {:category "Input", :protocol-inline nil, :meta {:category "Input", :added "1.0", :subcategory "Keyboard", :file quil.core, :end-column 10, :processing-name "key", :column 3, :requires-bindings true, :line 3210, :end-line 3210, :arglists (quote ([])), :doc "Contains the value of the most recent key on the keyboard that was\n  used (either pressed or released).\n\n  For non-ASCII keys, use the keyCode variable. The keys included in\n  the ASCII specification (BACKSPACE, TAB, ENTER, RETURN, ESC, and\n  DELETE) do not require checking to see if they key is coded, and you\n  should simply use the key variable instead of keyCode If you're\n  making cross-platform projects, note that the ENTER key is commonly\n  used on PCs and Unix and the RETURN key is used instead on\n  Macintosh. Check for both ENTER and RETURN to make sure your program\n  will work for all platforms."}, :added "1.0", :name quil.core$macros/raw-key, :variadic false, :subcategory "Keyboard", :file nil, :end-column 10, :processing-name "key", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3204, :end-line 3210, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Contains the value of the most recent key on the keyboard that was\n  used (either pressed or released).\n\n  For non-ASCII keys, use the keyCode variable. The keys included in\n  the ASCII specification (BACKSPACE, TAB, ENTER, RETURN, ESC, and\n  DELETE) do not require checking to see if they key is coded, and you\n  should simply use the key variable instead of keyCode If you're\n  making cross-platform projects, note that the ENTER key is commonly\n  used on PCs and Unix and the RETURN key is used instead on\n  Macintosh. Check for both ENTER and RETURN to make sure your program\n  will work for all platforms."}, text-char {:category "Typography", :protocol-inline nil, :meta {:category "Typography", :added "1.0", :subcategory "Loading & Displaying", :file quil.core, :end-column 12, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([c x y] [c x y z]), :arglists ([c x y] [c x y z]), :arglists-meta (nil nil)}, :processing-name "text()", :column 3, :requires-bindings true, :line 4097, :end-line 4097, :arglists (quote ([c x y] [c x y z])), :doc "Draws a char to the screen in the specified position. See text fn\n  for more details."}, :added "1.0", :name quil.core$macros/text-char, :variadic false, :subcategory "Loading & Displaying", :file nil, :end-column 12, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([c x y] [c x y z]), :arglists ([c x y] [c x y z]), :arglists-meta (nil nil)}, :processing-name "text()", :method-params ([c x y] [c x y z]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 4091, :end-line 4097, :max-fixed-arity 4, :fn-var true, :arglists ([c x y] [c x y z]), :doc "Draws a char to the screen in the specified position. See text fn\n  for more details."}, display-filter {:category "Image", :protocol-inline nil, :meta {:category "Image", :added "1.0", :subcategory "Pixels", :file quil.core, :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([mode] [mode level]), :arglists ([mode] [mode level]), :arglists-meta (nil nil)}, :processing-name "filter()", :column 3, :requires-bindings true, :line 1757, :end-line 1757, :arglists (quote ([mode] [mode level])), :doc "Originally named filter in Processing Language.\n  Filters the display window with the specified mode and level.\n  Level defines the quality of the filter and mode may be one of the\n  following keywords:\n\n  :threshold - converts the image to black and white pixels depending\n               if they are above or below the threshold defined by\n               the level parameter. The level must be between\n               0.0 (black) and 1.0 (white). If no level is specified,\n               0.5 is used.\n  :gray      - converts any colors in the image to grayscale\n               equivalents. Doesn't work with level.\n  :invert    - sets each pixel to its inverse value. Doesn't work with\n               level.\n  :posterize - limits each channel of the image to the number of\n               colors specified as the level parameter. The parameter can\n               be set to values between 2 and 255, but results are most\n               noticeable in the lower ranges.\n  :blur      - executes a Guassian blur with the level parameter\n               specifying the extent of the blurring. If no level\n               parameter is used, the blur is equivalent to Guassian\n               blur of radius 1.\n  :opaque    - sets the alpha channel to entirely opaque. Doesn't work\n               with level.\n  :erode     - reduces the light areas. Doesn't work with level.\n  :dilate    - increases the light areas.  Doesn't work with level."}, :added "1.0", :name quil.core$macros/display-filter, :variadic false, :subcategory "Pixels", :file nil, :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([mode] [mode level]), :arglists ([mode] [mode level]), :arglists-meta (nil nil)}, :processing-name "filter()", :method-params ([mode] [mode level]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1751, :end-line 1757, :max-fixed-arity 2, :fn-var true, :arglists ([mode] [mode level]), :doc "Originally named filter in Processing Language.\n  Filters the display window with the specified mode and level.\n  Level defines the quality of the filter and mode may be one of the\n  following keywords:\n\n  :threshold - converts the image to black and white pixels depending\n               if they are above or below the threshold defined by\n               the level parameter. The level must be between\n               0.0 (black) and 1.0 (white). If no level is specified,\n               0.5 is used.\n  :gray      - converts any colors in the image to grayscale\n               equivalents. Doesn't work with level.\n  :invert    - sets each pixel to its inverse value. Doesn't work with\n               level.\n  :posterize - limits each channel of the image to the number of\n               colors specified as the level parameter. The parameter can\n               be set to values between 2 and 255, but results are most\n               noticeable in the lower ranges.\n  :blur      - executes a Guassian blur with the level parameter\n               specifying the extent of the blurring. If no level\n               parameter is used, the blur is equivalent to Guassian\n               blur of radius 1.\n  :opaque    - sets the alpha channel to entirely opaque. Doesn't work\n               with level.\n  :erode     - reduces the light areas. Doesn't work with level.\n  :dilate    - increases the light areas.  Doesn't work with level."}, rotate-z {:category "Transform", :protocol-inline nil, :meta {:category "Transform", :added "1.0", :subcategory nil, :file quil.core, :end-column 11, :processing-name "rotateZ()", :column 3, :requires-bindings true, :line 3459, :end-line 3459, :arglists (quote ([angle])), :doc "Rotates a shape around the z-axis the amount specified by the angle\n  parameter. Angles should be specified in radians (values from 0\n  to (* PI 2)) or converted to radians with the radians function.\n  Objects are always rotated around their relative position to the\n  origin and positive numbers rotate objects in a counterclockwise\n  direction. Transformations apply to everything that happens after\n  and subsequent calls to the function accumulates the effect. For\n  example, calling (rotate-z HALF-PI) and then (rotate-z HALF-PI) is\n  the same as (rotate-z PI). If rotate-y is called within the draw fn,\n  the transformation is reset when the loop begins again. This\n  function requires either the :p3d or :opengl renderer."}, :added "1.0", :name quil.core$macros/rotate-z, :variadic false, :subcategory nil, :file nil, :end-column 11, :processing-name "rotateZ()", :method-params ([angle]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3453, :end-line 3459, :max-fixed-arity 1, :fn-var true, :arglists (quote ([angle])), :doc "Rotates a shape around the z-axis the amount specified by the angle\n  parameter. Angles should be specified in radians (values from 0\n  to (* PI 2)) or converted to radians with the radians function.\n  Objects are always rotated around their relative position to the\n  origin and positive numbers rotate objects in a counterclockwise\n  direction. Transformations apply to everything that happens after\n  and subsequent calls to the function accumulates the effect. For\n  example, calling (rotate-z HALF-PI) and then (rotate-z HALF-PI) is\n  the same as (rotate-z PI). If rotate-y is called within the draw fn,\n  the transformation is reset when the loop begins again. This\n  function requires either the :p3d or :opengl renderer."}, random-gaussian {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "2.0", :subcategory "Random", :file quil.core, :end-column 18, :processing-name "randomGaussian()", :column 3, :requires-bindings true, :line 3179, :end-line 3179, :arglists (quote ([])), :doc "Returns a float from a random series of numbers having a mean of 0 and\n  standard deviation of 1. Each time the randomGaussian() function is called,\n  it returns a number fitting a Gaussian, or normal, distribution.\n  There is theoretically no minimum or maximum value that randomGaussian()\n  might return. Rather, there is just a very low probability that values far\n  from the mean will be returned; and a higher probability that numbers near\n  the mean will be returned. ."}, :added "2.0", :name quil.core$macros/random-gaussian, :variadic false, :subcategory "Random", :file nil, :end-column 18, :processing-name "randomGaussian()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3173, :end-line 3179, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Returns a float from a random series of numbers having a mean of 0 and\n  standard deviation of 1. Each time the randomGaussian() function is called,\n  it returns a number fitting a Gaussian, or normal, distribution.\n  There is theoretically no minimum or maximum value that randomGaussian()\n  might return. Rather, there is just a very low probability that values far\n  from the mean will be returned; and a higher probability that numbers near\n  the mean will be returned. ."}, blend {:category "Image", :protocol-inline nil, :meta {:category "Image", :added "1.0", :subcategory "Pixels", :file quil.core, :end-column 8, :top-fn {:variadic false, :max-fixed-arity 11, :method-params ([x y width height dx dy dwidth dheight mode] [src-img x y width height dx dy dwidth dheight mode] [src-img dest-img x y width height dx dy dwidth dheight mode]), :arglists ([x y width height dx dy dwidth dheight mode] [src-img x y width height dx dy dwidth dheight mode] [src-img dest-img x y width height dx dy dwidth dheight mode]), :arglists-meta (nil nil nil)}, :processing-name "blend()", :column 3, :requires-bindings true, :line 778, :end-line 778, :arglists (quote ([x y width height dx dy dwidth dheight mode] [src-img x y width height dx dy dwidth dheight mode] [src-img dest-img x y width height dx dy dwidth dheight mode])), :doc "Blends a region of pixels from one image into another with full alpha\n  channel support. If src is not specified it defaults to current-graphics.\n  If dest is not specified it defaults to current-graphics.\n\n  Note: blend-mode function is recommended to use instead of this one.\n\n  Available blend modes are:\n\n  :blend      - linear interpolation of colours: C = A*factor + B\n  :add        - additive blending with white clip:\n                                            C = min(A*factor + B, 255)\n  :subtract   - subtractive blending with black clip:\n                                            C = max(B - A*factor, 0)\n  :darkest    - only the darkest colour succeeds:\n                                            C = min(A*factor, B)\n  :lightest   - only the lightest colour succeeds:\n                                            C = max(A*factor, B)\n  :difference - subtract colors from underlying image.\n  :exclusion  - similar to :difference, but less extreme.\n  :multiply   - Multiply the colors, result will always be darker.\n  :screen     - Opposite multiply, uses inverse values of the colors.\n  :overlay    - A mix of :multiply and :screen. Multiplies dark values\n                and screens light values.\n  :hard-light - :screen when greater than 50% gray, :multiply when\n                lower.\n  :soft-light - Mix of :darkest and :lightest. Works like :overlay,\n                but not as harsh.\n  :dodge      - Lightens light tones and increases contrast, ignores\n                darks.\n                Called \"Color Dodge\" in Illustrator and Photoshop.\n  :burn       - Darker areas are applied, increasing contrast, ignores\n                lights. Called \"Color Burn\" in Illustrator and\n                Photoshop."}, :added "1.0", :name quil.core$macros/blend, :variadic false, :subcategory "Pixels", :file nil, :end-column 8, :top-fn {:variadic false, :max-fixed-arity 11, :method-params ([x y width height dx dy dwidth dheight mode] [src-img x y width height dx dy dwidth dheight mode] [src-img dest-img x y width height dx dy dwidth dheight mode]), :arglists ([x y width height dx dy dwidth dheight mode] [src-img x y width height dx dy dwidth dheight mode] [src-img dest-img x y width height dx dy dwidth dheight mode]), :arglists-meta (nil nil nil)}, :processing-name "blend()", :method-params ([x y width height dx dy dwidth dheight mode] [src-img x y width height dx dy dwidth dheight mode] [src-img dest-img x y width height dx dy dwidth dheight mode]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :requires-bindings true, :line 772, :end-line 778, :max-fixed-arity 11, :fn-var true, :arglists ([x y width height dx dy dwidth dheight mode] [src-img x y width height dx dy dwidth dheight mode] [src-img dest-img x y width height dx dy dwidth dheight mode]), :doc "Blends a region of pixels from one image into another with full alpha\n  channel support. If src is not specified it defaults to current-graphics.\n  If dest is not specified it defaults to current-graphics.\n\n  Note: blend-mode function is recommended to use instead of this one.\n\n  Available blend modes are:\n\n  :blend      - linear interpolation of colours: C = A*factor + B\n  :add        - additive blending with white clip:\n                                            C = min(A*factor + B, 255)\n  :subtract   - subtractive blending with black clip:\n                                            C = max(B - A*factor, 0)\n  :darkest    - only the darkest colour succeeds:\n                                            C = min(A*factor, B)\n  :lightest   - only the lightest colour succeeds:\n                                            C = max(A*factor, B)\n  :difference - subtract colors from underlying image.\n  :exclusion  - similar to :difference, but less extreme.\n  :multiply   - Multiply the colors, result will always be darker.\n  :screen     - Opposite multiply, uses inverse values of the colors.\n  :overlay    - A mix of :multiply and :screen. Multiplies dark values\n                and screens light values.\n  :hard-light - :screen when greater than 50% gray, :multiply when\n                lower.\n  :soft-light - Mix of :darkest and :lightest. Works like :overlay,\n                but not as harsh.\n  :dodge      - Lightens light tones and increases contrast, ignores\n                darks.\n                Called \"Color Dodge\" in Illustrator and Photoshop.\n  :burn       - Darker areas are applied, increasing contrast, ignores\n                lights. Called \"Color Burn\" in Illustrator and\n                Photoshop."}, frame-count {:category "Environment", :protocol-inline nil, :meta {:category "Environment", :added "1.0", :subcategory nil, :file quil.core, :end-column 14, :processing-name "frameCount", :column 3, :requires-bindings true, :line 1833, :end-line 1833, :arglists (quote ([])), :doc "The system variable frameCount contains the number of frames\n  displayed since the program started. Inside setup() the value is 0\n  and after the first iteration of draw it is 1, etc."}, :added "1.0", :name quil.core$macros/frame-count, :variadic false, :subcategory nil, :file nil, :end-column 14, :processing-name "frameCount", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1827, :end-line 1833, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "The system variable frameCount contains the number of frames\n  displayed since the program started. Inside setup() the value is 0\n  and after the first iteration of draw it is 1, etc."}, with-graphics {:category "Rendering", :protocol-inline nil, :meta {:category "Rendering", :added "1.7", :file quil.core, :end-column 16, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env graphics body)], :arglists ([&form &env graphics & body]), :arglists-meta (nil)}, :processing-name nil, :column 3, :requires-bindings true, :line 4662, :macro true, :end-line 4662, :arglists (quote ([graphics & body])), :doc "All subsequent calls of any drawing function will draw on given\n  graphics. 'with-graphics' cannot be nested (you can draw simultaneously\n  only on 1 graphics)"}, :added "1.7", :name quil.core$macros/with-graphics, :variadic true, :file nil, :end-column 16, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env graphics body)], :arglists ([&form &env graphics & body]), :arglists-meta (nil)}, :processing-name nil, :method-params [(&form &env graphics body)], :protocol-impl nil, :arglists-meta (nil), :column 1, :requires-bindings true, :line 4657, :macro true, :end-line 4662, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env graphics & body]), :doc "All subsequent calls of any drawing function will draw on given\n  graphics. 'with-graphics' cannot be nested (you can draw simultaneously\n  only on 1 graphics)"}, model-y {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Coordinates", :file quil.core, :end-column 10, :processing-name "modelY()", :column 3, :requires-bindings true, :line 2517, :end-line 2517, :arglists (quote ([x y z])), :doc "Returns the three-dimensional x, y, z position in model space. This\n  returns the y value for a given coordinate based on the current set\n  of transformations (scale, rotate, translate, etc.) The y value can\n  be used to place an object in space relative to the location of the\n  original point once the transformations are no longer in use."}, :added "1.0", :name quil.core$macros/model-y, :variadic false, :subcategory "Coordinates", :file nil, :end-column 10, :processing-name "modelY()", :method-params ([x y z]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2511, :end-line 2517, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x y z])), :doc "Returns the three-dimensional x, y, z position in model space. This\n  returns the y value for a given coordinate based on the current set\n  of transformations (scale, rotate, translate, etc.) The y value can\n  be used to place an object in space relative to the location of the\n  original point once the transformations are no longer in use."}, set-image {:category "Image", :protocol-inline nil, :meta {:category "Image", :added "1.0", :subcategory "Pixels", :file quil.core, :end-column 12, :processing-name "set()", :column 3, :requires-bindings true, :line 3675, :end-line 3675, :arglists (quote ([x y src])), :doc "Writes an image directly into the display window. The x and y\n  parameters define the coordinates for the upper-left corner of the\n  image."}, :added "1.0", :name quil.core$macros/set-image, :variadic false, :subcategory "Pixels", :file nil, :end-column 12, :processing-name "set()", :method-params ([x y src]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3669, :end-line 3675, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x y src])), :doc "Writes an image directly into the display window. The x and y\n  parameters define the coordinates for the upper-left corner of the\n  image."}, shape-mode {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "Loading & Displaying", :file quil.core, :end-column 13, :processing-name "shapeMode()", :column 3, :requires-bindings true, :line 3778, :end-line 3778, :arglists (quote ([mode])), :doc "Modifies the location from which shapes draw. Available modes are\n  :corner, :corners and :center. Default is :corner.\n\n  :corner  - specifies the location to be the upper left corner of the\n             shape and uses the third and fourth parameters of shape\n             to specify the width and height.\n\n  :corners - uses the first and second parameters of shape to set\n             the location of one corner and uses the third and fourth\n             parameters to set the opposite corner.\n\n  :center  - draws the shape from its center point and uses the third\n             and forth parameters of shape to specify the width and\n             height. "}, :added "1.0", :name quil.core$macros/shape-mode, :variadic false, :subcategory "Loading & Displaying", :file nil, :end-column 13, :processing-name "shapeMode()", :method-params ([mode]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3773, :end-line 3778, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mode])), :doc "Modifies the location from which shapes draw. Available modes are\n  :corner, :corners and :center. Default is :corner.\n\n  :corner  - specifies the location to be the upper left corner of the\n             shape and uses the third and fourth parameters of shape\n             to specify the width and height.\n\n  :corners - uses the first and second parameters of shape to set\n             the location of one corner and uses the third and fourth\n             parameters to set the opposite corner.\n\n  :center  - draws the shape from its center point and uses the third\n             and forth parameters of shape to specify the width and\n             height. "}, cursor-image {:category "Environment", :protocol-inline nil, :meta {:category "Environment", :added "1.0", :subcategory nil, :file quil.core, :end-column 17, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([img] [img hx hy]), :arglists ([img] [img hx hy]), :arglists-meta (nil nil)}, :processing-name "cursor()", :column 5, :requires-bindings true, :line 1307, :end-line 1307, :arglists (quote ([img] [img hx hy])), :doc "Set the cursor to a predefined image. The horizontal and vertical\n  active spots of the cursor may be specified with hx and hy.\n  It is recommended to make the size 16x16 or 32x32 pixels."}, :added "1.0", :name quil.core$macros/cursor-image, :variadic false, :subcategory nil, :file nil, :end-column 17, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([img] [img hx hy]), :arglists ([img] [img hx hy]), :arglists-meta (nil nil)}, :processing-name "cursor()", :method-params ([img] [img hx hy]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1301, :end-line 1307, :max-fixed-arity 3, :fn-var true, :arglists ([img] [img hx hy]), :doc "Set the cursor to a predefined image. The horizontal and vertical\n  active spots of the cursor may be specified with hx and hy.\n  It is recommended to make the size 16x16 or 32x32 pixels."}, create-graphics {:category "Image", :protocol-inline nil, :meta {:category "Image", :added "1.0", :subcategory "Rendering", :file quil.core, :end-column 18, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([w h] [w h renderer] [w h renderer path]), :arglists ([w h] [w h renderer] [w h renderer path]), :arglists-meta (nil nil nil)}, :processing-name "createGraphics()", :column 3, :requires-bindings true, :line 1204, :end-line 1204, :arglists (quote ([w h] [w h renderer] [w h renderer path])), :doc "Creates and returns a new PGraphics object of the types :p2d, :p3d,\n  :java2d, :pdf. By default :java2d is used. Use this class if you\n  need to draw into an off-screen graphics buffer. It's not possible\n  to use create-graphics with the :opengl renderer, because it doesn't\n  allow offscreen use. The :pdf renderer requires the filename parameter.\n\n  Note: don't use create-graphics in draw in clojurescript, it leaks memory.\n  You should create graphic in setup and reuse it in draw instead of creating\n  a new one.\n\n  It's important to call any drawing commands between (.beginDraw graphics) and\n  (.endDraw graphics) statements or use with-graphics macro. This is also true\n  for any commands that affect drawing, such as smooth or color-mode.\n\n  If you're using :pdf renderer - don't forget to call (.dispose graphics)\n  as last command inside with-graphics macro, otherwise graphics won't be\n  saved.\n\n  Unlike the main drawing surface which is completely opaque, surfaces\n  created with create-graphics can have transparency. This makes it\n  possible to draw into a graphics and maintain the alpha channel. By\n  using save to write a PNG or TGA file, the transparency of the\n  graphics object will be honored."}, :added "1.0", :name quil.core$macros/create-graphics, :variadic false, :subcategory "Rendering", :file nil, :end-column 18, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([w h] [w h renderer] [w h renderer path]), :arglists ([w h] [w h renderer] [w h renderer path]), :arglists-meta (nil nil nil)}, :processing-name "createGraphics()", :method-params ([w h] [w h renderer] [w h renderer path]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :requires-bindings true, :line 1198, :end-line 1204, :max-fixed-arity 4, :fn-var true, :arglists ([w h] [w h renderer] [w h renderer path]), :doc "Creates and returns a new PGraphics object of the types :p2d, :p3d,\n  :java2d, :pdf. By default :java2d is used. Use this class if you\n  need to draw into an off-screen graphics buffer. It's not possible\n  to use create-graphics with the :opengl renderer, because it doesn't\n  allow offscreen use. The :pdf renderer requires the filename parameter.\n\n  Note: don't use create-graphics in draw in clojurescript, it leaks memory.\n  You should create graphic in setup and reuse it in draw instead of creating\n  a new one.\n\n  It's important to call any drawing commands between (.beginDraw graphics) and\n  (.endDraw graphics) statements or use with-graphics macro. This is also true\n  for any commands that affect drawing, such as smooth or color-mode.\n\n  If you're using :pdf renderer - don't forget to call (.dispose graphics)\n  as last command inside with-graphics macro, otherwise graphics won't be\n  saved.\n\n  Unlike the main drawing surface which is completely opaque, surfaces\n  created with create-graphics can have transparency. This makes it\n  possible to draw into a graphics and maintain the alpha channel. By\n  using save to write a PNG or TGA file, the transparency of the\n  graphics object will be honored."}, update-pixels {:category "Image", :protocol-inline nil, :meta {:category "Image", :added "1.0", :subcategory "Pixels", :file quil.core, :end-column 16, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [img]), :arglists ([] [img]), :arglists-meta (nil nil)}, :processing-name "updatePixels()", :column 3, :requires-bindings true, :line 4504, :end-line 4504, :arglists (quote ([] [img])), :doc "Updates the display window or image with the data in the pixels array.\n  Use in conjunction with (pixels). If you're only reading pixels from\n  the array, there's no need to call update-pixels unless there are\n  changes.\n\n  Certain renderers may or may not seem to require pixels or\n  update-pixels. However, the rule is that any time you want to\n  manipulate the pixels array, you must first call pixels, and\n  after changes have been made, call update-pixels. Even if the\n  renderer may not seem to use this function in the current Processing\n  release, this will always be subject to change."}, :added "1.0", :name quil.core$macros/update-pixels, :variadic false, :subcategory "Pixels", :file nil, :end-column 16, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [img]), :arglists ([] [img]), :arglists-meta (nil nil)}, :processing-name "updatePixels()", :method-params ([] [img]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 4498, :end-line 4504, :max-fixed-arity 1, :fn-var true, :arglists ([] [img]), :doc "Updates the display window or image with the data in the pixels array.\n  Use in conjunction with (pixels). If you're only reading pixels from\n  the array, there's no need to call update-pixels unless there are\n  changes.\n\n  Certain renderers may or may not seem to require pixels or\n  update-pixels. However, the rule is that any time you want to\n  manipulate the pixels array, you must first call pixels, and\n  after changes have been made, call update-pixels. Even if the\n  renderer may not seem to use this function in the current Processing\n  release, this will always be subject to change."}, text-size {:category "Typography", :protocol-inline nil, :meta {:category "Typography", :added "1.0", :subcategory "Attributes", :file quil.core, :end-column 12, :processing-name "textSize()", :column 3, :requires-bindings true, :line 4289, :end-line 4289, :arglists (quote ([size])), :doc "Sets the current font size. This size will be used in all\n  subsequent calls to the text fn. Font size is measured in\n  units of pixels."}, :added "1.0", :name quil.core$macros/text-size, :variadic false, :subcategory "Attributes", :file nil, :end-column 12, :processing-name "textSize()", :method-params ([size]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 4283, :end-line 4289, :max-fixed-arity 1, :fn-var true, :arglists (quote ([size])), :doc "Sets the current font size. This size will be used in all\n  subsequent calls to the text fn. Font size is measured in\n  units of pixels."}, pixels {:category "Image", :protocol-inline nil, :meta {:category "Image", :added "1.0", :subcategory "Pixels", :file quil.core, :end-column 9, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [img]), :arglists ([] [img]), :arglists-meta (nil nil)}, :processing-name "pixels[]", :column 3, :requires-bindings true, :line 2899, :end-line 2899, :arglists (quote ([] [img])), :doc "Array containing the values for all the pixels in the display\n  window or image. This array is therefore the size of the display window. If\n  this array is modified, the update-pixels fn must be called to update\n  the changes. Calls .loadPixels before obtaining the pixel array."}, :added "1.0", :name quil.core$macros/pixels, :variadic false, :subcategory "Pixels", :file nil, :end-column 9, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [img]), :arglists ([] [img]), :arglists-meta (nil nil)}, :processing-name "pixels[]", :method-params ([] [img]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2893, :end-line 2899, :max-fixed-arity 1, :fn-var true, :arglists ([] [img]), :doc "Array containing the values for all the pixels in the display\n  window or image. This array is therefore the size of the display window. If\n  this array is modified, the update-pixels fn must be called to update\n  the changes. Calls .loadPixels before obtaining the pixel array."}, stroke-float {:category "Color", :protocol-inline nil, :meta {:category "Color", :added "1.0", :subcategory "Setting", :file quil.core, :end-column 15, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([gray] [gray alpha] [x y z] [x y z a]), :arglists ([gray] [gray alpha] [x y z] [x y z a]), :arglists-meta (nil nil nil nil)}, :processing-name "stroke()", :column 3, :requires-bindings true, :line 3969, :end-line 3969, :arglists (quote ([gray] [gray alpha] [x y z] [x y z a])), :doc "Sets the color used to draw lines and borders around\n  shapes. Converts all args to floats"}, :added "1.0", :name quil.core$macros/stroke-float, :variadic false, :subcategory "Setting", :file nil, :end-column 15, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([gray] [gray alpha] [x y z] [x y z a]), :arglists ([gray] [gray alpha] [x y z] [x y z a]), :arglists-meta (nil nil nil nil)}, :processing-name "stroke()", :method-params ([gray] [gray alpha] [x y z] [x y z a]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :requires-bindings true, :line 3963, :end-line 3969, :max-fixed-arity 4, :fn-var true, :arglists ([gray] [gray alpha] [x y z] [x y z a]), :doc "Sets the color used to draw lines and borders around\n  shapes. Converts all args to floats"}, constrain {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Calculation", :file quil.core, :end-column 12, :processing-name "constrain()", :column 3, :requires-bindings false, :line 1097, :end-line 1097, :arglists (quote ([amt low high])), :doc "Constrains a value to not exceed a maximum and minimum value."}, :added "1.0", :name quil.core$macros/constrain, :variadic false, :subcategory "Calculation", :file nil, :end-column 12, :processing-name "constrain()", :method-params ([amt low high]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 1091, :end-line 1097, :max-fixed-arity 3, :fn-var true, :arglists (quote ([amt low high])), :doc "Constrains a value to not exceed a maximum and minimum value."}, screen-y {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Coordinates", :file quil.core, :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([x y] [x y z]), :arglists ([x y] [x y z]), :arglists-meta (nil nil)}, :processing-name "screenY()", :column 3, :requires-bindings true, :line 3608, :end-line 3608, :arglists (quote ([x y] [x y z])), :doc "Takes a three-dimensional x, y, z position and returns the y value\n  for where it will appear on a (two-dimensional) screen, once\n  affected by translate, scale or any other transformations"}, :added "1.0", :name quil.core$macros/screen-y, :variadic false, :subcategory "Coordinates", :file nil, :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([x y] [x y z]), :arglists ([x y] [x y z]), :arglists-meta (nil nil)}, :processing-name "screenY()", :method-params ([x y] [x y z]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3602, :end-line 3608, :max-fixed-arity 3, :fn-var true, :arglists ([x y] [x y z]), :doc "Takes a three-dimensional x, y, z position and returns the y value\n  for where it will appear on a (two-dimensional) screen, once\n  affected by translate, scale or any other transformations"}, fill-float {:category "Color", :protocol-inline nil, :meta {:category "Color", :added "1.0", :subcategory "Setting", :file quil.core, :end-column 13, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([gray] [gray alpha] [r g b] [r g b alpha]), :arglists ([gray] [gray alpha] [r g b] [r g b alpha]), :arglists-meta (nil nil nil nil)}, :processing-name "fill()", :column 3, :requires-bindings true, :line 1685, :end-line 1685, :arglists (quote ([gray] [gray alpha] [r g b] [r g b alpha])), :doc "Sets the color used to fill shapes. For example, (fill 204 102 0),\n  will specify that all subsequent shapes will be filled with orange."}, :added "1.0", :name quil.core$macros/fill-float, :variadic false, :subcategory "Setting", :file nil, :end-column 13, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([gray] [gray alpha] [r g b] [r g b alpha]), :arglists ([gray] [gray alpha] [r g b] [r g b alpha]), :arglists-meta (nil nil nil nil)}, :processing-name "fill()", :method-params ([gray] [gray alpha] [r g b] [r g b alpha]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :requires-bindings true, :line 1679, :end-line 1685, :max-fixed-arity 4, :fn-var true, :arglists ([gray] [gray alpha] [r g b] [r g b alpha]), :doc "Sets the color used to fill shapes. For example, (fill 204 102 0),\n  will specify that all subsequent shapes will be filled with orange."}, rect {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "2D Primitives", :file quil.core, :end-column 7, :top-fn {:variadic false, :max-fixed-arity 8, :method-params ([x y width height] [x y width height r] [x y width height top-left-r top-right-r bottom-right-r bottom-left-r]), :arglists ([x y width height] [x y width height r] [x y width height top-left-r top-right-r bottom-right-r bottom-left-r]), :arglists-meta (nil nil nil)}, :processing-name "rect()", :column 3, :requires-bindings true, :line 3231, :end-line 3231, :arglists (quote ([x y width height] [x y width height r] [x y width height top-left-r top-right-r bottom-right-r bottom-left-r])), :doc "Draws a rectangle to the screen. A rectangle is a four-sided shape\n  with every angle at ninety degrees. By default, the first two\n  parameters set the location of the upper-left corner, the third\n  sets the width, and the fourth sets the height. These parameters\n  may be changed with rect-mode.\n\n  To draw a rounded rectangle, add a fifth parameter, which is used as\n  the radius value for all four corners. To use a different radius value\n  for each corner, include eight parameters."}, :added "1.0", :name quil.core$macros/rect, :variadic false, :subcategory "2D Primitives", :file nil, :end-column 7, :top-fn {:variadic false, :max-fixed-arity 8, :method-params ([x y width height] [x y width height r] [x y width height top-left-r top-right-r bottom-right-r bottom-left-r]), :arglists ([x y width height] [x y width height r] [x y width height top-left-r top-right-r bottom-right-r bottom-left-r]), :arglists-meta (nil nil nil)}, :processing-name "rect()", :method-params ([x y width height] [x y width height r] [x y width height top-left-r top-right-r bottom-right-r bottom-left-r]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :requires-bindings true, :line 3225, :end-line 3231, :max-fixed-arity 8, :fn-var true, :arglists ([x y width height] [x y width height r] [x y width height top-left-r top-right-r bottom-right-r bottom-left-r]), :doc "Draws a rectangle to the screen. A rectangle is a four-sided shape\n  with every angle at ninety degrees. By default, the first two\n  parameters set the location of the upper-left corner, the third\n  sets the width, and the fourth sets the height. These parameters\n  may be changed with rect-mode.\n\n  To draw a rounded rectangle, add a fifth parameter, which is used as\n  the radius value for all four corners. To use a different radius value\n  for each corner, include eight parameters."}, log {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Calculation", :file quil.core, :end-column 6, :processing-name "log()", :column 3, :requires-bindings false, :line 2407, :end-line 2407, :arglists (quote ([val])), :doc "Calculates the natural logarithm (the base-e logarithm) of a\n  number. This function expects the values greater than 0.0."}, :added "1.0", :name quil.core$macros/log, :variadic false, :subcategory "Calculation", :file nil, :end-column 6, :processing-name "log()", :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 2401, :end-line 2407, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :doc "Calculates the natural logarithm (the base-e logarithm) of a\n  number. This function expects the values greater than 0.0."}, with-stroke {:category "Color", :protocol-inline nil, :meta {:category "Color", :added "1.7", :subcategory "Utility Macros", :file quil.core, :end-column 15, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env stroke-args body)], :arglists ([&form &env stroke-args & body]), :arglists-meta (nil)}, :processing-name nil, :column 4, :requires-bindings true, :line 4604, :macro true, :end-line 4604, :arglists (quote ([stroke-args & body])), :doc "Temporarily set the stroke color for the body of this macro.\n   The code outside of with-stroke form will have the previous stroke color set.\n\n   The stroke color has to be in a vector!\n   Example: (with-stroke [255] ...)\n            (with-stroke [10 80 98] ...)"}, :added "1.7", :name quil.core$macros/with-stroke, :variadic true, :subcategory "Utility Macros", :file nil, :end-column 15, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env stroke-args body)], :arglists ([&form &env stroke-args & body]), :arglists-meta (nil)}, :processing-name nil, :method-params [(&form &env stroke-args body)], :protocol-impl nil, :arglists-meta (nil), :column 1, :requires-bindings true, :line 4598, :macro true, :end-line 4604, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env stroke-args & body]), :doc "Temporarily set the stroke color for the body of this macro.\n   The code outside of with-stroke form will have the previous stroke color set.\n\n   The stroke color has to be in a vector!\n   Example: (with-stroke [255] ...)\n            (with-stroke [10 80 98] ...)"}, ambient-float {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Material Properties", :file quil.core, :end-column 16, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([gray] [x y z]), :arglists ([gray] [x y z]), :arglists-meta (nil nil)}, :processing-name "ambient()", :column 3, :requires-bindings true, :line 324, :end-line 324, :arglists (quote ([gray] [x y z])), :doc "Sets the ambient reflectance for shapes drawn to the screen. This\n  is combined with the ambient light component of environment. The\n  color components set through the parameters define the\n  reflectance. For example in the default color mode, setting x=255,\n  y=126, z=0, would cause all the red light to reflect and half of the\n  green light to reflect. Used in combination with emissive, specular,\n  and shininess in setting the material properties of shapes."}, :added "1.0", :name quil.core$macros/ambient-float, :variadic false, :subcategory "Material Properties", :file nil, :end-column 16, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([gray] [x y z]), :arglists ([gray] [x y z]), :arglists-meta (nil nil)}, :processing-name "ambient()", :method-params ([gray] [x y z]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 318, :end-line 324, :max-fixed-arity 3, :fn-var true, :arglists ([gray] [x y z]), :doc "Sets the ambient reflectance for shapes drawn to the screen. This\n  is combined with the ambient light component of environment. The\n  color components set through the parameters define the\n  reflectance. For example in the default color mode, setting x=255,\n  y=126, z=0, would cause all the red light to reflect and half of the\n  green light to reflect. Used in combination with emissive, specular,\n  and shininess in setting the material properties of shapes."}, end-raw {:category "Output", :protocol-inline nil, :meta {:category "Output", :added "1.0", :subcategory "Files", :file quil.core, :end-column 10, :processing-name "endRaw()", :column 3, :requires-bindings true, :line 1619, :end-line 1619, :arglists (quote ([])), :doc "Complement to begin-raw; they must always be used together. See\n  the begin-raw docstring for details."}, :added "1.0", :name quil.core$macros/end-raw, :variadic false, :subcategory "Files", :file nil, :end-column 10, :processing-name "endRaw()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1613, :end-line 1619, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Complement to begin-raw; they must always be used together. See\n  the begin-raw docstring for details."}, radians {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Trigonometry", :file quil.core, :end-column 10, :processing-name "radians()", :column 3, :requires-bindings false, :line 3141, :end-line 3141, :arglists (quote ([degrees]))}, :added "1.0", :name quil.core$macros/radians, :variadic false, :subcategory "Trigonometry", :file nil, :end-column 10, :processing-name "radians()", :method-params ([degrees]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 3135, :end-line 3141, :max-fixed-arity 1, :fn-var true, :arglists (quote ([degrees]))}, degrees {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Trigonometry", :file quil.core, :end-column 10, :processing-name "degrees()", :column 3, :requires-bindings false, :line 1438, :end-line 1438, :arglists (quote ([radians]))}, :added "1.0", :name quil.core$macros/degrees, :variadic false, :subcategory "Trigonometry", :file nil, :end-column 10, :processing-name "degrees()", :method-params ([radians]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 1432, :end-line 1438, :max-fixed-arity 1, :fn-var true, :arglists (quote ([radians]))}, acos {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Trigonometry", :file quil.core, :end-column 7, :processing-name "acos()", :column 3, :requires-bindings false, :line 299, :end-line 299, :arglists (quote ([n])), :doc "The inverse of cos, returns the arc cosine of a value. This\n  function expects the values in the range of -1 to 1 and values are\n  returned in the range 0 to Math/PI (3.1415927)."}, :added "1.0", :name quil.core$macros/acos, :variadic false, :subcategory "Trigonometry", :file nil, :end-column 7, :processing-name "acos()", :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 293, :end-line 299, :max-fixed-arity 1, :fn-var true, :arglists (quote ([n])), :doc "The inverse of cos, returns the arc cosine of a value. This\n  function expects the values in the range of -1 to 1 and values are\n  returned in the range 0 to Math/PI (3.1415927)."}, bezier-detail {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "Curves", :file quil.core, :end-column 16, :processing-name "bezierDetail()", :column 3, :requires-bindings true, :line 692, :end-line 692, :arglists (quote ([detail])), :doc "Sets the resolution at which Beziers display. The default value is\n  20. This function is only useful when using the :p3d or :opengl\n  renderer as the default (:java2d) renderer does not use this\n  information."}, :added "1.0", :name quil.core$macros/bezier-detail, :variadic false, :subcategory "Curves", :file nil, :end-column 16, :processing-name "bezierDetail()", :method-params ([detail]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 686, :end-line 692, :max-fixed-arity 1, :fn-var true, :arglists (quote ([detail])), :doc "Sets the resolution at which Beziers display. The default value is\n  20. This function is only useful when using the :p3d or :opengl\n  renderer as the default (:java2d) renderer does not use this\n  information."}, texture {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "Vertex", :file quil.core, :end-column 10, :processing-name "texture()", :column 3, :requires-bindings true, :line 4302, :end-line 4302, :arglists (quote ([img])), :doc "Sets a texture to be applied to vertex points. The texture fn must\n  be called between begin-shape and end-shape and before any calls to\n  vertex.\n\n  When textures are in use, the fill color is ignored. Instead, use\n  tint to specify the color of the texture as it is applied to the\n  shape."}, :added "1.0", :name quil.core$macros/texture, :variadic false, :subcategory "Vertex", :file nil, :end-column 10, :processing-name "texture()", :method-params ([img]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 4296, :end-line 4302, :max-fixed-arity 1, :fn-var true, :arglists (quote ([img])), :doc "Sets a texture to be applied to vertex points. The texture fn must\n  be called between begin-shape and end-shape and before any calls to\n  vertex.\n\n  When textures are in use, the fill color is ignored. Instead, use\n  tint to specify the color of the texture as it is applied to the\n  shape."}, stroke-int {:category "Color", :protocol-inline nil, :meta {:category "Color", :added "1.0", :subcategory "Setting", :file quil.core, :end-column 13, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([rgb] [rgb alpha]), :arglists ([rgb] [rgb alpha]), :arglists-meta (nil nil)}, :processing-name "stroke()", :column 3, :requires-bindings true, :line 3983, :end-line 3983, :arglists (quote ([rgb] [rgb alpha])), :doc "Sets the color used to draw lines and borders around\n  shapes. Converts rgb to int and alpha to a float."}, :added "1.0", :name quil.core$macros/stroke-int, :variadic false, :subcategory "Setting", :file nil, :end-column 13, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([rgb] [rgb alpha]), :arglists ([rgb] [rgb alpha]), :arglists-meta (nil nil)}, :processing-name "stroke()", :method-params ([rgb] [rgb alpha]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3977, :end-line 3983, :max-fixed-arity 2, :fn-var true, :arglists ([rgb] [rgb alpha]), :doc "Sets the color used to draw lines and borders around\n  shapes. Converts rgb to int and alpha to a float."}, print-camera {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Camera", :file quil.core, :end-column 15, :processing-name "printCamera()", :column 3, :requires-bindings true, :line 3027, :end-line 3027, :arglists (quote ([])), :doc "Prints the current camera matrix to std out. Useful for debugging."}, :added "1.0", :name quil.core$macros/print-camera, :variadic false, :subcategory "Camera", :file nil, :end-column 15, :processing-name "printCamera()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3021, :end-line 3027, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Prints the current camera matrix to std out. Useful for debugging."}, floor {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "2.0", :subcategory "Calculation", :file quil.core, :end-column 8, :processing-name "floor()", :column 3, :requires-bindings false, :line 1810, :end-line 1810, :arglists (quote ([n])), :doc "Calculates the closest int value that is less than or equal to the\n  value of the parameter. For example, (floor 9.03) returns the value 9."}, :added "2.0", :name quil.core$macros/floor, :variadic false, :subcategory "Calculation", :file nil, :end-column 8, :processing-name "floor()", :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 1804, :end-line 1810, :max-fixed-arity 1, :fn-var true, :arglists (quote ([n])), :doc "Calculates the closest int value that is less than or equal to the\n  value of the parameter. For example, (floor 9.03) returns the value 9."}, atan2 {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Trigonometry", :file quil.core, :end-column 8, :processing-name "atan2()", :column 3, :requires-bindings false, :line 473, :end-line 473, :arglists (quote ([y x])), :doc "Calculates the angle (in radians) from a specified point to the\n  coordinate origin as measured from the positive x-axis. Values are\n  returned as a float in the range from PI to -PI. The atan2 function\n  is most often used for orienting geometry to the position of the\n  cursor. Note: The y-coordinate of the point is the first parameter\n  and the x-coordinate is the second due to the structure of\n  calculating the tangent."}, :added "1.0", :name quil.core$macros/atan2, :variadic false, :subcategory "Trigonometry", :file nil, :end-column 8, :processing-name "atan2()", :method-params ([y x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 467, :end-line 473, :max-fixed-arity 2, :fn-var true, :arglists (quote ([y x])), :doc "Calculates the angle (in radians) from a specified point to the\n  coordinate origin as measured from the positive x-axis. Values are\n  returned as a float in the range from PI to -PI. The atan2 function\n  is most often used for orienting geometry to the position of the\n  cursor. Note: The y-coordinate of the point is the first parameter\n  and the x-coordinate is the second due to the structure of\n  calculating the tangent."}, millis {:category "Input", :protocol-inline nil, :meta {:category "Input", :added "1.0", :subcategory "Time & Date", :file quil.core, :end-column 9, :processing-name "millis()", :column 3, :requires-bindings true, :line 2477, :end-line 2477, :arglists (quote ([])), :doc "Returns the number of milliseconds (thousandths of a second) since\n  starting the sketch. This information is often used for timing\n  animation sequences."}, :added "1.0", :name quil.core$macros/millis, :variadic false, :subcategory "Time & Date", :file nil, :end-column 9, :processing-name "millis()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2471, :end-line 2477, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Returns the number of milliseconds (thousandths of a second) since\n  starting the sketch. This information is often used for timing\n  animation sequences."}, lerp-color {:category "Color", :protocol-inline nil, :meta {:category "Color", :added "1.0", :subcategory "Creating & Reading", :file quil.core, :end-column 13, :processing-name "lerpColor()", :column 3, :requires-bindings true, :line 2232, :end-line 2232, :arglists (quote ([c1 c2 amt])), :doc "Calculates a color or colors between two color at a specific\n  increment. The amt parameter is the amount to interpolate between\n  the two values where 0.0 equal to the first point, 0.1 is very near\n  the first point, 0.5 is half-way in between, etc."}, :added "1.0", :name quil.core$macros/lerp-color, :variadic false, :subcategory "Creating & Reading", :file nil, :end-column 13, :processing-name "lerpColor()", :method-params ([c1 c2 amt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2226, :end-line 2232, :max-fixed-arity 3, :fn-var true, :arglists (quote ([c1 c2 amt])), :doc "Calculates a color or colors between two color at a specific\n  increment. The amt parameter is the amount to interpolate between\n  the two values where 0.0 equal to the first point, 0.1 is very near\n  the first point, 0.5 is half-way in between, etc."}, image-modes {:name quil.core$macros/image-modes, :file nil, :line 45, :column 1, :end-line 61, :end-column 13, :meta {:file quil.core, :line 61, :column 2, :end-line 61, :end-column 13}}, no-fill-prop {:name quil.core$macros/no-fill-prop, :file nil, :line 24, :column 1, :end-line 24, :end-column 35, :private true, :meta {:file quil.core, :line 24, :column 23, :end-line 24, :end-column 35, :private true}}, color-mode {:category "Color", :protocol-inline nil, :meta {:category "Color", :added "1.0", :subcategory "Creating & Reading", :file quil.core, :end-column 13, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([mode] [mode max] [mode max-x max-y max-z] [mode max-x max-y max-z max-a]), :arglists ([mode] [mode max] [mode max-x max-y max-z] [mode max-x max-y max-z max-a]), :arglists-meta (nil nil nil nil)}, :processing-name "colorMode()", :column 3, :requires-bindings true, :line 1041, :end-line 1041, :arglists (quote ([mode] [mode max] [mode max-x max-y max-z] [mode max-x max-y max-z max-a])), :doc "Changes the way Processing interprets color data. Available modes\n  are :rgb and :hsb.By default, the parameters for fill, stroke,\n  background, and color are defined by values between 0 and 255 using\n  the :rgb color model. The color-mode fn is used to change the\n  numerical range used for specifying colors and to switch color\n  systems. For example, calling\n  (color-mode :rgb 1.0) will specify that values are specified between\n  0 and 1. The limits for defining colors are altered by setting the\n  parameters range1, range2, range3, and range 4."}, :added "1.0", :name quil.core$macros/color-mode, :variadic false, :subcategory "Creating & Reading", :file nil, :end-column 13, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([mode] [mode max] [mode max-x max-y max-z] [mode max-x max-y max-z max-a]), :arglists ([mode] [mode max] [mode max-x max-y max-z] [mode max-x max-y max-z max-a]), :arglists-meta (nil nil nil nil)}, :processing-name "colorMode()", :method-params ([mode] [mode max] [mode max-x max-y max-z] [mode max-x max-y max-z max-a]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :requires-bindings true, :line 1035, :end-line 1041, :max-fixed-arity 5, :fn-var true, :arglists ([mode] [mode max] [mode max-x max-y max-z] [mode max-x max-y max-z max-a]), :doc "Changes the way Processing interprets color data. Available modes\n  are :rgb and :hsb.By default, the parameters for fill, stroke,\n  background, and color are defined by values between 0 and 255 using\n  the :rgb color model. The color-mode fn is used to change the\n  numerical range used for specifying colors and to switch color\n  systems. For example, calling\n  (color-mode :rgb 1.0) will specify that values are specified between\n  0 and 1. The limits for defining colors are altered by setting the\n  parameters range1, range2, range3, and range 4."}, create-image {:category "Image", :protocol-inline nil, :meta {:category "Image", :added "1.0", :subcategory nil, :file quil.core, :end-column 15, :processing-name "createImage()", :column 3, :requires-bindings true, :line 1243, :end-line 1243, :arglists (quote ([w h format])), :doc "Creates a new PImage (the datatype for storing images). This\n  provides a fresh buffer of pixels to play with. Set the size of the\n  buffer with the width and height parameters. The format parameter\n  defines how the pixels are stored. See the PImage reference for more\n  information.\n\n  Possible formats: :rgb, :argb, :alpha (grayscale alpha channel)\n\n  Prefer using create-image over initialising new PImage instances\n  directly."}, :added "1.0", :name quil.core$macros/create-image, :variadic false, :subcategory nil, :file nil, :end-column 15, :processing-name "createImage()", :method-params ([w h format]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1237, :end-line 1243, :max-fixed-arity 3, :fn-var true, :arglists (quote ([w h format])), :doc "Creates a new PImage (the datatype for storing images). This\n  provides a fresh buffer of pixels to play with. Set the size of the\n  buffer with the width and height parameters. The format parameter\n  defines how the pixels are stored. See the PImage reference for more\n  information.\n\n  Possible formats: :rgb, :argb, :alpha (grayscale alpha channel)\n\n  Prefer using create-image over initialising new PImage instances\n  directly."}, sq {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Calculation", :file quil.core, :end-column 5, :processing-name "sq()", :column 3, :requires-bindings false, :line 3928, :end-line 3928, :arglists (quote ([a])), :doc "Squares a number (multiplies a number by itself). The result is\n  always a positive number, as multiplying two negative numbers always\n  yields a positive result. For example, -1 * -1 = 1."}, :added "1.0", :name quil.core$macros/sq, :variadic false, :subcategory "Calculation", :file nil, :end-column 5, :processing-name "sq()", :method-params ([a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 3922, :end-line 3928, :max-fixed-arity 1, :fn-var true, :arglists (quote ([a])), :doc "Squares a number (multiplies a number by itself). The result is\n  always a positive number, as multiplying two negative numbers always\n  yields a positive result. For example, -1 * -1 = 1."}, height {:category "Environment", :protocol-inline nil, :meta {:category "Environment", :added "1.0", :subcategory nil, :file quil.core, :end-column 9, :processing-name "getHeight()", :column 3, :processing-link nil, :requires-bindings true, :line 1950, :end-line 1950, :arglists (quote ([])), :doc "Height of the display window. The value of height is zero until\n  size is called."}, :added "1.0", :name quil.core$macros/height, :variadic false, :subcategory nil, :file nil, :end-column 9, :processing-name "getHeight()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :processing-link nil, :requires-bindings true, :line 1943, :end-line 1950, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Height of the display window. The value of height is zero until\n  size is called."}, no-loop {:category "Structure", :protocol-inline nil, :meta {:category "Structure", :added "1.0", :subcategory nil, :file quil.core, :end-column 10, :processing-name "noLoop()", :column 3, :requires-bindings true, :line 2750, :end-line 2750, :arglists (quote ([])), :doc "Stops Processing from continuously executing the code within\n  draw. If start-loop is called, the code in draw will begin to run\n  continuously again. If using no-loop in setup, it should be the last\n  line inside the block.\n\n  When no-loop is used, it's not possible to manipulate or access the\n  screen inside event handling functions such as mouse-pressed or\n  key-pressed. Instead, use those functions to call redraw or\n  loop which will run draw, which can update the screen\n  properly. This means that when no-loop has been called, no drawing\n  can happen, and functions like save-frame may not be used.\n\n  Note that if the sketch is resized, redraw will be called to\n  update the sketch, even after no-oop has been\n  specified. Otherwise, the sketch would enter an odd state until\n  loop was called."}, :added "1.0", :name quil.core$macros/no-loop, :variadic false, :subcategory nil, :file nil, :end-column 10, :processing-name "noLoop()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2744, :end-line 2750, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Stops Processing from continuously executing the code within\n  draw. If start-loop is called, the code in draw will begin to run\n  continuously again. If using no-loop in setup, it should be the last\n  line inside the block.\n\n  When no-loop is used, it's not possible to manipulate or access the\n  screen inside event handling functions such as mouse-pressed or\n  key-pressed. Instead, use those functions to call redraw or\n  loop which will run draw, which can update the screen\n  properly. This means that when no-loop has been called, no drawing\n  can happen, and functions like save-frame may not be used.\n\n  Note that if the sketch is resized, redraw will be called to\n  update the sketch, even after no-oop has been\n  specified. Otherwise, the sketch would enter an odd state until\n  loop was called."}, minute {:category "Input", :protocol-inline nil, :meta {:category "Input", :added "1.0", :subcategory "Time & Date", :file quil.core, :end-column 9, :processing-name "minute()", :column 3, :requires-bindings false, :line 2490, :end-line 2490, :arglists (quote ([])), :doc "Returns the current minute as a value from 0 - 59"}, :added "1.0", :name quil.core$macros/minute, :variadic false, :subcategory "Time & Date", :file nil, :end-column 9, :processing-name "minute()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 2484, :end-line 2490, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Returns the current minute as a value from 0 - 59"}, text {:category "Typography", :protocol-inline nil, :meta {:category "Typography", :added "1.0", :subcategory "Loading & Displaying", :file quil.core, :end-column 7, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([s x y] [s x y z] [s x1 y1 x2 y2]), :arglists ([s x y] [s x y z] [s x1 y1 x2 y2]), :arglists-meta (nil nil nil)}, :processing-name "text()", :column 3, :requires-bindings true, :line 4129, :end-line 4129, :arglists (quote ([s x y] [s x y z] [s x1 y1 x2 y2])), :doc "Draws text to the screen in the position specified by the x and y\n  parameters and the optional z parameter. A default font will be used\n  unless a font is set with the text-font fn. Change the color of the\n  text with the fill fn. The text displays in relation to the\n  text-align fn, which gives the option to draw to the left, right, and\n  center of the coordinates.\n\n  The x1, y1, x2 and y2 parameters define a\n  rectangular area to display within and may only be used with string\n  data. For text drawn inside a rectangle, the coordinates are\n  interpreted based on the current rect-mode setting."}, :added "1.0", :name quil.core$macros/text, :variadic false, :subcategory "Loading & Displaying", :file nil, :end-column 7, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([s x y] [s x y z] [s x1 y1 x2 y2]), :arglists ([s x y] [s x y z] [s x1 y1 x2 y2]), :arglists-meta (nil nil nil)}, :processing-name "text()", :method-params ([s x y] [s x y z] [s x1 y1 x2 y2]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :requires-bindings true, :line 4123, :end-line 4129, :max-fixed-arity 5, :fn-var true, :arglists ([s x y] [s x y z] [s x1 y1 x2 y2]), :doc "Draws text to the screen in the position specified by the x and y\n  parameters and the optional z parameter. A default font will be used\n  unless a font is set with the text-font fn. Change the color of the\n  text with the fill fn. The text displays in relation to the\n  text-align fn, which gives the option to draw to the left, right, and\n  center of the coordinates.\n\n  The x1, y1, x2 and y2 parameters define a\n  rectangular area to display within and may only be used with string\n  data. For text drawn inside a rectangle, the coordinates are\n  interpreted based on the current rect-mode setting."}, available-fonts {:category "Typography", :protocol-inline nil, :meta {:category "Typography", :added "1.0", :subcategory "Loading & Displaying", :file quil.core, :end-column 18, :processing-name "PFont.list()", :column 3, :requires-bindings false, :line 491, :end-line 491, :arglists (quote ([])), :doc "A sequence of strings representing the fonts on this system\n  available for use.\n\n  Because of limitations in Java, not all fonts can be used and some\n  might work with one operating system and not others. When sharing a\n  sketch with other people or posting it on the web, you may need to\n  include a .ttf or .otf version of your font in the data directory of\n  the sketch because other people might not have the font installed on\n  their computer. Only fonts that can legally be distributed should be\n  included with a sketch."}, :added "1.0", :name quil.core$macros/available-fonts, :variadic false, :subcategory "Loading & Displaying", :file nil, :end-column 18, :processing-name "PFont.list()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 485, :end-line 491, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "A sequence of strings representing the fonts on this system\n  available for use.\n\n  Because of limitations in Java, not all fonts can be used and some\n  might work with one operating system and not others. When sharing a\n  sketch with other people or posting it on the web, you may need to\n  include a .ttf or .otf version of your font in the data directory of\n  the sketch because other people might not have the font installed on\n  their computer. Only fonts that can legally be distributed should be\n  included with a sketch."}, rect-modes {:name quil.core$macros/rect-modes, :file nil, :line 45, :column 1, :end-line 62, :end-column 12, :meta {:file quil.core, :line 62, :column 2, :end-line 62, :end-column 12}}, THIRD-PI {:name quil.core$macros/THIRD-PI, :file nil, :line 78, :column 1, :end-line 78, :end-column 14, :meta {:file quil.core, :line 78, :column 6, :end-line 78, :end-column 14}}, binary {:category "Data", :protocol-inline nil, :meta {:category "Data", :require-binding false, :added "1.0", :subcategory "Conversion", :file quil.core, :end-column 9, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([val] [val num-digits]), :arglists ([val] [val num-digits]), :arglists-meta (nil nil)}, :processing-name "binary()", :column 3, :line 761, :end-line 761, :arglists (quote ([val] [val num-digits])), :doc "Returns a string representing the binary value of an int, char or\n  byte. When converting an int to a string, it is possible to specify\n  the number of digits used."}, :require-binding false, :added "1.0", :name quil.core$macros/binary, :variadic false, :subcategory "Conversion", :file nil, :end-column 9, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([val] [val num-digits]), :arglists ([val] [val num-digits]), :arglists-meta (nil nil)}, :processing-name "binary()", :method-params ([val] [val num-digits]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 755, :end-line 761, :max-fixed-arity 2, :fn-var true, :arglists ([val] [val num-digits]), :doc "Returns a string representing the binary value of an int, char or\n  byte. When converting an int to a string, it is possible to specify\n  the number of digits used."}, pop-matrix {:category "Transform", :protocol-inline nil, :meta {:category "Transform", :added "1.0", :subcategory nil, :file quil.core, :end-column 13, :processing-name "popMatrix()", :column 3, :requires-bindings true, :line 2978, :end-line 2978, :arglists (quote ([])), :doc "Pops the current transformation matrix off the matrix\n  stack. Understanding pushing and popping requires understanding the\n  concept of a matrix stack. The push-matrix fn saves the current\n  coordinate system to the stack and pop-matrix restores the prior\n  coordinate system. push-matrix and pop-matrix are used in conjuction\n  with the other transformation methods and may be embedded to control\n  the scope of the transformations."}, :added "1.0", :name quil.core$macros/pop-matrix, :variadic false, :subcategory nil, :file nil, :end-column 13, :processing-name "popMatrix()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2972, :end-line 2978, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Pops the current transformation matrix off the matrix\n  stack. Understanding pushing and popping requires understanding the\n  concept of a matrix stack. The push-matrix fn saves the current\n  coordinate system to the stack and pop-matrix restores the prior\n  coordinate system. push-matrix and pop-matrix are used in conjuction\n  with the other transformation methods and may be embedded to control\n  the scope of the transformations."}, ceil {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Calculation", :file quil.core, :end-column 7, :processing-name "ceil()", :column 3, :requires-bindings false, :line 972, :end-line 972, :arglists (quote ([n])), :doc "Calculates the closest int value that is greater than or equal to\n  the value of the parameter. For example, (ceil 9.03) returns the\n  value 10."}, :added "1.0", :name quil.core$macros/ceil, :variadic false, :subcategory "Calculation", :file nil, :end-column 7, :processing-name "ceil()", :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 966, :end-line 972, :max-fixed-arity 1, :fn-var true, :arglists (quote ([n])), :doc "Calculates the closest int value that is greater than or equal to\n  the value of the parameter. For example, (ceil 9.03) returns the\n  value 10."}, key-code {:category "Input", :protocol-inline nil, :meta {:category "Input", :added "1.0", :subcategory "Keyboard", :file quil.core, :end-column 11, :processing-name "keyCode", :column 3, :requires-bindings true, :line 2148, :end-line 2148, :arglists (quote ([])), :doc "The variable keyCode is used to detect special keys such as the UP,\n  DOWN, LEFT, RIGHT arrow keys and ALT, CONTROL, SHIFT. When checking\n  for these keys, it's first necessary to check and see if the key is\n  coded. This is done with the conditional (= (key) CODED).\n\n  The keys included in the ASCII specification (BACKSPACE, TAB, ENTER,\n  RETURN, ESC, and DELETE) do not require checking to see if they key\n  is coded, and you should simply use the key variable instead of\n  key-code If you're making cross-platform projects, note that the\n  ENTER key is commonly used on PCs and Unix and the RETURN key is\n  used instead on Macintosh. Check for both ENTER and RETURN to make\n  sure your program will work for all platforms.\n\n  For users familiar with Java, the values for UP and DOWN are simply\n  shorter versions of Java's KeyEvent.VK_UP and\n  KeyEvent.VK_DOWN. Other keyCode values can be found in the Java\n  KeyEvent reference."}, :added "1.0", :name quil.core$macros/key-code, :variadic false, :subcategory "Keyboard", :file nil, :end-column 11, :processing-name "keyCode", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2142, :end-line 2148, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "The variable keyCode is used to detect special keys such as the UP,\n  DOWN, LEFT, RIGHT arrow keys and ALT, CONTROL, SHIFT. When checking\n  for these keys, it's first necessary to check and see if the key is\n  coded. This is done with the conditional (= (key) CODED).\n\n  The keys included in the ASCII specification (BACKSPACE, TAB, ENTER,\n  RETURN, ESC, and DELETE) do not require checking to see if they key\n  is coded, and you should simply use the key variable instead of\n  key-code If you're making cross-platform projects, note that the\n  ENTER key is commonly used on PCs and Unix and the RETURN key is\n  used instead on Macintosh. Check for both ENTER and RETURN to make\n  sure your program will work for all platforms.\n\n  For users familiar with Java, the values for UP and DOWN are simply\n  shorter versions of Java's KeyEvent.VK_UP and\n  KeyEvent.VK_DOWN. Other keyCode values can be found in the Java\n  KeyEvent reference."}, sphere {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "3D Primitives", :file quil.core, :end-column 9, :processing-name "sphere()", :column 3, :requires-bindings true, :line 3876, :end-line 3876, :arglists (quote ([radius])), :doc "Generates a hollow ball made from tessellated triangles."}, :added "1.0", :name quil.core$macros/sphere, :variadic false, :subcategory "3D Primitives", :file nil, :end-column 9, :processing-name "sphere()", :method-params ([radius]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3870, :end-line 3876, :max-fixed-arity 1, :fn-var true, :arglists (quote ([radius])), :doc "Generates a hollow ball made from tessellated triangles."}, request-image {:category "Image", :protocol-inline nil, :meta {:category "Image", :added "1.0", :subcategory "Loading & Displaying", :file quil.core, :end-column 16, :processing-name "requestImage()", :column 3, :requires-bindings true, :line 3319, :end-line 3319, :arglists (quote ([filename])), :doc "This function load images on a separate thread so that your sketch\n  does not freeze while images load during setup. While the image is\n  loading, its width and height will be 0. If an error occurs while\n  loading the image, its width and height will be set to -1. You'll\n  know when the image has loaded properly because its width and height\n  will be greater than 0. Asynchronous image loading (particularly\n  when downloading from a server) can dramatically improve\n  performance."}, :added "1.0", :name quil.core$macros/request-image, :variadic false, :subcategory "Loading & Displaying", :file nil, :end-column 16, :processing-name "requestImage()", :method-params ([filename]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3313, :end-line 3319, :max-fixed-arity 1, :fn-var true, :arglists (quote ([filename])), :doc "This function load images on a separate thread so that your sketch\n  does not freeze while images load during setup. While the image is\n  loading, its width and height will be 0. If an error occurs while\n  loading the image, its width and height will be set to -1. You'll\n  know when the image has loaded properly because its width and height\n  will be greater than 0. Asynchronous image loading (particularly\n  when downloading from a server) can dramatically improve\n  performance."}, hue {:category "Color", :protocol-inline nil, :meta {:category "Color", :added "1.0", :subcategory "Creating & Reading", :file quil.core, :end-column 6, :processing-name "hue()", :column 3, :requires-bindings true, :line 2044, :end-line 2044, :arglists (quote ([col])), :doc "Extracts the hue value from a color."}, :added "1.0", :name quil.core$macros/hue, :variadic false, :subcategory "Creating & Reading", :file nil, :end-column 6, :processing-name "hue()", :method-params ([col]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2038, :end-line 2044, :max-fixed-arity 1, :fn-var true, :arglists (quote ([col])), :doc "Extracts the hue value from a color."}, background-int {:category "Color", :protocol-inline nil, :meta {:category "Color", :added "1.0", :subcategory "Setting", :file quil.core, :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([rgb] [rgb alpha]), :arglists ([rgb] [rgb alpha]), :arglists-meta (nil nil)}, :processing-name "background()", :column 3, :requires-bindings true, :line 532, :end-line 532, :arglists (quote ([rgb] [rgb alpha])), :doc "Sets the color used for the background of the Processing\n  window. The default background is light gray. In the draw function,\n  the background color is used to clear the display window at the\n  beginning of each frame.\n\n  It is not possible to use transparency (alpha) in background colors\n  with the main drawing surface, however they will work properly with\n  create-graphics. Converts rgb to an int and alpha to a float."}, :added "1.0", :name quil.core$macros/background-int, :variadic false, :subcategory "Setting", :file nil, :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([rgb] [rgb alpha]), :arglists ([rgb] [rgb alpha]), :arglists-meta (nil nil)}, :processing-name "background()", :method-params ([rgb] [rgb alpha]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 526, :end-line 532, :max-fixed-arity 2, :fn-var true, :arglists ([rgb] [rgb alpha]), :doc "Sets the color used for the background of the Processing\n  window. The default background is light gray. In the draw function,\n  the background color is used to clear the display window at the\n  beginning of each frame.\n\n  It is not possible to use transparency (alpha) in background colors\n  with the main drawing surface, however they will work properly with\n  create-graphics. Converts rgb to an int and alpha to a float."}, start-loop {:category "Structure", :protocol-inline nil, :meta {:category "Structure", :added "1.0", :subcategory nil, :file quil.core, :end-column 13, :processing-name "loop()", :column 3, :requires-bindings true, :line 3957, :end-line 3957, :arglists (quote ([])), :doc "Causes Processing to continuously execute the code within\n  draw. If no-loop is called, the code in draw stops executing."}, :added "1.0", :name quil.core$macros/start-loop, :variadic false, :subcategory nil, :file nil, :end-column 13, :processing-name "loop()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3951, :end-line 3957, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Causes Processing to continuously execute the code within\n  draw. If no-loop is called, the code in draw stops executing."}, no-fill? {:protocol-inline nil, :meta {:file quil.core, :line 4085, :column 8, :end-line 4085, :end-column 16, :private true, :arglists (quote ([graphics])), :doc "Returns whether fill is disabled for current graphics."}, :private true, :name quil.core$macros/no-fill?, :variadic false, :file nil, :end-column 16, :method-params ([graphics]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4085, :end-line 4085, :max-fixed-arity 1, :fn-var true, :arglists (quote ([graphics])), :doc "Returns whether fill is disabled for current graphics."}, curve-vertex {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "Vertex", :file quil.core, :end-column 15, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([x y] [x y z]), :arglists ([x y] [x y z]), :arglists-meta (nil nil)}, :processing-name "curveVertex()", :column 3, :requires-bindings true, :line 1407, :end-line 1407, :arglists (quote ([x y] [x y z])), :doc "Specifies vertex coordinates for curves. This function may only be\n  used between begin-shape and end-shape and only when there is no\n  mode keyword specified to begin-shape. The first and last points in a\n  series of curve-vertex lines will be used to guide the beginning and\n  end of a the curve. A minimum of four points is required to draw a\n  tiny curve between the second and third points. Adding a fifth point\n  with curve-vertex will draw the curve between the second, third, and\n  fourth points. The curve-vertex function is an implementation of\n  Catmull-Rom splines."}, :added "1.0", :name quil.core$macros/curve-vertex, :variadic false, :subcategory "Vertex", :file nil, :end-column 15, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([x y] [x y z]), :arglists ([x y] [x y z]), :arglists-meta (nil nil)}, :processing-name "curveVertex()", :method-params ([x y] [x y z]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1401, :end-line 1407, :max-fixed-arity 3, :fn-var true, :arglists ([x y] [x y z]), :doc "Specifies vertex coordinates for curves. This function may only be\n  used between begin-shape and end-shape and only when there is no\n  mode keyword specified to begin-shape. The first and last points in a\n  series of curve-vertex lines will be used to guide the beginning and\n  end of a the curve. A minimum of four points is required to draw a\n  tiny curve between the second and third points. Adding a fifth point\n  with curve-vertex will draw the curve between the second, third, and\n  fourth points. The curve-vertex function is an implementation of\n  Catmull-Rom splines."}, state-atom {:category "State", :protocol-inline nil, :meta {:category "State", :added "1.0", :subcategory nil, :file quil.core, :end-column 13, :column 3, :requires-bindings true, :line 199, :end-line 199, :arglists (quote ([])), :doc "Retrieve sketch-specific state-atom. All changes to the\n  atom will be reflected in the state.\n\n  (set-state! :foo 1)\n  (state :foo) ;=> 1\n  (swap! (state-atom) update-in [:foo] inc)\n  (state :foo) ;=> 2"}, :added "1.0", :name quil.core$macros/state-atom, :variadic false, :subcategory nil, :file nil, :end-column 13, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 194, :end-line 199, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Retrieve sketch-specific state-atom. All changes to the\n  atom will be reflected in the state.\n\n  (set-state! :foo 1)\n  (state :foo) ;=> 1\n  (swap! (state-atom) update-in [:foo] inc)\n  (state :foo) ;=> 2"}, load-image {:category "Image", :protocol-inline nil, :meta {:category "Image", :added "1.0", :subcategory "Loading & Displaying", :file quil.core, :end-column 13, :processing-name "loadImage()", :column 3, :requires-bindings true, :line 2351, :end-line 2351, :arglists (quote ([filename])), :doc "Loads an image into a variable of type PImage. Four types of\n  images ( .gif, .jpg, .tga, .png) images may be loaded. To load\n  correctly, images must be located in the data directory of the\n  current sketch. In most cases, load all images in setup to preload\n  them at the start of the program. Loading images inside draw will\n  reduce the speed of a program.\n\n  The filename parameter can also be a URL to a file found online.\n\n  If an image is not loaded successfully, the null value is returned\n  and an error message will be printed to the console. The error\n  message does not halt the program, however the null value may cause\n  a NullPointerException if your code does not check whether the value\n  returned from load-image is nil.\n\n  Depending on the type of error, a PImage object may still be\n  returned, but the width and height of the image will be set to\n  -1. This happens if bad image data is returned or cannot be decoded\n  properly. Sometimes this happens with image URLs that produce a 403\n  error or that redirect to a password prompt, because load-image\n  will attempt to interpret the HTML as image data."}, :added "1.0", :name quil.core$macros/load-image, :variadic false, :subcategory "Loading & Displaying", :file nil, :end-column 13, :processing-name "loadImage()", :method-params ([filename]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2345, :end-line 2351, :max-fixed-arity 1, :fn-var true, :arglists (quote ([filename])), :doc "Loads an image into a variable of type PImage. Four types of\n  images ( .gif, .jpg, .tga, .png) images may be loaded. To load\n  correctly, images must be located in the data directory of the\n  current sketch. In most cases, load all images in setup to preload\n  them at the start of the program. Loading images inside draw will\n  reduce the speed of a program.\n\n  The filename parameter can also be a URL to a file found online.\n\n  If an image is not loaded successfully, the null value is returned\n  and an error message will be printed to the console. The error\n  message does not halt the program, however the null value may cause\n  a NullPointerException if your code does not check whether the value\n  returned from load-image is nil.\n\n  Depending on the type of error, a PImage object may still be\n  returned, but the width and height of the image will be set to\n  -1. This happens if bad image data is returned or cannot be decoded\n  properly. Sometimes this happens with image URLs that produce a 403\n  error or that redirect to a password prompt, because load-image\n  will attempt to interpret the HTML as image data."}, bezier {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "Curves", :file quil.core, :end-column 9, :top-fn {:variadic false, :max-fixed-arity 12, :method-params ([x1 y1 cx1 cy1 cx2 cy2 x2 y2] [x1 y1 z1 cx1 cy1 cz1 cx2 cy2 cz2 x2 y2 z2]), :arglists ([x1 y1 cx1 cy1 cx2 cy2 x2 y2] [x1 y1 z1 cx1 cy1 cz1 cx2 cy2 cz2 x2 y2 z2]), :arglists-meta (nil nil)}, :processing-name "bezier()", :column 3, :requires-bindings true, :line 667, :end-line 667, :arglists (quote ([x1 y1 cx1 cy1 cx2 cy2 x2 y2] [x1 y1 z1 cx1 cy1 cz1 cx2 cy2 cz2 x2 y2 z2])), :doc "Draws a Bezier curve on the screen. These curves are defined by a\n  series of anchor and control points. The first two parameters\n  specify the first anchor point and the last two parameters specify\n  the other anchor point. The middle parameters specify the control\n  points which define the shape of the curve."}, :added "1.0", :name quil.core$macros/bezier, :variadic false, :subcategory "Curves", :file nil, :end-column 9, :top-fn {:variadic false, :max-fixed-arity 12, :method-params ([x1 y1 cx1 cy1 cx2 cy2 x2 y2] [x1 y1 z1 cx1 cy1 cz1 cx2 cy2 cz2 x2 y2 z2]), :arglists ([x1 y1 cx1 cy1 cx2 cy2 x2 y2] [x1 y1 z1 cx1 cy1 cz1 cx2 cy2 cz2 x2 y2 z2]), :arglists-meta (nil nil)}, :processing-name "bezier()", :method-params ([x1 y1 cx1 cy1 cx2 cy2 x2 y2] [x1 y1 z1 cx1 cy1 cz1 cx2 cy2 cz2 x2 y2 z2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 661, :end-line 667, :max-fixed-arity 12, :fn-var true, :arglists ([x1 y1 cx1 cy1 cx2 cy2 x2 y2] [x1 y1 z1 cx1 cy1 cz1 cx2 cy2 cz2 x2 y2 z2]), :doc "Draws a Bezier curve on the screen. These curves are defined by a\n  series of anchor and control points. The first two parameters\n  specify the first anchor point and the last two parameters specify\n  the other anchor point. The middle parameters specify the control\n  points which define the shape of the curve."}, smooth {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "Attributes", :file quil.core, :end-column 9, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [level]), :arglists ([] [level]), :arglists-meta (nil nil)}, :processing-name "smooth()", :column 3, :requires-bindings true, :line 3830, :end-line 3830, :arglists (quote ([] [level])), :doc "Draws all geometry with smooth (anti-aliased) edges. This will slow\n  down the frame rate of the application, but will enhance the visual\n  refinement.\n\n  Must be called inside :settings handler.\n\n  The level parameter (int) increases the level of smoothness with the\n  P2D and P3D renderers. This is the level of over sampling applied to\n  the graphics buffer. The value '2' will double the rendering size\n  before scaling it down to the display size. This is called '2x\n  anti-aliasing.' The value 4 is used for 4x anti-aliasing and 8 is\n  specified for 8x anti-aliasing. If level is set to 0, it will disable\n  all smoothing; it's the equivalent of the function noSmooth().\n  The maximum anti-aliasing level is determined by the hardware of the\n  machine that is running the software.\n\n  Note that smooth will also improve image quality of resized images."}, :added "1.0", :name quil.core$macros/smooth, :variadic false, :subcategory "Attributes", :file nil, :end-column 9, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [level]), :arglists ([] [level]), :arglists-meta (nil nil)}, :processing-name "smooth()", :method-params ([] [level]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3824, :end-line 3830, :max-fixed-arity 1, :fn-var true, :arglists ([] [level]), :doc "Draws all geometry with smooth (anti-aliased) edges. This will slow\n  down the frame rate of the application, but will enhance the visual\n  refinement.\n\n  Must be called inside :settings handler.\n\n  The level parameter (int) increases the level of smoothness with the\n  P2D and P3D renderers. This is the level of over sampling applied to\n  the graphics buffer. The value '2' will double the rendering size\n  before scaling it down to the display size. This is called '2x\n  anti-aliasing.' The value 4 is used for 4x anti-aliasing and 8 is\n  specified for 8x anti-aliasing. If level is set to 0, it will disable\n  all smoothing; it's the equivalent of the function noSmooth().\n  The maximum anti-aliasing level is determined by the hardware of the\n  machine that is running the software.\n\n  Note that smooth will also improve image quality of resized images."}, filter-modes {:name quil.core$macros/filter-modes, :file nil, :line 45, :column 1, :end-line 71, :end-column 14, :meta {:file quil.core, :line 71, :column 2, :end-line 71, :end-column 14}}, shear-x {:category "Transform", :protocol-inline nil, :meta {:category "Transform", :added "1.0", :subcategory nil, :file quil.core, :end-column 10, :processing-name "shearX()", :column 3, :requires-bindings true, :line 3729, :end-line 3729, :arglists (quote ([angle])), :doc "Shears a shape around the x-axis the amount specified by the angle\n  parameter. Angles should be specified in radians (values from 0 to\n  PI*2) or converted to radians with the radians() function. Objects\n  are always sheared around their relative position to the origin and\n  positive numbers shear objects in a clockwise direction.\n  Transformations apply to everything that happens after and\n  subsequent calls to the function accumulates the effect. For\n  example, calling (shear-x (/ PI 2)) and then (shear-x (/ PI 2)) is\n  the same as (shear-x PI). If shear-x is called within the draw fn,\n  the transformation is reset when the loop begins again. This\n  function works in P2D or JAVA2D mode.\n\n  Technically, shear-x multiplies the current transformation matrix\n  by a rotation matrix. This function can be further controlled by the\n  push-matrix and pop-matrix fns."}, :added "1.0", :name quil.core$macros/shear-x, :variadic false, :subcategory nil, :file nil, :end-column 10, :processing-name "shearX()", :method-params ([angle]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3723, :end-line 3729, :max-fixed-arity 1, :fn-var true, :arglists (quote ([angle])), :doc "Shears a shape around the x-axis the amount specified by the angle\n  parameter. Angles should be specified in radians (values from 0 to\n  PI*2) or converted to radians with the radians() function. Objects\n  are always sheared around their relative position to the origin and\n  positive numbers shear objects in a clockwise direction.\n  Transformations apply to everything that happens after and\n  subsequent calls to the function accumulates the effect. For\n  example, calling (shear-x (/ PI 2)) and then (shear-x (/ PI 2)) is\n  the same as (shear-x PI). If shear-x is called within the draw fn,\n  the transformation is reset when the loop begins again. This\n  function works in P2D or JAVA2D mode.\n\n  Technically, shear-x multiplies the current transformation matrix\n  by a rotation matrix. This function can be further controlled by the\n  push-matrix and pop-matrix fns."}, stroke-weight {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "Attributes", :file quil.core, :end-column 16, :processing-name "strokeWeight()", :column 3, :requires-bindings true, :line 4053, :end-line 4053, :arglists (quote ([weight])), :doc "Sets the width of the stroke used for lines, points, and the border\n  around shapes. All widths are set in units of pixels. "}, :added "1.0", :name quil.core$macros/stroke-weight, :variadic false, :subcategory "Attributes", :file nil, :end-column 16, :processing-name "strokeWeight()", :method-params ([weight]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 4047, :end-line 4053, :max-fixed-arity 1, :fn-var true, :arglists (quote ([weight])), :doc "Sets the width of the stroke used for lines, points, and the border\n  around shapes. All widths are set in units of pixels. "}, directional-light {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Lights", :file quil.core, :end-column 20, :processing-name "directionalLight()", :column 3, :requires-bindings true, :line 1475, :end-line 1475, :arglists (quote ([r g b nx ny nz])), :doc "Adds a directional light. Directional light comes from one\n  direction and is stronger when hitting a surface squarely and weaker\n  if it hits at a gentle angle. After hitting a surface, a\n  directional lights scatters in all directions. Lights need to be\n  included in the draw fn to remain persistent in a looping\n  program. Placing them in the setup fn of a looping program will cause\n  them to only have an effect the first time through the loop. The\n  affect of the r, g, and b parameters is determined by the current\n  color mode. The nx, ny, and nz parameters specify the direction the\n  light is facing. For example, setting ny to -1 will cause the\n  geometry to be lit from below (the light is facing directly upward)"}, :added "1.0", :name quil.core$macros/directional-light, :variadic false, :subcategory "Lights", :file nil, :end-column 20, :processing-name "directionalLight()", :method-params ([r g b nx ny nz]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1469, :end-line 1475, :max-fixed-arity 6, :fn-var true, :arglists (quote ([r g b nx ny nz])), :doc "Adds a directional light. Directional light comes from one\n  direction and is stronger when hitting a surface squarely and weaker\n  if it hits at a gentle angle. After hitting a surface, a\n  directional lights scatters in all directions. Lights need to be\n  included in the draw fn to remain persistent in a looping\n  program. Placing them in the setup fn of a looping program will cause\n  them to only have an effect the first time through the loop. The\n  affect of the r, g, and b parameters is determined by the current\n  color mode. The nx, ny, and nz parameters specify the direction the\n  light is facing. For example, setting ny to -1 will cause the\n  geometry to be lit from below (the light is facing directly upward)"}, frame-rate {:category "Environment", :protocol-inline nil, :meta {:category "Environment", :added "1.0", :subcategory nil, :file quil.core, :end-column 13, :processing-name "frameRate()", :column 3, :requires-bindings true, :line 1859, :end-line 1859, :arglists (quote ([new-rate])), :doc "Specifies a new target framerate (number of frames to be displayed every\n  second). If the processor is not fast enough to maintain the\n  specified rate, it will not be achieved. For example, the function\n  call (frame-rate 30) will attempt to refresh 30 times a second. It\n  is recommended to set the frame rate within setup. The default rate\n  is 60 frames per second."}, :added "1.0", :name quil.core$macros/frame-rate, :variadic false, :subcategory nil, :file nil, :end-column 13, :processing-name "frameRate()", :method-params ([new-rate]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1853, :end-line 1859, :max-fixed-arity 1, :fn-var true, :arglists (quote ([new-rate])), :doc "Specifies a new target framerate (number of frames to be displayed every\n  second). If the processor is not fast enough to maintain the\n  specified rate, it will not be achieved. For example, the function\n  call (frame-rate 30) will attempt to refresh 30 times a second. It\n  is recommended to set the frame rate within setup. The default rate\n  is 60 frames per second."}, hour {:category "Input", :protocol-inline nil, :meta {:category "Input", :added "1.0", :subcategory "Time & Date", :file quil.core, :end-column 7, :processing-name "hour()", :column 3, :requires-bindings false, :line 2032, :end-line 2032, :arglists (quote ([])), :doc "Returns the current hour as a value from 0 - 23."}, :added "1.0", :name quil.core$macros/hour, :variadic false, :subcategory "Time & Date", :file nil, :end-column 7, :processing-name "hour()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 2026, :end-line 2032, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Returns the current hour as a value from 0 - 23."}, fill-int {:category "Color", :protocol-inline nil, :meta {:category "Color", :added "1.0", :subcategory "Setting", :file quil.core, :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([rgb] [rgb alpha]), :arglists ([rgb] [rgb alpha]), :arglists-meta (nil nil)}, :processing-name "fill()", :column 3, :requires-bindings true, :line 1707, :end-line 1707, :arglists (quote ([rgb] [rgb alpha])), :doc "Sets the color used to fill shapes."}, :added "1.0", :name quil.core$macros/fill-int, :variadic false, :subcategory "Setting", :file nil, :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([rgb] [rgb alpha]), :arglists ([rgb] [rgb alpha]), :arglists-meta (nil nil)}, :processing-name "fill()", :method-params ([rgb] [rgb alpha]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1701, :end-line 1707, :max-fixed-arity 2, :fn-var true, :arglists ([rgb] [rgb alpha]), :doc "Sets the color used to fill shapes."}, atan {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Trigonometry", :file quil.core, :end-column 7, :processing-name "atan()", :column 3, :requires-bindings false, :line 458, :end-line 458, :arglists (quote ([n])), :doc "The inverse of tan, returns the arc tangent of a value. This\n  function expects the values in the range of -Infinity to\n  Infinity (exclusive) and values are returned in the range -PI/2 to\n  PI/2 ."}, :added "1.0", :name quil.core$macros/atan, :variadic false, :subcategory "Trigonometry", :file nil, :end-column 7, :processing-name "atan()", :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 452, :end-line 458, :max-fixed-arity 1, :fn-var true, :arglists (quote ([n])), :doc "The inverse of tan, returns the arc tangent of a value. This\n  function expects the values in the range of -Infinity to\n  Infinity (exclusive) and values are returned in the range -PI/2 to\n  PI/2 ."}, stroke-join-modes {:name quil.core$macros/stroke-join-modes, :file nil, :line 45, :column 1, :end-line 65, :end-column 19, :meta {:file quil.core, :line 65, :column 2, :end-line 65, :end-column 19}}, rotate-y {:category "Transform", :protocol-inline nil, :meta {:category "Transform", :added "1.0", :subcategory nil, :file quil.core, :end-column 11, :processing-name "rotateY()", :column 3, :requires-bindings true, :line 3438, :end-line 3438, :arglists (quote ([angle])), :doc "Rotates a shape around the y-axis the amount specified by the angle\n  parameter. Angles should be specified in radians (values from 0\n  to (* PI 2)) or converted to radians with the radians function.\n  Objects are always rotated around their relative position to the\n  origin and positive numbers rotate objects in a counterclockwise\n  direction. Transformations apply to everything that happens after\n  and subsequent calls to the function accumulates the effect. For\n  example, calling (rotate-y HALF-PI) and then (rotate-y HALF-PI) is\n  the same as (rotate-y PI). If rotate-y is called within the draw fn,\n  the transformation is reset when the loop begins again. This\n  function requires either the :p3d or :opengl renderer."}, :added "1.0", :name quil.core$macros/rotate-y, :variadic false, :subcategory nil, :file nil, :end-column 11, :processing-name "rotateY()", :method-params ([angle]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3432, :end-line 3438, :max-fixed-arity 1, :fn-var true, :arglists (quote ([angle])), :doc "Rotates a shape around the y-axis the amount specified by the angle\n  parameter. Angles should be specified in radians (values from 0\n  to (* PI 2)) or converted to radians with the radians function.\n  Objects are always rotated around their relative position to the\n  origin and positive numbers rotate objects in a counterclockwise\n  direction. Transformations apply to everything that happens after\n  and subsequent calls to the function accumulates the effect. For\n  example, calling (rotate-y HALF-PI) and then (rotate-y HALF-PI) is\n  the same as (rotate-y PI). If rotate-y is called within the draw fn,\n  the transformation is reset when the loop begins again. This\n  function requires either the :p3d or :opengl renderer."}, day {:category "Input", :protocol-inline nil, :meta {:category "Input", :added "1.0", :subcategory "Time & Date", :file quil.core, :end-column 6, :processing-name "day()", :column 3, :requires-bindings false, :line 1426, :end-line 1426, :arglists (quote ([])), :doc "Get the current day of the month (1 through 31)."}, :added "1.0", :name quil.core$macros/day, :variadic false, :subcategory "Time & Date", :file nil, :end-column 6, :processing-name "day()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 1420, :end-line 1426, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Get the current day of the month (1 through 31)."}, point-light {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Lights", :file quil.core, :end-column 14, :processing-name "pointLight()", :column 3, :requires-bindings true, :line 2962, :end-line 2962, :arglists (quote ([r g b x y z])), :doc "Adds a point light. Lights need to be included in the draw() to\n  remain persistent in a looping program. Placing them in the setup()\n  of a looping program will cause them to only have an effect the\n  first time through the loop. The affect of the r, g, and b\n  parameters is determined by the current color mode. The x, y, and z\n  parameters set the position of the light"}, :added "1.0", :name quil.core$macros/point-light, :variadic false, :subcategory "Lights", :file nil, :end-column 14, :processing-name "pointLight()", :method-params ([r g b x y z]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2956, :end-line 2962, :max-fixed-arity 6, :fn-var true, :arglists (quote ([r g b x y z])), :doc "Adds a point light. Lights need to be included in the draw() to\n  remain persistent in a looping program. Placing them in the setup()\n  of a looping program will cause them to only have an effect the\n  first time through the loop. The affect of the r, g, and b\n  parameters is determined by the current color mode. The x, y, and z\n  parameters set the position of the light"}, pmouse-x {:category "Input", :protocol-inline nil, :meta {:category "Input", :added "1.0", :subcategory "Mouse", :file quil.core, :end-column 11, :processing-name "pmouseX", :column 3, :requires-bindings true, :line 2924, :end-line 2924, :arglists (quote ([])), :doc "Horizontal coordinate of the mouse in the previous frame"}, :added "1.0", :name quil.core$macros/pmouse-x, :variadic false, :subcategory "Mouse", :file nil, :end-column 11, :processing-name "pmouseX", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2918, :end-line 2924, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Horizontal coordinate of the mouse in the previous frame"}, get-sketch-by-id {:category nil, :protocol-inline nil, :meta {:category nil, :added "1.0", :subcategory nil, :file quil.core, :end-column 22, :processing-name "getSketchById()", :column 6, :requires-bindings true, :line 185, :end-line 185, :arglists (quote ([id])), :doc "Returns sketch object by id of canvas element of sketch."}, :added "1.0", :name quil.core$macros/get-sketch-by-id, :variadic false, :subcategory nil, :file nil, :end-column 22, :processing-name "getSketchById()", :method-params ([id]), :protocol-impl nil, :arglists-meta (nil nil), :column 4, :requires-bindings true, :line 179, :end-line 185, :max-fixed-arity 1, :fn-var true, :arglists (quote ([id])), :doc "Returns sketch object by id of canvas element of sketch."}, stroke {:category "Color", :protocol-inline nil, :meta {:category "Color", :added "1.0", :subcategory "Setting", :file quil.core, :end-column 9, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([rgb] [rgb alpha] [x y z] [x y z a]), :arglists ([rgb] [rgb alpha] [x y z] [x y z a]), :arglists-meta (nil nil nil nil)}, :processing-name "stroke()", :column 3, :requires-bindings true, :line 3995, :end-line 3995, :arglists (quote ([rgb] [rgb alpha] [x y z] [x y z a])), :doc "Sets the color used to draw lines and borders around shapes. This\n  color is either specified in terms of the RGB or HSB color depending\n  on the current color-mode (the default color space is RGB, with\n  each value in the range from 0 to 255)."}, :added "1.0", :name quil.core$macros/stroke, :variadic false, :subcategory "Setting", :file nil, :end-column 9, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([rgb] [rgb alpha] [x y z] [x y z a]), :arglists ([rgb] [rgb alpha] [x y z] [x y z a]), :arglists-meta (nil nil nil nil)}, :processing-name "stroke()", :method-params ([rgb] [rgb alpha] [x y z] [x y z a]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :requires-bindings true, :line 3989, :end-line 3995, :max-fixed-arity 4, :fn-var true, :arglists ([rgb] [rgb alpha] [x y z] [x y z a]), :doc "Sets the color used to draw lines and borders around shapes. This\n  color is either specified in terms of the RGB or HSB color depending\n  on the current color-mode (the default color space is RGB, with\n  each value in the range from 0 to 255)."}, mouse-pressed? {:category "Input", :protocol-inline nil, :meta {:category "Input", :added "1.0", :subcategory "Mouse", :file quil.core, :end-column 17, :processing-name "mousePressed", :column 3, :requires-bindings true, :line 2584, :end-line 2584, :arglists (quote ([])), :doc "Variable storing if a mouse button is pressed. The value of the\n  system variable mousePressed is true if a mouse button is pressed\n  and false if a button is not pressed."}, :added "1.0", :name quil.core$macros/mouse-pressed?, :variadic false, :subcategory "Mouse", :file nil, :end-column 17, :processing-name "mousePressed", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2578, :end-line 2584, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Variable storing if a mouse button is pressed. The value of the\n  system variable mousePressed is true if a mouse button is pressed\n  and false if a button is not pressed."}, key-pressed? {:category "Input", :protocol-inline nil, :meta {:category "Input", :added "1.0", :subcategory "Keyboard", :file quil.core, :end-column 15, :processing-name "keyPressed", :column 3, :requires-bindings true, :line 2196, :end-line 2196, :arglists (quote ([])), :doc "true if any key is currently pressed, false otherwise."}, :added "1.0", :name quil.core$macros/key-pressed?, :variadic false, :subcategory "Keyboard", :file nil, :end-column 15, :processing-name "keyPressed", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2190, :end-line 2196, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "true if any key is currently pressed, false otherwise."}, quadratic-vertex {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "2.0", :subcategory "Vertex", :file quil.core, :end-column 19, :top-fn {:variadic false, :max-fixed-arity 6, :method-params ([cx cy x3 y3] [cx cy cz x3 y3 z3]), :arglists ([cx cy x3 y3] [cx cy cz x3 y3 z3]), :arglists-meta (nil nil)}, :processing-name "quadraticVertex()", :column 3, :requires-bindings true, :line 3121, :end-line 3121, :arglists (quote ([cx cy x3 y3] [cx cy cz x3 y3 z3])), :doc "Specifies vertex coordinates for quadratic Bezier curves. Each call to\n  quadratic-vertex defines the position of one control points and one\n  anchor point of a Bezier curve, adding a new segment to a line or shape.\n  The first time quadratic-vertex is used within a begin-shape call, it\n  must be prefaced with a call to vertex to set the first anchor point.\n  This function must be used between begin-shape and end-shape and only\n  when there is no MODE parameter specified to begin-shape. Using the 3D\n  version requires rendering with :p3d."}, :added "2.0", :name quil.core$macros/quadratic-vertex, :variadic false, :subcategory "Vertex", :file nil, :end-column 19, :top-fn {:variadic false, :max-fixed-arity 6, :method-params ([cx cy x3 y3] [cx cy cz x3 y3 z3]), :arglists ([cx cy x3 y3] [cx cy cz x3 y3 z3]), :arglists-meta (nil nil)}, :processing-name "quadraticVertex()", :method-params ([cx cy x3 y3] [cx cy cz x3 y3 z3]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3115, :end-line 3121, :max-fixed-arity 6, :fn-var true, :arglists ([cx cy x3 y3] [cx cy cz x3 y3 z3]), :doc "Specifies vertex coordinates for quadratic Bezier curves. Each call to\n  quadratic-vertex defines the position of one control points and one\n  anchor point of a Bezier curve, adding a new segment to a line or shape.\n  The first time quadratic-vertex is used within a begin-shape call, it\n  must be prefaced with a call to vertex to set the first anchor point.\n  This function must be used between begin-shape and end-shape and only\n  when there is no MODE parameter specified to begin-shape. Using the 3D\n  version requires rendering with :p3d."}, texture-wrap-modes {:name quil.core$macros/texture-wrap-modes, :file nil, :line 45, :column 1, :end-line 70, :end-column 20, :meta {:file quil.core, :line 70, :column 2, :end-line 70, :end-column 20}}, noise-seed {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Random", :file quil.core, :end-column 13, :processing-name "noiseSeed()", :column 3, :requires-bindings true, :line 2722, :end-line 2722, :arglists (quote ([val])), :doc "Sets the seed value for noise. By default, noise produces different\n  results each time the program is run. Set the value parameter to a\n  constant to return the same pseudo-random numbers each time the\n  software is run."}, :added "1.0", :name quil.core$macros/noise-seed, :variadic false, :subcategory "Random", :file nil, :end-column 13, :processing-name "noiseSeed()", :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2716, :end-line 2722, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :doc "Sets the seed value for noise. By default, noise produces different\n  results each time the program is run. Set the value parameter to a\n  constant to return the same pseudo-random numbers each time the\n  software is run."}, apply-matrix {:category "Transform", :protocol-inline nil, :meta {:category "Transform", :added "1.0", :subcategory nil, :file quil.core, :end-column 15, :processing-name "applyMatrix()", :column 3, :requires-bindings true, :line 396, :end-line 396, :arglists (quote ([n00 n01 n02 n03 n10 n11 n12 n13 n20 n21 n22 n23 n30 n31 n32 n33])), :doc "Multiplies the current matrix by the one specified through the\n  parameters. This is very slow because it will try to calculate the\n  inverse of the transform, so avoid it whenever possible. The\n  equivalent function in OpenGL is glMultMatrix()."}, :added "1.0", :name quil.core$macros/apply-matrix, :variadic false, :subcategory nil, :file nil, :end-column 15, :processing-name "applyMatrix()", :method-params ([n00 n01 n02 n03 n10 n11 n12 n13 n20 n21 n22 n23 n30 n31 n32 n33]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 390, :end-line 396, :max-fixed-arity 16, :fn-var true, :arglists (quote ([n00 n01 n02 n03 n10 n11 n12 n13 n20 n21 n22 n23 n30 n31 n32 n33])), :doc "Multiplies the current matrix by the one specified through the\n  parameters. This is very slow because it will try to calculate the\n  inverse of the transform, so avoid it whenever possible. The\n  equivalent function in OpenGL is glMultMatrix()."}, copy {:category "Image", :protocol-inline nil, :meta {:category "Image", :added "1.0", :subcategory "Pixels", :file quil.core, :end-column 7, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([[sx sy swidth sheight] [dx dy dwidth dheight]] [src-img [sx sy swidth sheight] [dx dy dwidth dheight]] [src-img dest-img [sx sy swidth sheight] [dx dy dwidth dheight]]), :arglists ([[sx sy swidth sheight] [dx dy dwidth dheight]] [src-img [sx sy swidth sheight] [dx dy dwidth dheight]] [src-img dest-img [sx sy swidth sheight] [dx dy dwidth dheight]]), :arglists-meta (nil nil nil)}, :processing-name "copy()", :column 3, :requires-bindings true, :line 1112, :end-line 1112, :arglists (quote ([[sx sy swidth sheight] [dx dy dwidth dheight]] [src-img [sx sy swidth sheight] [dx dy dwidth dheight]] [src-img dest-img [sx sy swidth sheight] [dx dy dwidth dheight]])), :doc "Copies a region of pixels from the one image to another. If src-img\n  is not specified it defaults to current-graphics. If dest-img is not\n  specified - it defaults to current-graphics. If the source\n  and destination regions aren't the same size, it will automatically\n  resize the source pixels to fit the specified target region. No\n  alpha information is used in the process, however if the source\n  image has an alpha channel set, it will be copied as well. "}, :added "1.0", :name quil.core$macros/copy, :variadic false, :subcategory "Pixels", :file nil, :end-column 7, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([[sx sy swidth sheight] [dx dy dwidth dheight]] [src-img [sx sy swidth sheight] [dx dy dwidth dheight]] [src-img dest-img [sx sy swidth sheight] [dx dy dwidth dheight]]), :arglists ([[sx sy swidth sheight] [dx dy dwidth dheight]] [src-img [sx sy swidth sheight] [dx dy dwidth dheight]] [src-img dest-img [sx sy swidth sheight] [dx dy dwidth dheight]]), :arglists-meta (nil nil nil)}, :processing-name "copy()", :method-params ([[sx sy swidth sheight] [dx dy dwidth dheight]] [src-img [sx sy swidth sheight] [dx dy dwidth dheight]] [src-img dest-img [sx sy swidth sheight] [dx dy dwidth dheight]]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :requires-bindings true, :line 1106, :end-line 1112, :max-fixed-arity 4, :fn-var true, :arglists ([[sx sy swidth sheight] [dx dy dwidth dheight]] [src-img [sx sy swidth sheight] [dx dy dwidth dheight]] [src-img dest-img [sx sy swidth sheight] [dx dy dwidth dheight]]), :doc "Copies a region of pixels from the one image to another. If src-img\n  is not specified it defaults to current-graphics. If dest-img is not\n  specified - it defaults to current-graphics. If the source\n  and destination regions aren't the same size, it will automatically\n  resize the source pixels to fit the specified target region. No\n  alpha information is used in the process, however if the source\n  image has an alpha channel set, it will be copied as well. "}, begin-shape {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "Vertex", :file quil.core, :end-column 14, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [mode]), :arglists ([] [mode]), :arglists-meta (nil nil)}, :processing-name "beginShape()", :column 3, :requires-bindings true, :line 635, :end-line 635, :arglists (quote ([] [mode])), :doc "Enables the creation of complex forms. begin-shape begins recording\n  vertices for a shape and end-shape stops recording. Use the mode\n  keyword to specify which shape create from the provided\n  vertices. With no mode specified, the shape can be any irregular\n  polygon.\n\n  The available mode keywords are :points, :lines, :triangles,\n                                  :triangle-fan, :triangle-strip,\n                                  :quads, :quad-strip.\n\n  After calling the begin-shape function, a series of vertex commands\n  must follow. To stop drawing the shape, call end-shape. The vertex\n  function with two parameters specifies a position in 2D and the\n  vertex function with three parameters specifies a position in\n  3D. Each shape will be outlined with the current stroke color and\n  filled with the fill color.\n\n  Transformations such as translate, rotate, and scale do not work\n  within begin-shape. It is also not possible to use other shapes,\n  such as ellipse or rect within begin-shape."}, :added "1.0", :name quil.core$macros/begin-shape, :variadic false, :subcategory "Vertex", :file nil, :end-column 14, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [mode]), :arglists ([] [mode]), :arglists-meta (nil nil)}, :processing-name "beginShape()", :method-params ([] [mode]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 629, :end-line 635, :max-fixed-arity 1, :fn-var true, :arglists ([] [mode]), :doc "Enables the creation of complex forms. begin-shape begins recording\n  vertices for a shape and end-shape stops recording. Use the mode\n  keyword to specify which shape create from the provided\n  vertices. With no mode specified, the shape can be any irregular\n  polygon.\n\n  The available mode keywords are :points, :lines, :triangles,\n                                  :triangle-fan, :triangle-strip,\n                                  :quads, :quad-strip.\n\n  After calling the begin-shape function, a series of vertex commands\n  must follow. To stop drawing the shape, call end-shape. The vertex\n  function with two parameters specifies a position in 2D and the\n  vertex function with three parameters specifies a position in\n  3D. Each shape will be outlined with the current stroke color and\n  filled with the fill color.\n\n  Transformations such as translate, rotate, and scale do not work\n  within begin-shape. It is also not possible to use other shapes,\n  such as ellipse or rect within begin-shape."}, set-state! {:category "State", :protocol-inline nil, :meta {:category "State", :added "1.0", :subcategory nil, :file quil.core, :end-column 13, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(state-vals)], :arglists ([& state-vals]), :arglists-meta (nil)}, :column 3, :requires-bindings true, :line 236, :end-line 236, :arglists (quote ([& state-vals])), :doc "Set sketch-specific state. May only be called once (ideally in the\n  setup fn).  Subsequent calls have no effect.\n\n  Example:\n  (set-state! :foo 1 :bar (atom true) :baz (/ (width) 2))"}, :added "1.0", :name quil.core$macros/set-state!, :variadic true, :subcategory nil, :file nil, :end-column 13, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(state-vals)], :arglists ([& state-vals]), :arglists-meta (nil)}, :method-params [(state-vals)], :protocol-impl nil, :arglists-meta (nil), :column 1, :requires-bindings true, :line 231, :end-line 236, :max-fixed-arity 0, :fn-var true, :arglists ([& state-vals]), :doc "Set sketch-specific state. May only be called once (ideally in the\n  setup fn).  Subsequent calls have no effect.\n\n  Example:\n  (set-state! :foo 1 :bar (atom true) :baz (/ (width) 2))"}, stroke-join {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "Attributes", :file quil.core, :end-column 14, :processing-name "strokeJoin()", :column 3, :requires-bindings true, :line 4033, :end-line 4033, :arglists (quote ([join-mode])), :doc "Sets the style of the joints which connect line\n  segments. These joints are either mitered, beveled, or rounded and\n  specified with the corresponding parameters :miter, :bevel, and\n  :round. The default joint is :miter.\n\n  This function is not available with the :p2d, :p3d, or :opengl\n  renderers."}, :added "1.0", :name quil.core$macros/stroke-join, :variadic false, :subcategory "Attributes", :file nil, :end-column 14, :processing-name "strokeJoin()", :method-params ([join-mode]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 4027, :end-line 4033, :max-fixed-arity 1, :fn-var true, :arglists (quote ([join-mode])), :doc "Sets the style of the joints which connect line\n  segments. These joints are either mitered, beveled, or rounded and\n  specified with the corresponding parameters :miter, :bevel, and\n  :round. The default joint is :miter.\n\n  This function is not available with the :p2d, :p3d, or :opengl\n  renderers."}, cos {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Trigonometry", :file quil.core, :end-column 6, :processing-name "cos()", :column 3, :requires-bindings false, :line 1138, :end-line 1138, :arglists (quote ([angle])), :doc "Calculates the cosine of an angle. This function expects the values\n  of the angle parameter to be provided in radians (values from 0 to\n  Math/PI*2). Values are returned in the range -1 to 1."}, :added "1.0", :name quil.core$macros/cos, :variadic false, :subcategory "Trigonometry", :file nil, :end-column 6, :processing-name "cos()", :method-params ([angle]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 1132, :end-line 1138, :max-fixed-arity 1, :fn-var true, :arglists (quote ([angle])), :doc "Calculates the cosine of an angle. This function expects the values\n  of the angle parameter to be provided in radians (values from 0 to\n  Math/PI*2). Values are returned in the range -1 to 1."}, curve-tightness {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "Curves", :file quil.core, :end-column 18, :processing-name "curveTightness()", :column 3, :requires-bindings true, :line 1389, :end-line 1389, :arglists (quote ([ti])), :doc "Modifies the quality of forms created with curve and\n  curve-vertex. The parameter squishy determines how the curve fits\n  to the vertex points. The value 0.0 is the default value for\n  squishy (this value defines the curves to be Catmull-Rom splines)\n  and the value 1.0 connects all the points with straight\n  lines. Values within the range -5.0 and 5.0 will deform the curves\n  but will leave them recognizable and as values increase in\n  magnitude, they will continue to deform."}, :added "1.0", :name quil.core$macros/curve-tightness, :variadic false, :subcategory "Curves", :file nil, :end-column 18, :processing-name "curveTightness()", :method-params ([ti]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1383, :end-line 1389, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ti])), :doc "Modifies the quality of forms created with curve and\n  curve-vertex. The parameter squishy determines how the curve fits\n  to the vertex points. The value 0.0 is the default value for\n  squishy (this value defines the curves to be Catmull-Rom splines)\n  and the value 1.0 connects all the points with straight\n  lines. Values within the range -5.0 and 5.0 will deform the curves\n  but will leave them recognizable and as values increase in\n  magnitude, they will continue to deform."}, tan {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Trigonometry", :file quil.core, :end-column 6, :processing-name "tan()", :column 3, :requires-bindings false, :line 4065, :end-line 4065, :arglists (quote ([angle])), :doc "Calculates the ratio of the sine and cosine of an angle. This\n  function expects the values of the angle parameter to be provided in\n  radians (values from 0 to PI*2). Values are returned in the range\n  infinity to -infinity."}, :added "1.0", :name quil.core$macros/tan, :variadic false, :subcategory "Trigonometry", :file nil, :end-column 6, :processing-name "tan()", :method-params ([angle]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 4059, :end-line 4065, :max-fixed-arity 1, :fn-var true, :arglists (quote ([angle])), :doc "Calculates the ratio of the sine and cosine of an angle. This\n  function expects the values of the angle parameter to be provided in\n  radians (values from 0 to PI*2). Values are returned in the range\n  infinity to -infinity."}, triangle {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "2D Primitives", :file quil.core, :end-column 11, :processing-name "triangle()", :column 3, :requires-bindings true, :line 4462, :end-line 4462, :arglists (quote ([x1 y1 x2 y2 x3 y3])), :doc "A triangle is a plane created by connecting three points. The first\n  two arguments specify the first point, the middle two arguments\n  specify the second point, and the last two arguments specify the\n  third point."}, :added "1.0", :name quil.core$macros/triangle, :variadic false, :subcategory "2D Primitives", :file nil, :end-column 11, :processing-name "triangle()", :method-params ([x1 y1 x2 y2 x3 y3]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 4456, :end-line 4462, :max-fixed-arity 6, :fn-var true, :arglists (quote ([x1 y1 x2 y2 x3 y3])), :doc "A triangle is a plane created by connecting three points. The first\n  two arguments specify the first point, the middle two arguments\n  specify the second point, and the last two arguments specify the\n  third point."}, emissive {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Material Properties", :file quil.core, :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([c] [r g b]), :arglists ([c] [r g b]), :arglists-meta (nil nil)}, :processing-name "emissive()", :column 3, :requires-bindings true, :line 1575, :end-line 1575, :arglists (quote ([c] [r g b])), :doc "Sets the emissive color of the material used for drawing shapes\n  drawn to the screen. Used in combination with ambient, specular, and\n  shininess in setting the material properties of shapes.\n\n  If passed one arg - it is assumed to be an int (i.e. a color),\n  multiple args are converted to floats."}, :added "1.0", :name quil.core$macros/emissive, :variadic false, :subcategory "Material Properties", :file nil, :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([c] [r g b]), :arglists ([c] [r g b]), :arglists-meta (nil nil)}, :processing-name "emissive()", :method-params ([c] [r g b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1569, :end-line 1575, :max-fixed-arity 3, :fn-var true, :arglists ([c] [r g b]), :doc "Sets the emissive color of the material used for drawing shapes\n  drawn to the screen. Used in combination with ambient, specular, and\n  shininess in setting the material properties of shapes.\n\n  If passed one arg - it is assumed to be an int (i.e. a color),\n  multiple args are converted to floats."}, clear-no-fill-cljs {:protocol-inline nil, :meta {:file quil.core, :line 1673, :column 8, :end-line 1673, :end-column 26, :private true, :arglists (quote ([graphics])), :doc "Sets custom property on graphcis object indicating that it has\n  fill color."}, :private true, :name quil.core$macros/clear-no-fill-cljs, :variadic false, :file nil, :end-column 26, :method-params ([graphics]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1673, :end-line 1673, :max-fixed-arity 1, :fn-var true, :arglists (quote ([graphics])), :doc "Sets custom property on graphcis object indicating that it has\n  fill color."}, sketch {:category "Environment", :protocol-inline nil, :meta {:category "Environment", :added "1.0", :subcategory nil, :file quil.core, :end-column 9, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(opts)], :arglists ([& opts]), :arglists-meta (nil)}, :column 3, :requires-bindings false, :line 4676, :end-line 4676, :arglists (quote ([& opts])), :doc "Create and start a new visualisation applet. Can be used to create\n  new sketches programmatically. See documentation for 'defsketch' for\n  list of available options."}, :added "1.0", :name quil.core$macros/sketch, :variadic true, :subcategory nil, :file nil, :end-column 9, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(opts)], :arglists ([& opts]), :arglists-meta (nil)}, :method-params [(opts)], :protocol-impl nil, :arglists-meta (nil), :column 1, :requires-bindings false, :line 4672, :end-line 4676, :max-fixed-arity 0, :fn-var true, :arglists ([& opts]), :doc "Create and start a new visualisation applet. Can be used to create\n  new sketches programmatically. See documentation for 'defsketch' for\n  list of available options."}, color {:category "Color", :protocol-inline nil, :meta {:category "Color", :added "1.0", :subcategory "Creating & Reading", :file quil.core, :end-column 8, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([gray] [gray alpha] [r g b] [r g b a]), :arglists ([gray] [gray alpha] [r g b] [r g b a]), :arglists-meta (nil nil nil nil)}, :processing-name "color()", :column 3, :requires-bindings true, :line 1019, :end-line 1019, :arglists (quote ([gray] [gray alpha] [r g b] [r g b a])), :doc "Creates an integer representation of a color The parameters are\n  interpreted as RGB or HSB values depending on the current\n  color-mode. The default mode is RGB values from 0 to 255 and\n  therefore, the function call (color 255 204 0) will return a bright\n  yellow. Args are cast to floats.\n\n  r - red or hue value\n  g - green or saturation value\n  b - blue or brightness value\n  a - alpha value"}, :added "1.0", :name quil.core$macros/color, :variadic false, :subcategory "Creating & Reading", :file nil, :end-column 8, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([gray] [gray alpha] [r g b] [r g b a]), :arglists ([gray] [gray alpha] [r g b] [r g b a]), :arglists-meta (nil nil nil nil)}, :processing-name "color()", :method-params ([gray] [gray alpha] [r g b] [r g b a]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :requires-bindings true, :line 1013, :end-line 1019, :max-fixed-arity 4, :fn-var true, :arglists ([gray] [gray alpha] [r g b] [r g b a]), :doc "Creates an integer representation of a color The parameters are\n  interpreted as RGB or HSB values depending on the current\n  color-mode. The default mode is RGB values from 0 to 255 and\n  therefore, the function call (color 255 204 0) will return a bright\n  yellow. Args are cast to floats.\n\n  r - red or hue value\n  g - green or saturation value\n  b - blue or brightness value\n  a - alpha value"}, arc {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "2D Primitives", :file quil.core, :end-column 6, :processing-name "arc()", :column 3, :requires-bindings true, :line 422, :end-line 422, :arglists (quote ([x y width height start stop])), :doc "Draws an arc in the display window. Arcs are drawn along the outer\n  edge of an ellipse defined by the x, y, width and height\n  parameters. The origin or the arc's ellipse may be changed with the\n  ellipse-mode function. The start and stop parameters specify the\n  angles at which to draw the arc. The mode is either :open, :chord or :pie."}, :added "1.0", :name quil.core$macros/arc, :variadic false, :subcategory "2D Primitives", :file nil, :end-column 6, :processing-name "arc()", :method-params ([x y width height start stop]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 416, :end-line 422, :max-fixed-arity 6, :fn-var true, :arglists (quote ([x y width height start stop])), :doc "Draws an arc in the display window. Arcs are drawn along the outer\n  edge of an ellipse defined by the x, y, width and height\n  parameters. The origin or the arc's ellipse may be changed with the\n  ellipse-mode function. The start and stop parameters specify the\n  angles at which to draw the arc. The mode is either :open, :chord or :pie."}, text-align {:category "Typography", :protocol-inline nil, :meta {:category "Typography", :added "1.0", :subcategory "Attributes", :file quil.core, :end-column 13, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([align] [align-x align-y]), :arglists ([align] [align-x align-y]), :arglists-meta (nil nil)}, :processing-name "textAlign()", :column 3, :requires-bindings true, :line 4157, :end-line 4157, :arglists (quote ([align] [align-x align-y])), :doc "Sets the current alignment for drawing text. Available modes are:\n\n  horizontal - :left, :center, and :right\n  vertical   - :top, :bottom, :center, and :baseline\n\n  An optional second parameter specifies the vertical alignment\n  mode. :baseline is the default. The :top and :center parameters are\n  straightforward. The :bottom parameter offsets the line based on the\n  current text-descent. For multiple lines, the final line will be\n  aligned to the bottom, with the previous lines appearing above it.\n\n  When using text with width and height parameters, :baseline is\n  ignored, and treated as :top. (Otherwise, text would by default draw\n  outside the box, since :baseline is the default setting. :baseline is\n  not a useful drawing mode for text drawn in a rectangle.)\n\n  The vertical alignment is based on the value of text-ascent, which\n  many fonts do not specify correctly. It may be necessary to use a\n  hack and offset by a few pixels by hand so that the offset looks\n  correct. To do this as less of a hack, use some percentage of\n  text-ascent or text-descent so that the hack works even if you\n  change the size of the font."}, :added "1.0", :name quil.core$macros/text-align, :variadic false, :subcategory "Attributes", :file nil, :end-column 13, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([align] [align-x align-y]), :arglists ([align] [align-x align-y]), :arglists-meta (nil nil)}, :processing-name "textAlign()", :method-params ([align] [align-x align-y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 4151, :end-line 4157, :max-fixed-arity 2, :fn-var true, :arglists ([align] [align-x align-y]), :doc "Sets the current alignment for drawing text. Available modes are:\n\n  horizontal - :left, :center, and :right\n  vertical   - :top, :bottom, :center, and :baseline\n\n  An optional second parameter specifies the vertical alignment\n  mode. :baseline is the default. The :top and :center parameters are\n  straightforward. The :bottom parameter offsets the line based on the\n  current text-descent. For multiple lines, the final line will be\n  aligned to the bottom, with the previous lines appearing above it.\n\n  When using text with width and height parameters, :baseline is\n  ignored, and treated as :top. (Otherwise, text would by default draw\n  outside the box, since :baseline is the default setting. :baseline is\n  not a useful drawing mode for text drawn in a rectangle.)\n\n  The vertical alignment is based on the value of text-ascent, which\n  many fonts do not specify correctly. It may be necessary to use a\n  hack and offset by a few pixels by hand so that the offset looks\n  correct. To do this as less of a hack, use some percentage of\n  text-ascent or text-descent so that the hack works even if you\n  change the size of the font."}, text-width {:category "Typography", :protocol-inline nil, :meta {:category "Typography", :added "1.0", :subcategory "Attributes", :file quil.core, :end-column 13, :processing-name "textWidth()", :column 3, :requires-bindings true, :line 4355, :end-line 4355, :arglists (quote ([data])), :doc "Calculates and returns the width of any text string."}, :added "1.0", :name quil.core$macros/text-width, :variadic false, :subcategory "Attributes", :file nil, :end-column 13, :processing-name "textWidth()", :method-params ([data]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 4349, :end-line 4355, :max-fixed-arity 1, :fn-var true, :arglists (quote ([data])), :doc "Calculates and returns the width of any text string."}, mouse-x {:category "Input", :protocol-inline nil, :meta {:category "Input", :added "1.0", :subcategory "Mouse", :file quil.core, :end-column 10, :processing-name "mouseX", :column 3, :requires-bindings true, :line 2597, :end-line 2597, :arglists (quote ([])), :doc "Current horizontal coordinate of the mouse."}, :added "1.0", :name quil.core$macros/mouse-x, :variadic false, :subcategory "Mouse", :file nil, :end-column 10, :processing-name "mouseX", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2591, :end-line 2597, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Current horizontal coordinate of the mouse."}, TWO-PI {:name quil.core$macros/TWO-PI, :file nil, :line 80, :column 1, :end-line 80, :end-column 12, :meta {:file quil.core, :line 80, :column 6, :end-line 80, :end-column 12}}, mag {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Calculation", :file quil.core, :end-column 6, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([a b] [a b c]), :arglists ([a b] [a b c]), :arglists-meta (nil nil)}, :processing-name "mag()", :column 3, :requires-bindings false, :line 2420, :end-line 2420, :arglists (quote ([a b] [a b c])), :doc "Calculates the magnitude (or length) of a vector. A vector is a\n  direction in space commonly used in computer graphics and linear\n  algebra. Because it has no start position, the magnitude of a vector\n  can be thought of as the distance from coordinate (0,0) to its (x,y)\n  value. Therefore, mag is a shortcut for writing (dist 0 0 x y)."}, :added "1.0", :name quil.core$macros/mag, :variadic false, :subcategory "Calculation", :file nil, :end-column 6, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([a b] [a b c]), :arglists ([a b] [a b c]), :arglists-meta (nil nil)}, :processing-name "mag()", :method-params ([a b] [a b c]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 2414, :end-line 2420, :max-fixed-arity 3, :fn-var true, :arglists ([a b] [a b c]), :doc "Calculates the magnitude (or length) of a vector. A vector is a\n  direction in space commonly used in computer graphics and linear\n  algebra. Because it has no start position, the magnitude of a vector\n  can be thought of as the distance from coordinate (0,0) to its (x,y)\n  value. Therefore, mag is a shortcut for writing (dist 0 0 x y)."}, exit {:category "Structure", :protocol-inline nil, :meta {:category "Structure", :added "1.0", :subcategory nil, :file quil.core, :end-column 7, :processing-name "exit()", :column 3, :requires-bindings true, :line 1652, :end-line 1652, :arglists (quote ([])), :doc "Quits/stops/exits the program.  Rather than terminating\n  immediately, exit will cause the sketch to exit after draw has\n  completed (or after setup completes if called during the setup\n  method). "}, :added "1.0", :name quil.core$macros/exit, :variadic false, :subcategory nil, :file nil, :end-column 7, :processing-name "exit()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1646, :end-line 1652, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Quits/stops/exits the program.  Rather than terminating\n  immediately, exit will cause the sketch to exit after draw has\n  completed (or after setup completes if called during the setup\n  method). "}, map-range {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Calculation", :file quil.core, :end-column 12, :processing-name "map()", :column 3, :requires-bindings false, :line 2439, :end-line 2439, :arglists (quote ([val low1 high1 low2 high2])), :doc "Re-maps a number from one range to another.\n\n  Numbers outside the range are not clamped to 0 and 1, because\n  out-of-range values are often intentional and useful."}, :added "1.0", :name quil.core$macros/map-range, :variadic false, :subcategory "Calculation", :file nil, :end-column 12, :processing-name "map()", :method-params ([val low1 high1 low2 high2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 2433, :end-line 2439, :max-fixed-arity 5, :fn-var true, :arglists (quote ([val low1 high1 low2 high2])), :doc "Re-maps a number from one range to another.\n\n  Numbers outside the range are not clamped to 0 and 1, because\n  out-of-range values are often intentional and useful."}, model-x {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Coordinates", :file quil.core, :end-column 10, :processing-name "modelX()", :column 3, :requires-bindings true, :line 2502, :end-line 2502, :arglists (quote ([x y z])), :doc "Returns the three-dimensional x, y, z position in model space. This\n  returns the x value for a given coordinate based on the current set\n  of transformations (scale, rotate, translate, etc.) The x value can\n  be used to place an object in space relative to the location of the\n  original point once the transformations are no longer in use."}, :added "1.0", :name quil.core$macros/model-x, :variadic false, :subcategory "Coordinates", :file nil, :end-column 10, :processing-name "modelX()", :method-params ([x y z]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2496, :end-line 2502, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x y z])), :doc "Returns the three-dimensional x, y, z position in model space. This\n  returns the x value for a given coordinate based on the current set\n  of transformations (scale, rotate, translate, etc.) The x value can\n  be used to place an object in space relative to the location of the\n  original point once the transformations are no longer in use."}, sqrt {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Calculation", :file quil.core, :end-column 7, :processing-name "sqrt()", :column 3, :requires-bindings false, :line 3942, :end-line 3942, :arglists (quote ([a])), :doc "Calculates the square root of a number. The square root of a number\n  is always positive, even though there may be a valid negative\n  root. The square root s of number a is such that (= a (* s s)) . It\n  is the opposite of squaring."}, :added "1.0", :name quil.core$macros/sqrt, :variadic false, :subcategory "Calculation", :file nil, :end-column 7, :processing-name "sqrt()", :method-params ([a]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 3936, :end-line 3942, :max-fixed-arity 1, :fn-var true, :arglists (quote ([a])), :doc "Calculates the square root of a number. The square root of a number\n  is always positive, even though there may be a valid negative\n  root. The square root s of number a is such that (= a (* s s)) . It\n  is the opposite of squaring."}, saturation {:category "Color", :protocol-inline nil, :meta {:category "Color", :added "1.0", :subcategory "Creating & Reading", :file quil.core, :end-column 13, :processing-name "saturation()", :column 3, :requires-bindings true, :line 3493, :end-line 3493, :arglists (quote ([c])), :doc "Extracts the saturation value from a color."}, :added "1.0", :name quil.core$macros/saturation, :variadic false, :subcategory "Creating & Reading", :file nil, :end-column 13, :processing-name "saturation()", :method-params ([c]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3487, :end-line 3493, :max-fixed-arity 1, :fn-var true, :arglists (quote ([c])), :doc "Extracts the saturation value from a color."}, prc-print {:category "Output", :protocol-inline nil, :meta {:category "Output", :added "1.0", :subcategory "Text area", :file quil.core, :end-column 15, :column 6, :require-bindings true, :line 170, :end-line 170, :arglists (quote ([msg])), :doc "Writes to the console area of the Processing environment.\n  This is often helpful for looking at the data a program is producing.\n  The companion function println() works like print(), but creates a new line of text for each call to the function.\n   Individual elements can be separated with quotes (\"\") and joined with the addition operator (+). "}, :added "1.0", :name quil.core$macros/prc-print, :variadic false, :subcategory "Text area", :file nil, :end-column 15, :method-params ([msg]), :protocol-impl nil, :arglists-meta (nil nil), :column 4, :require-bindings true, :line 165, :end-line 170, :max-fixed-arity 1, :fn-var true, :arglists (quote ([msg])), :doc "Writes to the console area of the Processing environment.\n  This is often helpful for looking at the data a program is producing.\n  The companion function println() works like print(), but creates a new line of text for each call to the function.\n   Individual elements can be separated with quotes (\"\") and joined with the addition operator (+). "}, text-font {:category "Typography", :protocol-inline nil, :meta {:category "Typography", :added "1.0", :subcategory "Loading & Displaying", :file quil.core, :end-column 12, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([font] [font size]), :arglists ([font] [font size]), :arglists-meta (nil nil)}, :processing-name "textFont()", :column 3, :requires-bindings true, :line 4222, :end-line 4222, :arglists (quote ([font] [font size])), :doc "Sets the current font that will be drawn with the text\n  function. Fonts must be loaded with load-font before it can be\n  used. This font will be used in all subsequent calls to the text\n  function. If no size parameter is input, the font will appear at its\n  original size until it is changed with text-size.\n\n  Because fonts are usually bitmaped, you should create fonts at the\n  sizes that will be used most commonly. Using textFont without the\n  size parameter will result in the cleanest-looking text.\n\n  With the default (JAVA2D) and PDF renderers, it's also possible to\n  enable the use of native fonts via the command\n  (hint :enable-native-fonts). This will produce vector text in JAVA2D\n  sketches and PDF output in cases where the vector data is available:\n  when the font is still installed, or the font is created via the\n  create-font fn"}, :added "1.0", :name quil.core$macros/text-font, :variadic false, :subcategory "Loading & Displaying", :file nil, :end-column 12, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([font] [font size]), :arglists ([font] [font size]), :arglists-meta (nil nil)}, :processing-name "textFont()", :method-params ([font] [font size]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 4216, :end-line 4222, :max-fixed-arity 2, :fn-var true, :arglists ([font] [font size]), :doc "Sets the current font that will be drawn with the text\n  function. Fonts must be loaded with load-font before it can be\n  used. This font will be used in all subsequent calls to the text\n  function. If no size parameter is input, the font will appear at its\n  original size until it is changed with text-size.\n\n  Because fonts are usually bitmaped, you should create fonts at the\n  sizes that will be used most commonly. Using textFont without the\n  size parameter will result in the cleanest-looking text.\n\n  With the default (JAVA2D) and PDF renderers, it's also possible to\n  enable the use of native fonts via the command\n  (hint :enable-native-fonts). This will produce vector text in JAVA2D\n  sketches and PDF output in cases where the vector data is available:\n  when the font is still installed, or the font is created via the\n  create-font fn"}, scale {:category "Transform", :protocol-inline nil, :meta {:category "Transform", :added "1.0", :subcategory nil, :file quil.core, :end-column 8, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([s] [sx sy] [sx sy sz]), :arglists ([s] [sx sy] [sx sy sz]), :arglists-meta (nil nil nil)}, :processing-name "scale()", :column 3, :requires-bindings true, :line 3542, :end-line 3542, :arglists (quote ([s] [sx sy] [sx sy sz])), :doc "Increases or decreases the size of a shape by expanding and\n  contracting vertices. Objects always scale from their relative\n  origin to the coordinate system. Scale values are specified as\n  decimal percentages. For example, the function call (scale 2)\n  increases the dimension of a shape by 200%. Transformations apply to\n  everything that happens after and subsequent calls to the function\n  multiply the effect. For example, calling (scale 2) and then\n  (scale 1.5) is the same as (scale 3). If scale is called within\n  draw, the transformation is reset when the loop begins again. Using\n  this fuction with the z parameter requires specfying :p3d or :opengl\n  as the renderer. This function can be further controlled by\n  push-matrix and pop-matrix."}, :added "1.0", :name quil.core$macros/scale, :variadic false, :subcategory nil, :file nil, :end-column 8, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([s] [sx sy] [sx sy sz]), :arglists ([s] [sx sy] [sx sy sz]), :arglists-meta (nil nil nil)}, :processing-name "scale()", :method-params ([s] [sx sy] [sx sy sz]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :requires-bindings true, :line 3536, :end-line 3542, :max-fixed-arity 3, :fn-var true, :arglists ([s] [sx sy] [sx sy sz]), :doc "Increases or decreases the size of a shape by expanding and\n  contracting vertices. Objects always scale from their relative\n  origin to the coordinate system. Scale values are specified as\n  decimal percentages. For example, the function call (scale 2)\n  increases the dimension of a shape by 200%. Transformations apply to\n  everything that happens after and subsequent calls to the function\n  multiply the effect. For example, calling (scale 2) and then\n  (scale 1.5) is the same as (scale 3). If scale is called within\n  draw, the transformation is reset when the loop begins again. Using\n  this fuction with the z parameter requires specfying :p3d or :opengl\n  as the renderer. This function can be further controlled by\n  push-matrix and pop-matrix."}, defsketch {:category "Environment", :protocol-inline nil, :meta {:category "Environment", :added "1.0", :subcategory nil, :file quil.core, :end-column 13, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env app-name options)], :arglists ([&form &env app-name & options]), :arglists-meta (nil)}, :column 4, :requires-bindings false, :line 4688, :macro true, :end-line 4688, :arglists (quote ([app-name & options])), :doc "Define and start a sketch and bind it to a var with the symbol\n  app-name. If any of the options to the various callbacks are\n  symbols, it wraps them in a call to var to ensure they aren't\n  inlined and that redefinitions to the original fns are reflected in\n  the visualisation.\n\n  Available options:\n\n   :size           - A vector of width and height for the sketch or :fullscreen.\n                     Defaults to [500 300]. If you're using :fullscreen you may\n                     want to enable present mode - :features [:present]\n\n   :renderer       - Specifies the renderer type. One of :p2d, :p3d, :java2d,\n                     :opengl, :pdf). Defaults to :java2d. :dxf renderer\n                     can't be used as sketch renderer. Use begin-raw method\n                     instead. In clojurescript only :p2d and :p3d renderers\n                     are supported.\n\n   :output-file    - Specifies an output file path. Only used in :pdf mode.\n                     Not supported in clojurescript.\n\n   :title          - A string which will be displayed at the top of\n                     the sketch window. Not supported in clojurescript.\n\n   :features       - A vector of keywords customizing sketch behaviour.\n                     Supported features:\n\n                     :keep-on-top - Sketch window will always be above other\n                                    windows. Note: some platforms might not\n                                    support always-on-top windows.\n                                    Not supported in clojurescript.\n\n                     :exit-on-close - Shutdown JVM  when sketch is closed.\n                                      Not supported in clojurescript.\n\n                     :resizable - Makes sketch resizable.\n                                  Not supported in clojurescript.\n\n                     :no-safe-fns - Do not catch and print exceptions thrown\n                                    inside functions provided to sketch (like\n                                    draw, mouse-click, key-pressed and\n                                    other). By default all exceptions thrown\n                                    inside these functions are catched. This\n                                    prevents sketch from breaking when bad\n                                    function was provided and allows you to\n                                    fix it and reload it on fly. You can\n                                    disable this behaviour by enabling\n                                    :no-safe-fns feature.\n                                    Not supported in clojurescript.\n\n                     :present - Switch to present mode (fullscreen without\n                                borders, OS panels). You may want to use\n                                this feature together with :size :fullscreen.\n                                Not supported in clojurescript.\n\n                     :no-start - Disables autostart if sketch was created using\n                                 defsketch macro. To start sketch you have to\n                                 call function created defsketch.\n                                 Supported only in clojurescript.\n\n                     :global-key-events - Allows a sketch to receive any\n                                          keyboard event sent to the page,\n                                          regardless of whether the canvas it is\n                                          loaded in has focus or not.\n                                          Supported only in clojurescript.\n\n                     Usage example: :features [:keep-on-top :present]\n\n   :bgcolor        - Sets background color for unused space in present mode.\n                     Color is specified in hex format: #XXXXXX.\n                     Example: :bgcolor \"#00FFFF\" (cyan background)\n                     Not supported in clojurescript.\n\n   :display        - Sets what display should be used by this sketch.\n                     Displays are numbered starting from 0. Example: :display 1.\n                     Not supported in clojurescript.\n\n   :setup          - A function to be called once when setting the sketch up.\n\n   :draw           - A function to be repeatedly called at most n times per\n                     second where n is the target frame-rate set for\n                     the visualisation.\n\n   :host           - String id of canvas element or DOM element itself.\n                     Specifies host for the sketch. Must be specified in sketch,\n                     may be omitted in defsketch. If ommitted in defsketch,\n                     :host is set to the name of the sketch. If element with\n                     specified id is not found on the page and page is empty -\n                     new canvas element will be created. Used in clojurescript.\n\n   :focus-gained   - Called when the sketch gains focus.\n                     Not supported in clojurescript.\n\n   :focus-lost     - Called when the sketch loses focus.\n                     Not supported in clojurescript.\n\n   :mouse-entered  - Called when the mouse enters the sketch window.\n\n   :mouse-exited   - Called when the mouse leaves the sketch window\n\n   :mouse-pressed  - Called every time a mouse button is pressed.\n\n   :mouse-released - Called every time a mouse button is released.\n\n   :mouse-clicked  - called once after a mouse button has been pressed\n                     and then released.\n\n   :mouse-moved    - Called every time the mouse moves and a button is\n                     not pressed.\n\n   :mouse-dragged  - Called every time the mouse moves and a button is\n                     pressed.\n\n   :mouse-wheel    - Called every time mouse wheel is rotated.\n                     Takes 1 argument - wheel rotation, an int.\n                     Negative values if the mouse wheel was rotated\n                     up/away from the user, and positive values\n                     if the mouse wheel was rotated down/ towards the user\n\n   :key-pressed    - Called every time any key is pressed.\n\n   :key-released   - Called every time any key is released.\n\n   :key-typed      - Called once every time non-modifier keys are\n                     pressed.\n\n   :on-close       - Called once, when sketch is closed\n                     Not supported in clojurescript.\n\n   :middleware     - Vector of middleware to be applied to the sketch.\n                     Middleware will be applied in the same order as in comp\n                     function: [f g] will be applied as (f (g options)).\n\n   :settings       - cousin of :setup. A function to be called once when\n                     setting sketch up. Should be used only for (smooth) and\n                     (no-smooth). Due to Processing limitations these functions\n                     cannot be used neither in :setup nor in :draw."}, :added "1.0", :name quil.core$macros/defsketch, :variadic true, :subcategory nil, :file nil, :end-column 13, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env app-name options)], :arglists ([&form &env app-name & options]), :arglists-meta (nil)}, :method-params [(&form &env app-name options)], :protocol-impl nil, :arglists-meta (nil), :column 1, :requires-bindings false, :line 4684, :macro true, :end-line 4688, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env app-name & options]), :doc "Define and start a sketch and bind it to a var with the symbol\n  app-name. If any of the options to the various callbacks are\n  symbols, it wraps them in a call to var to ensure they aren't\n  inlined and that redefinitions to the original fns are reflected in\n  the visualisation.\n\n  Available options:\n\n   :size           - A vector of width and height for the sketch or :fullscreen.\n                     Defaults to [500 300]. If you're using :fullscreen you may\n                     want to enable present mode - :features [:present]\n\n   :renderer       - Specifies the renderer type. One of :p2d, :p3d, :java2d,\n                     :opengl, :pdf). Defaults to :java2d. :dxf renderer\n                     can't be used as sketch renderer. Use begin-raw method\n                     instead. In clojurescript only :p2d and :p3d renderers\n                     are supported.\n\n   :output-file    - Specifies an output file path. Only used in :pdf mode.\n                     Not supported in clojurescript.\n\n   :title          - A string which will be displayed at the top of\n                     the sketch window. Not supported in clojurescript.\n\n   :features       - A vector of keywords customizing sketch behaviour.\n                     Supported features:\n\n                     :keep-on-top - Sketch window will always be above other\n                                    windows. Note: some platforms might not\n                                    support always-on-top windows.\n                                    Not supported in clojurescript.\n\n                     :exit-on-close - Shutdown JVM  when sketch is closed.\n                                      Not supported in clojurescript.\n\n                     :resizable - Makes sketch resizable.\n                                  Not supported in clojurescript.\n\n                     :no-safe-fns - Do not catch and print exceptions thrown\n                                    inside functions provided to sketch (like\n                                    draw, mouse-click, key-pressed and\n                                    other). By default all exceptions thrown\n                                    inside these functions are catched. This\n                                    prevents sketch from breaking when bad\n                                    function was provided and allows you to\n                                    fix it and reload it on fly. You can\n                                    disable this behaviour by enabling\n                                    :no-safe-fns feature.\n                                    Not supported in clojurescript.\n\n                     :present - Switch to present mode (fullscreen without\n                                borders, OS panels). You may want to use\n                                this feature together with :size :fullscreen.\n                                Not supported in clojurescript.\n\n                     :no-start - Disables autostart if sketch was created using\n                                 defsketch macro. To start sketch you have to\n                                 call function created defsketch.\n                                 Supported only in clojurescript.\n\n                     :global-key-events - Allows a sketch to receive any\n                                          keyboard event sent to the page,\n                                          regardless of whether the canvas it is\n                                          loaded in has focus or not.\n                                          Supported only in clojurescript.\n\n                     Usage example: :features [:keep-on-top :present]\n\n   :bgcolor        - Sets background color for unused space in present mode.\n                     Color is specified in hex format: #XXXXXX.\n                     Example: :bgcolor \"#00FFFF\" (cyan background)\n                     Not supported in clojurescript.\n\n   :display        - Sets what display should be used by this sketch.\n                     Displays are numbered starting from 0. Example: :display 1.\n                     Not supported in clojurescript.\n\n   :setup          - A function to be called once when setting the sketch up.\n\n   :draw           - A function to be repeatedly called at most n times per\n                     second where n is the target frame-rate set for\n                     the visualisation.\n\n   :host           - String id of canvas element or DOM element itself.\n                     Specifies host for the sketch. Must be specified in sketch,\n                     may be omitted in defsketch. If ommitted in defsketch,\n                     :host is set to the name of the sketch. If element with\n                     specified id is not found on the page and page is empty -\n                     new canvas element will be created. Used in clojurescript.\n\n   :focus-gained   - Called when the sketch gains focus.\n                     Not supported in clojurescript.\n\n   :focus-lost     - Called when the sketch loses focus.\n                     Not supported in clojurescript.\n\n   :mouse-entered  - Called when the mouse enters the sketch window.\n\n   :mouse-exited   - Called when the mouse leaves the sketch window\n\n   :mouse-pressed  - Called every time a mouse button is pressed.\n\n   :mouse-released - Called every time a mouse button is released.\n\n   :mouse-clicked  - called once after a mouse button has been pressed\n                     and then released.\n\n   :mouse-moved    - Called every time the mouse moves and a button is\n                     not pressed.\n\n   :mouse-dragged  - Called every time the mouse moves and a button is\n                     pressed.\n\n   :mouse-wheel    - Called every time mouse wheel is rotated.\n                     Takes 1 argument - wheel rotation, an int.\n                     Negative values if the mouse wheel was rotated\n                     up/away from the user, and positive values\n                     if the mouse wheel was rotated down/ towards the user\n\n   :key-pressed    - Called every time any key is pressed.\n\n   :key-released   - Called every time any key is released.\n\n   :key-typed      - Called once every time non-modifier keys are\n                     pressed.\n\n   :on-close       - Called once, when sketch is closed\n                     Not supported in clojurescript.\n\n   :middleware     - Vector of middleware to be applied to the sketch.\n                     Middleware will be applied in the same order as in comp\n                     function: [f g] will be applied as (f (g options)).\n\n   :settings       - cousin of :setup. A function to be called once when\n                     setting sketch up. Should be used only for (smooth) and\n                     (no-smooth). Due to Processing limitations these functions\n                     cannot be used neither in :setup nor in :draw."}, no-stroke {:category "Color", :protocol-inline nil, :meta {:category "Color", :added "1.0", :subcategory "Setting", :file quil.core, :end-column 12, :processing-name "noStroke()", :column 3, :requires-bindings true, :line 2815, :end-line 2815, :arglists (quote ([])), :doc "Disables drawing the stroke (outline). If both no-stroke and\n  no-fill are called, nothing will be drawn to the screen."}, :added "1.0", :name quil.core$macros/no-stroke, :variadic false, :subcategory "Setting", :file nil, :end-column 12, :processing-name "noStroke()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2809, :end-line 2815, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Disables drawing the stroke (outline). If both no-stroke and\n  no-fill are called, nothing will be drawn to the screen."}, end-camera {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Camera", :file quil.core, :end-column 13, :processing-name "endCamera()", :column 3, :requires-bindings true, :line 1593, :end-line 1593, :arglists (quote ([])), :doc "Unsets the matrix mode from the camera matrix. See begin-camera."}, :added "1.0", :name quil.core$macros/end-camera, :variadic false, :subcategory "Camera", :file nil, :end-column 13, :processing-name "endCamera()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1587, :end-line 1593, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Unsets the matrix mode from the camera matrix. See begin-camera."}, random-seed {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Random", :file quil.core, :end-column 14, :processing-name "randomSeed()", :column 3, :requires-bindings true, :line 3196, :end-line 3196, :arglists (quote ([w])), :doc "Sets the seed value for random. By default, random produces\n  different results each time the program is run. Set the value\n  parameter to a constant to return the same pseudo-random numbers\n  each time the software is run."}, :added "1.0", :name quil.core$macros/random-seed, :variadic false, :subcategory "Random", :file nil, :end-column 14, :processing-name "randomSeed()", :method-params ([w]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3190, :end-line 3196, :max-fixed-arity 1, :fn-var true, :arglists (quote ([w])), :doc "Sets the seed value for random. By default, random produces\n  different results each time the program is run. Set the value\n  parameter to a constant to return the same pseudo-random numbers\n  each time the software is run."}, model-z {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Coordinates", :file quil.core, :end-column 10, :processing-name "modelZ()", :column 3, :requires-bindings true, :line 2532, :end-line 2532, :arglists (quote ([x y z])), :doc "Returns the three-dimensional x, y, z position in model space. This\n  returns the z value for a given coordinate based on the current set\n  of transformations (scale, rotate, translate, etc.) The z value can\n  be used to place an object in space relative to the location of the\n  original point once the transformations are no longer in use."}, :added "1.0", :name quil.core$macros/model-z, :variadic false, :subcategory "Coordinates", :file nil, :end-column 10, :processing-name "modelZ()", :method-params ([x y z]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2526, :end-line 2532, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x y z])), :doc "Returns the three-dimensional x, y, z position in model space. This\n  returns the z value for a given coordinate based on the current set\n  of transformations (scale, rotate, translate, etc.) The z value can\n  be used to place an object in space relative to the location of the\n  original point once the transformations are no longer in use."}, light-specular {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Lights", :file quil.core, :end-column 17, :processing-name "lightSpecular()", :column 3, :requires-bindings true, :line 2285, :end-line 2285, :arglists (quote ([r g b])), :doc "Sets the specular color for lights. Like fill, it affects only the\n  elements which are created after it in the code. Specular refers to\n  light which bounces off a surface in a perferred direction (rather\n  than bouncing in all directions like a diffuse light) and is used\n  for creating highlights. The specular quality of a light interacts\n  with the specular material qualities set through the specular and\n  shininess functions."}, :added "1.0", :name quil.core$macros/light-specular, :variadic false, :subcategory "Lights", :file nil, :end-column 17, :processing-name "lightSpecular()", :method-params ([r g b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2279, :end-line 2285, :max-fixed-arity 3, :fn-var true, :arglists (quote ([r g b])), :doc "Sets the specular color for lights. Like fill, it affects only the\n  elements which are created after it in the code. Specular refers to\n  light which bounces off a surface in a perferred direction (rather\n  than bouncing in all directions like a diffuse light) and is used\n  for creating highlights. The specular quality of a light interacts\n  with the specular material qualities set through the specular and\n  shininess functions."}, key-as-keyword {:category "Input", :protocol-inline nil, :meta {:category "Input", :added "1.6", :subcategory "Keyboard", :file quil.core, :end-column 17, :processing-name nil, :column 3, :requires-bindings true, :line 4852, :end-line 4852, :arglists (quote ([])), :doc "Returns a keyword representing the currently pressed key. Modifier\n  keys are represented as: :up, :down, :left, :right, :alt, :control,\n  :shift, :command, :f1-24"}, :added "1.6", :name quil.core$macros/key-as-keyword, :variadic false, :subcategory "Keyboard", :file nil, :end-column 17, :processing-name nil, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 4847, :end-line 4852, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Returns a keyword representing the currently pressed key. Modifier\n  keys are represented as: :up, :down, :left, :right, :alt, :control,\n  :shift, :command, :f1-24"}, dist {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Calculation", :file quil.core, :end-column 7, :top-fn {:variadic false, :max-fixed-arity 6, :method-params ([x1 y1 x2 y2] [x1 y1 z1 x2 y2 z2]), :arglists ([x1 y1 x2 y2] [x1 y1 z1 x2 y2 z2]), :arglists-meta (nil nil)}, :processing-name "dist()", :column 3, :requires-bindings false, :line 1497, :end-line 1497, :arglists (quote ([x1 y1 x2 y2] [x1 y1 z1 x2 y2 z2])), :doc "Calculates the distance between two points"}, :added "1.0", :name quil.core$macros/dist, :variadic false, :subcategory "Calculation", :file nil, :end-column 7, :top-fn {:variadic false, :max-fixed-arity 6, :method-params ([x1 y1 x2 y2] [x1 y1 z1 x2 y2 z2]), :arglists ([x1 y1 x2 y2] [x1 y1 z1 x2 y2 z2]), :arglists-meta (nil nil)}, :processing-name "dist()", :method-params ([x1 y1 x2 y2] [x1 y1 z1 x2 y2 z2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 1491, :end-line 1497, :max-fixed-arity 6, :fn-var true, :arglists ([x1 y1 x2 y2] [x1 y1 z1 x2 y2 z2]), :doc "Calculates the distance between two points"}, PI {:name quil.core$macros/PI, :file nil, :line 76, :column 10, :end-line 76, :end-column 17, :meta {:file quil.core, :line 76, :column 15, :end-line 76, :end-column 17}}, norm {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Calculation", :file quil.core, :end-column 7, :processing-name "norm()", :column 3, :requires-bindings true, :line 2776, :end-line 2776, :arglists (quote ([val start stop])), :doc "Normalize a value to exist between 0 and 1 (inclusive)."}, :added "1.0", :name quil.core$macros/norm, :variadic false, :subcategory "Calculation", :file nil, :end-column 7, :processing-name "norm()", :method-params ([val start stop]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2770, :end-line 2776, :max-fixed-arity 3, :fn-var true, :arglists (quote ([val start stop])), :doc "Normalize a value to exist between 0 and 1 (inclusive)."}, end-shape {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "Vertex", :file quil.core, :end-column 12, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [mode]), :arglists ([] [mode]), :arglists-meta (nil nil)}, :processing-name "endShape()", :column 3, :requires-bindings true, :line 1632, :end-line 1632, :arglists (quote ([] [mode])), :doc "May only be called after begin-shape. When end-shape is called,\n  all of image data defined since the previous call to begin-shape is\n  written into the image buffer. The keyword :close may be passed to\n  close the shape (to connect the beginning and the end)."}, :added "1.0", :name quil.core$macros/end-shape, :variadic false, :subcategory "Vertex", :file nil, :end-column 12, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [mode]), :arglists ([] [mode]), :arglists-meta (nil nil)}, :processing-name "endShape()", :method-params ([] [mode]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1626, :end-line 1632, :max-fixed-arity 1, :fn-var true, :arglists ([] [mode]), :doc "May only be called after begin-shape. When end-shape is called,\n  all of image data defined since the previous call to begin-shape is\n  written into the image buffer. The keyword :close may be passed to\n  close the shape (to connect the beginning and the end)."}, fill {:category "Color", :protocol-inline nil, :meta {:category "Color", :added "1.0", :subcategory "Setting", :file quil.core, :end-column 7, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([rgb] [rgb alpha] [r g b] [r g b a]), :arglists ([rgb] [rgb alpha] [r g b] [r g b a]), :arglists-meta (nil nil nil nil)}, :processing-name "fill()", :column 3, :requires-bindings true, :line 1722, :end-line 1722, :arglists (quote ([rgb] [rgb alpha] [r g b] [r g b a])), :doc "Sets the color used to fill shapes."}, :added "1.0", :name quil.core$macros/fill, :variadic false, :subcategory "Setting", :file nil, :end-column 7, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([rgb] [rgb alpha] [r g b] [r g b a]), :arglists ([rgb] [rgb alpha] [r g b] [r g b a]), :arglists-meta (nil nil nil nil)}, :processing-name "fill()", :method-params ([rgb] [rgb alpha] [r g b] [r g b a]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :requires-bindings true, :line 1716, :end-line 1722, :max-fixed-arity 4, :fn-var true, :arglists ([rgb] [rgb alpha] [r g b] [r g b a]), :doc "Sets the color used to fill shapes."}, with-translation {:category "Transform", :protocol-inline nil, :meta {:category "Transform", :added "1.0", :subcategory "Utility Macros", :file quil.core, :end-column 19, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env translation-vector body)], :arglists ([&form &env translation-vector & body]), :arglists-meta (nil)}, :processing-name nil, :column 3, :requires-bindings true, :line 4623, :macro true, :end-line 4623, :arglists (quote ([translation-vector & body])), :doc "Performs body with translation, restores current transformation on\n  exit."}, :added "1.0", :name quil.core$macros/with-translation, :variadic true, :subcategory "Utility Macros", :file nil, :end-column 19, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env translation-vector body)], :arglists ([&form &env translation-vector & body]), :arglists-meta (nil)}, :processing-name nil, :method-params [(&form &env translation-vector body)], :protocol-impl nil, :arglists-meta (nil), :column 1, :requires-bindings true, :line 4617, :macro true, :end-line 4623, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env translation-vector & body]), :doc "Performs body with translation, restores current transformation on\n  exit."}, reset-matrix {:category "Transform", :protocol-inline nil, :meta {:category "Transform", :added "1.0", :subcategory nil, :file quil.core, :end-column 15, :processing-name "resetMatrix()", :column 3, :requires-bindings true, :line 3336, :end-line 3336, :arglists (quote ([])), :doc "Replaces the current matrix with the identity matrix. The\n  equivalent function in OpenGL is glLoadIdentity()"}, :added "1.0", :name quil.core$macros/reset-matrix, :variadic false, :subcategory nil, :file nil, :end-column 15, :processing-name "resetMatrix()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3330, :end-line 3336, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Replaces the current matrix with the identity matrix. The\n  equivalent function in OpenGL is glLoadIdentity()"}, emissive-float {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Material Properties", :file quil.core, :end-column 17, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([float-val] [r g b]), :arglists ([float-val] [r g b]), :arglists-meta (nil nil)}, :processing-name "emissive()", :column 3, :requires-bindings true, :line 1547, :end-line 1547, :arglists (quote ([float-val] [r g b])), :doc "Sets the emissive color of the material used for drawing shapes\n drawn to the screen. Used in combination with ambient, specular, and\n shininess in setting the material properties of shapes. Converts all\n args to floats"}, :added "1.0", :name quil.core$macros/emissive-float, :variadic false, :subcategory "Material Properties", :file nil, :end-column 17, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([float-val] [r g b]), :arglists ([float-val] [r g b]), :arglists-meta (nil nil)}, :processing-name "emissive()", :method-params ([float-val] [r g b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1541, :end-line 1547, :max-fixed-arity 3, :fn-var true, :arglists ([float-val] [r g b]), :doc "Sets the emissive color of the material used for drawing shapes\n drawn to the screen. Used in combination with ambient, specular, and\n shininess in setting the material properties of shapes. Converts all\n args to floats"}, shape-modes {:name quil.core$macros/shape-modes, :file nil, :line 45, :column 1, :end-line 47, :end-column 13, :meta {:file quil.core, :line 47, :column 2, :end-line 47, :end-column 13}}, green {:category "Color", :protocol-inline nil, :meta {:category "Color", :added "1.0", :subcategory "Creating & Reading", :file quil.core, :end-column 8, :processing-name "green()", :column 3, :requires-bindings true, :line 1919, :end-line 1919, :arglists (quote ([col])), :doc "Extracts the green value from a color, scaled to match current\n  color-mode. This value is always returned as a float so be careful\n  not to assign it to an int value."}, :added "1.0", :name quil.core$macros/green, :variadic false, :subcategory "Creating & Reading", :file nil, :end-column 8, :processing-name "green()", :method-params ([col]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1913, :end-line 1919, :max-fixed-arity 1, :fn-var true, :arglists (quote ([col])), :doc "Extracts the green value from a color, scaled to match current\n  color-mode. This value is always returned as a float so be careful\n  not to assign it to an int value."}, HALF-PI {:name quil.core$macros/HALF-PI, :file nil, :line 77, :column 1, :end-line 77, :end-column 13, :meta {:file quil.core, :line 77, :column 6, :end-line 77, :end-column 13}}, begin-contour {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "2.0", :subcategory "Vertex", :file quil.core, :end-column 16, :processing-name "beginContour()", :column 3, :requires-bindings true, :line 602, :end-line 602, :arglists (quote ([])), :doc "Use the begin-contour and end-contour function to create negative\n  shapes within shapes. These functions can only be within a\n  begin-shape/end-shape pair and they only work with the :p2d and :p3d\n  renderers."}, :added "2.0", :name quil.core$macros/begin-contour, :variadic false, :subcategory "Vertex", :file nil, :end-column 16, :processing-name "beginContour()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 596, :end-line 602, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Use the begin-contour and end-contour function to create negative\n  shapes within shapes. These functions can only be within a\n  begin-shape/end-shape pair and they only work with the :p2d and :p3d\n  renderers."}, DEG-TO-RAD {:name quil.core$macros/DEG-TO-RAD, :file nil, :line 82, :column 1, :end-line 82, :end-column 16, :meta {:file quil.core, :line 82, :column 6, :end-line 82, :end-column 16}}, pow {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Calculation", :file quil.core, :end-column 6, :processing-name "pow()", :column 3, :requires-bindings false, :line 3011, :end-line 3011, :arglists (quote ([num exponent])), :doc "Facilitates exponential expressions. The pow() function is an\n  efficient way of multiplying numbers by themselves (or their\n  reciprocal) in large quantities. For example, (pow 3 5) is\n  equivalent to the expression (* 3 3 3 3 3) and (pow 3 -5) is\n  equivalent to (/ 1 (* 3 3 3 3 3))."}, :added "1.0", :name quil.core$macros/pow, :variadic false, :subcategory "Calculation", :file nil, :end-column 6, :processing-name "pow()", :method-params ([num exponent]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 3005, :end-line 3011, :max-fixed-arity 2, :fn-var true, :arglists (quote ([num exponent])), :doc "Facilitates exponential expressions. The pow() function is an\n  efficient way of multiplying numbers by themselves (or their\n  reciprocal) in large quantities. For example, (pow 3 5) is\n  equivalent to the expression (* 3 3 3 3 3) and (pow 3 -5) is\n  equivalent to (/ 1 (* 3 3 3 3 3))."}, box {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "3D Primitives", :file quil.core, :end-column 6, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([size] [width height depth]), :arglists ([size] [width height depth]), :arglists-meta (nil nil)}, :processing-name "box()", :column 3, :requires-bindings true, :line 917, :end-line 917, :arglists (quote ([size] [width height depth])), :doc "Creates an extruded rectangle."}, :added "1.0", :name quil.core$macros/box, :variadic false, :subcategory "3D Primitives", :file nil, :end-column 6, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([size] [width height depth]), :arglists ([size] [width height depth]), :arglists-meta (nil nil)}, :processing-name "box()", :method-params ([size] [width height depth]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 911, :end-line 917, :max-fixed-arity 3, :fn-var true, :arglists ([size] [width height depth]), :doc "Creates an extruded rectangle."}, exp {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Calculation", :file quil.core, :end-column 6, :processing-name "exp()", :column 3, :requires-bindings false, :line 1666, :end-line 1666, :arglists (quote ([val])), :doc "Returns Euler's number e (2.71828...) raised to the power of the\n  value parameter."}, :added "1.0", :name quil.core$macros/exp, :variadic false, :subcategory "Calculation", :file nil, :end-column 6, :processing-name "exp()", :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 1660, :end-line 1666, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :doc "Returns Euler's number e (2.71828...) raised to the power of the\n  value parameter."}, with-sketch {:protocol-inline nil, :meta {:file quil.core, :line 190, :column 11, :end-line 190, :end-column 22, :macro true, :arglists (quote ([applet & body])), :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env applet body)], :arglists ([&form &env applet & body]), :arglists-meta (nil)}}, :name quil.core$macros/with-sketch, :variadic true, :file nil, :end-column 22, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env applet body)], :arglists ([&form &env applet & body]), :arglists-meta (nil)}, :method-params [(&form &env applet body)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 190, :macro true, :end-line 190, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env applet & body])}, text-ascent {:category "Typography", :protocol-inline nil, :meta {:category "Typography", :added "1.0", :subcategory "Metrics", :file quil.core, :end-column 14, :processing-name "textAscent()", :column 3, :requires-bindings true, :line 4194, :end-line 4194, :arglists (quote ([])), :doc "Returns the ascent of the current font at its current size. This\n  information is useful for determining the height of the font above\n  the baseline. For example, adding the text-ascent and text-descent\n  values will give you the total height of the line."}, :added "1.0", :name quil.core$macros/text-ascent, :variadic false, :subcategory "Metrics", :file nil, :end-column 14, :processing-name "textAscent()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 4188, :end-line 4194, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Returns the ascent of the current font at its current size. This\n  information is useful for determining the height of the font above\n  the baseline. For example, adding the text-ascent and text-descent\n  values will give you the total height of the line."}, tint-int {:category "Image", :protocol-inline nil, :meta {:category "Image", :added "1.0", :subcategory "Loading & Displaying", :file quil.core, :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([rgb] [rgb alpha]), :arglists ([rgb] [rgb alpha]), :arglists-meta (nil nil)}, :processing-name "tint()", :column 3, :requires-bindings true, :line 4391, :end-line 4391, :arglists (quote ([rgb] [rgb alpha])), :doc "Sets the fill value for displaying images. Images can be tinted to\n  specified colors or made transparent by setting the alpha.\n\n  To make an image transparent, but not change it's color, use white\n  as the tint color and specify an alpha value. For instance,\n  tint(255, 128) will make an image 50% transparent (unless\n  colorMode() has been used).\n\n  The value for the parameter gray must be less than or equal to the\n  current maximum value as specified by colorMode(). The default\n  maximum value is 255.\n\n  Also used to control the coloring of textures in 3D."}, :added "1.0", :name quil.core$macros/tint-int, :variadic false, :subcategory "Loading & Displaying", :file nil, :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([rgb] [rgb alpha]), :arglists ([rgb] [rgb alpha]), :arglists-meta (nil nil)}, :processing-name "tint()", :method-params ([rgb] [rgb alpha]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 4385, :end-line 4391, :max-fixed-arity 2, :fn-var true, :arglists ([rgb] [rgb alpha]), :doc "Sets the fill value for displaying images. Images can be tinted to\n  specified colors or made transparent by setting the alpha.\n\n  To make an image transparent, but not change it's color, use white\n  as the tint color and specify an alpha value. For instance,\n  tint(255, 128) will make an image 50% transparent (unless\n  colorMode() has been used).\n\n  The value for the parameter gray must be less than or equal to the\n  current maximum value as specified by colorMode(). The default\n  maximum value is 255.\n\n  Also used to control the coloring of textures in 3D."}, shininess {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Material Properties", :file quil.core, :end-column 12, :processing-name "shininess()", :column 3, :requires-bindings true, :line 3803, :end-line 3803, :arglists (quote ([shine])), :doc "Sets the amount of gloss in the surface of shapes. Used in\n  combination with ambient, specular, and emissive in setting\n  the material properties of shapes."}, :added "1.0", :name quil.core$macros/shininess, :variadic false, :subcategory "Material Properties", :file nil, :end-column 12, :processing-name "shininess()", :method-params ([shine]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3797, :end-line 3803, :max-fixed-arity 1, :fn-var true, :arglists (quote ([shine])), :doc "Sets the amount of gloss in the surface of shapes. Used in\n  combination with ambient, specular, and emissive in setting\n  the material properties of shapes."}, rect-mode {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "Attributes", :file quil.core, :end-column 12, :processing-name "rectMode()", :column 3, :requires-bindings true, :line 3255, :end-line 3255, :arglists (quote ([mode])), :doc "Modifies the location from which rectangles draw. The default mode\n  is :corner. Available modes are:\n\n\n  :corner  - Specifies the location to be the upper left corner of the\n             shape and uses the third and fourth parameters of rect to\n             specify the width and height.\n\n  :corners - Uses the first and second parameters of rect to set the\n             location of one corner and uses the third and fourth\n             parameters to set the opposite corner.\n\n  :center  - Draws the image from its center point and uses the third\n             and forth parameters of rect to specify the image's width\n             and height.\n\n  :radius  - Draws the image from its center point and uses the third\n             and forth parameters of rect() to specify half of the\n             image's width and height."}, :added "1.0", :name quil.core$macros/rect-mode, :variadic false, :subcategory "Attributes", :file nil, :end-column 12, :processing-name "rectMode()", :method-params ([mode]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3249, :end-line 3255, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mode])), :doc "Modifies the location from which rectangles draw. The default mode\n  is :corner. Available modes are:\n\n\n  :corner  - Specifies the location to be the upper left corner of the\n             shape and uses the third and fourth parameters of rect to\n             specify the width and height.\n\n  :corners - Uses the first and second parameters of rect to set the\n             location of one corner and uses the third and fourth\n             parameters to set the opposite corner.\n\n  :center  - Draws the image from its center point and uses the third\n             and forth parameters of rect to specify the image's width\n             and height.\n\n  :radius  - Draws the image from its center point and uses the third\n             and forth parameters of rect() to specify half of the\n             image's width and height."}, ellipse-mode {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "Attributes", :file quil.core, :end-column 15, :processing-name "ellipseMode()", :column 3, :requires-bindings true, :line 1525, :end-line 1525, :arglists (quote ([mode])), :doc "Modifies the origin of the ellispse according to the specified mode:\n\n  :center  - specifies the location of the ellipse as\n             the center of the shape. (Default).\n  :radius  - similar to center, but the width and height parameters to\n             ellipse specify the radius of the ellipse, rather than the\n             diameter.\n  :corner  - draws the shape from the upper-left corner of its bounding\n             box.\n  :corners - uses the four parameters to ellipse to set two opposing\n             corners of the ellipse's bounding box."}, :added "1.0", :name quil.core$macros/ellipse-mode, :variadic false, :subcategory "Attributes", :file nil, :end-column 15, :processing-name "ellipseMode()", :method-params ([mode]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1519, :end-line 1525, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mode])), :doc "Modifies the origin of the ellispse according to the specified mode:\n\n  :center  - specifies the location of the ellipse as\n             the center of the shape. (Default).\n  :radius  - similar to center, but the width and height parameters to\n             ellipse specify the radius of the ellipse, rather than the\n             diameter.\n  :corner  - draws the shape from the upper-left corner of its bounding\n             box.\n  :corners - uses the four parameters to ellipse to set two opposing\n             corners of the ellipse's bounding box."}, month {:category "Input", :protocol-inline nil, :meta {:category "Input", :added "1.0", :subcategory "Time & Date", :file quil.core, :end-column 8, :processing-name "month()", :column 3, :requires-bindings false, :line 2547, :end-line 2547, :arglists (quote ([])), :doc "Returns the current month as a value from 1 - 12."}, :added "1.0", :name quil.core$macros/month, :variadic false, :subcategory "Time & Date", :file nil, :end-column 8, :processing-name "month()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 2541, :end-line 2547, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Returns the current month as a value from 1 - 12."}, texture-modes {:name quil.core$macros/texture-modes, :file nil, :line 45, :column 1, :end-line 69, :end-column 15, :meta {:file quil.core, :line 69, :column 2, :end-line 69, :end-column 15}}, tint-float {:category "Image", :protocol-inline nil, :meta {:category "Image", :added "1.0", :subcategory "Loading & Displaying", :file quil.core, :end-column 13, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([gray] [gray alpha] [r g b] [r g b a]), :arglists ([gray] [gray alpha] [r g b] [r g b a]), :arglists-meta (nil nil nil nil)}, :processing-name "tint()", :column 3, :requires-bindings true, :line 4366, :end-line 4366, :arglists (quote ([gray] [gray alpha] [r g b] [r g b a])), :doc "Sets the fill value for displaying images. Images can be tinted to\n  specified colors or made transparent by setting the alpha.\n\n  To make an image transparent, but not change it's color, use white\n  as the tint color and specify an alpha value. For instance,\n  tint(255, 128) will make an image 50% transparent (unless\n  colorMode() has been used).\n\n  The value for the parameter gray must be less than or equal to the\n  current maximum value as specified by colorMode(). The default\n  maximum value is 255.\n\n  Also used to control the coloring of textures in 3D."}, :added "1.0", :name quil.core$macros/tint-float, :variadic false, :subcategory "Loading & Displaying", :file nil, :end-column 13, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([gray] [gray alpha] [r g b] [r g b a]), :arglists ([gray] [gray alpha] [r g b] [r g b a]), :arglists-meta (nil nil nil nil)}, :processing-name "tint()", :method-params ([gray] [gray alpha] [r g b] [r g b a]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :requires-bindings true, :line 4360, :end-line 4366, :max-fixed-arity 4, :fn-var true, :arglists ([gray] [gray alpha] [r g b] [r g b a]), :doc "Sets the fill value for displaying images. Images can be tinted to\n  specified colors or made transparent by setting the alpha.\n\n  To make an image transparent, but not change it's color, use white\n  as the tint color and specify an alpha value. For instance,\n  tint(255, 128) will make an image 50% transparent (unless\n  colorMode() has been used).\n\n  The value for the parameter gray must be less than or equal to the\n  current maximum value as specified by colorMode(). The default\n  maximum value is 255.\n\n  Also used to control the coloring of textures in 3D."}, width {:category "Environment", :protocol-inline nil, :meta {:category "Environment", :added "1.0", :subcategory nil, :file quil.core, :end-column 8, :processing-name "getWidth()", :column 3, :processing-link nil, :requires-bindings true, :line 4573, :end-line 4573, :arglists (quote ([])), :doc "Width of the display window. The value of width is zero until size is\n  called."}, :added "1.0", :name quil.core$macros/width, :variadic false, :subcategory nil, :file nil, :end-column 8, :processing-name "getWidth()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :processing-link nil, :requires-bindings true, :line 4566, :end-line 4573, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Width of the display window. The value of width is zero until size is\n  called."}, background {:category "Color", :protocol-inline nil, :meta {:category "Color", :added "1.0", :subcategory "Setting", :file quil.core, :end-column 13, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([rgb] [rgb alpha] [r g b] [r g b a]), :arglists ([rgb] [rgb alpha] [r g b] [r g b a]), :arglists-meta (nil nil nil nil)}, :processing-name "background()", :column 3, :requires-bindings true, :line 550, :end-line 550, :arglists (quote ([rgb] [rgb alpha] [r g b] [r g b a])), :doc "Sets the color used for the background of the Processing\n  window. The default background is light gray. In the draw function,\n  the background color is used to clear the display window at the\n  beginning of each frame.\n\n  It is not possible to use transparency (alpha) in background colors\n  with the main drawing surface, however they will work properly with\n  create-graphics. Converts args to floats."}, :added "1.0", :name quil.core$macros/background, :variadic false, :subcategory "Setting", :file nil, :end-column 13, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([rgb] [rgb alpha] [r g b] [r g b a]), :arglists ([rgb] [rgb alpha] [r g b] [r g b a]), :arglists-meta (nil nil nil nil)}, :processing-name "background()", :method-params ([rgb] [rgb alpha] [r g b] [r g b a]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :requires-bindings true, :line 544, :end-line 550, :max-fixed-arity 4, :fn-var true, :arglists ([rgb] [rgb alpha] [r g b] [r g b a]), :doc "Sets the color used for the background of the Processing\n  window. The default background is light gray. In the draw function,\n  the background color is used to clear the display window at the\n  beginning of each frame.\n\n  It is not possible to use transparency (alpha) in background colors\n  with the main drawing surface, however they will work properly with\n  create-graphics. Converts args to floats."}, ortho {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Camera", :file quil.core, :end-column 8, :top-fn {:variadic false, :max-fixed-arity 6, :method-params ([] [left right bottom top] [left right bottom top near far]), :arglists ([] [left right bottom top] [left right bottom top near far]), :arglists-meta (nil nil nil)}, :processing-name "ortho()", :column 3, :requires-bindings true, :line 2839, :end-line 2839, :arglists (quote ([] [left right bottom top] [left right bottom top near far])), :doc "Sets an orthographic projection and defines a parallel clipping\n  volume. All objects with the same dimension appear the same size,\n  regardless of whether they are near or far from the camera. The\n  parameters to this function specify the clipping volume where left\n  and right are the minimum and maximum x values, top and bottom are\n  the minimum and maximum y values, and near and far are the minimum\n  and maximum z values. If no parameters are given, the default is\n  used: (ortho 0 width 0 height -10 10)"}, :added "1.0", :name quil.core$macros/ortho, :variadic false, :subcategory "Camera", :file nil, :end-column 8, :top-fn {:variadic false, :max-fixed-arity 6, :method-params ([] [left right bottom top] [left right bottom top near far]), :arglists ([] [left right bottom top] [left right bottom top near far]), :arglists-meta (nil nil nil)}, :processing-name "ortho()", :method-params ([] [left right bottom top] [left right bottom top near far]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :requires-bindings true, :line 2833, :end-line 2839, :max-fixed-arity 6, :fn-var true, :arglists ([] [left right bottom top] [left right bottom top near far]), :doc "Sets an orthographic projection and defines a parallel clipping\n  volume. All objects with the same dimension appear the same size,\n  regardless of whether they are near or far from the camera. The\n  parameters to this function specify the clipping volume where left\n  and right are the minimum and maximum x values, top and bottom are\n  the minimum and maximum y values, and near and far are the minimum\n  and maximum z values. If no parameters are given, the default is\n  used: (ortho 0 width 0 height -10 10)"}, hint-options {:name quil.core$macros/hint-options, :file nil, :line 45, :column 1, :end-line 53, :end-column 14, :meta {:file quil.core, :line 53, :column 2, :end-line 53, :end-column 14}}, prc-println {:category "Output", :protocol-inline nil, :meta {:category "Output", :added "1.0", :subcategory "Text area", :file quil.core, :end-column 17, :column 6, :require-bindings true, :line 152, :end-line 152, :arglists (quote ([msg])), :doc "Writes to the text area of the Processing environment's console.\n  This is often helpful for looking at the data a program is producing.\n  Each call to this function creates a new line of output.\n  Individual elements can be separated with quotes (\"\") and joined with the string concatenation operator (+).\n  Also writes the content of an array to the text area of the Processing environment.\n  This is often helpful for looking at the data a program is producing.\n  A new line is put between each element of the array. This function can only print 1D arrays,\n  but can test to see if the content are null or not null for 2+ dimensional arrays."}, :added "1.0", :name quil.core$macros/prc-println, :variadic false, :subcategory "Text area", :file nil, :end-column 17, :method-params ([msg]), :protocol-impl nil, :arglists-meta (nil nil), :column 4, :require-bindings true, :line 147, :end-line 152, :max-fixed-arity 1, :fn-var true, :arglists (quote ([msg])), :doc "Writes to the text area of the Processing environment's console.\n  This is often helpful for looking at the data a program is producing.\n  Each call to this function creates a new line of output.\n  Individual elements can be separated with quotes (\"\") and joined with the string concatenation operator (+).\n  Also writes the content of an array to the text area of the Processing environment.\n  This is often helpful for looking at the data a program is producing.\n  A new line is put between each element of the array. This function can only print 1D arrays,\n  but can test to see if the content are null or not null for 2+ dimensional arrays."}, brightness {:category "Color", :protocol-inline nil, :meta {:category "Color", :added "1.0", :subcategory "Creating & Reading", :file quil.core, :end-column 13, :processing-name "brightness()", :column 3, :requires-bindings true, :line 928, :end-line 928, :arglists (quote ([color])), :doc "Extracts the brightness value from a color. Returns a float."}, :added "1.0", :name quil.core$macros/brightness, :variadic false, :subcategory "Creating & Reading", :file nil, :end-column 13, :processing-name "brightness()", :method-params ([color]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 922, :end-line 928, :max-fixed-arity 1, :fn-var true, :arglists (quote ([color])), :doc "Extracts the brightness value from a color. Returns a float."}, arc-modes {:name quil.core$macros/arc-modes, :file nil, :line 45, :column 1, :end-line 46, :end-column 11, :meta {:file quil.core, :line 46, :column 2, :end-line 46, :end-column 11}}, specular {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Material Properties", :file quil.core, :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([gray] [x y z]), :arglists ([gray] [x y z]), :arglists-meta (nil nil)}, :processing-name "specular()", :column 3, :requires-bindings true, :line 3860, :end-line 3860, :arglists (quote ([gray] [x y z])), :doc "Sets the specular color of the materials used for shapes drawn to\n  the screen, which sets the color of hightlights. Specular refers to\n  light which bounces off a surface in a perferred direction (rather\n  than bouncing in all directions like a diffuse light). Used in\n  combination with emissive, ambient, and shininess in setting\n  the material properties of shapes."}, :added "1.0", :name quil.core$macros/specular, :variadic false, :subcategory "Material Properties", :file nil, :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([gray] [x y z]), :arglists ([gray] [x y z]), :arglists-meta (nil nil)}, :processing-name "specular()", :method-params ([gray] [x y z]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3854, :end-line 3860, :max-fixed-arity 3, :fn-var true, :arglists ([gray] [x y z]), :doc "Sets the specular color of the materials used for shapes drawn to\n  the screen, which sets the color of hightlights. Specular refers to\n  light which bounces off a surface in a perferred direction (rather\n  than bouncing in all directions like a diffuse light). Used in\n  combination with emissive, ambient, and shininess in setting\n  the material properties of shapes."}, save-frame {:category "Output", :protocol-inline nil, :meta {:category "Output", :added "1.0", :subcategory "Image", :file quil.core, :end-column 13, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [name]), :arglists ([] [name]), :arglists-meta (nil nil)}, :processing-name "saveFrame()", :column 3, :requires-bindings true, :line 3522, :end-line 3522, :arglists (quote ([] [name])), :doc "Saves an image identical to the current display window as a\n  file. May be called multple times - each file saved will have a\n  unique name. Name and image formate may be modified by passing a\n  string parameter of the form \"foo-####.ext\" where foo- can be any\n  arbitrary string, #### will be replaced with the current frame id\n  and .ext is one of .tiff, .targa, .png, .jpeg or .jpg\n\n  Examples:\n  (save-frame)\n  (save-frame \"pretty-pic-####.jpg\")"}, :added "1.0", :name quil.core$macros/save-frame, :variadic false, :subcategory "Image", :file nil, :end-column 13, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [name]), :arglists ([] [name]), :arglists-meta (nil nil)}, :processing-name "saveFrame()", :method-params ([] [name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3516, :end-line 3522, :max-fixed-arity 1, :fn-var true, :arglists ([] [name]), :doc "Saves an image identical to the current display window as a\n  file. May be called multple times - each file saved will have a\n  unique name. Name and image formate may be modified by passing a\n  string parameter of the form \"foo-####.ext\" where foo- can be any\n  arbitrary string, #### will be replaced with the current frame id\n  and .ext is one of .tiff, .targa, .png, .jpeg or .jpg\n\n  Examples:\n  (save-frame)\n  (save-frame \"pretty-pic-####.jpg\")"}, cursor {:category "Environment", :protocol-inline nil, :meta {:category "Environment", :added "1.0", :subcategory nil, :file quil.core, :end-column 9, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [cursor-mode]), :arglists ([] [cursor-mode]), :arglists-meta (nil nil)}, :processing-name "cursor()", :column 3, :requires-bindings true, :line 1286, :end-line 1286, :arglists (quote ([] [cursor-mode])), :doc "Sets the cursor to a predefined symbol or makes it\n  visible if already hidden (after no-cursor was called).\n\n  Available modes: :arrow, :cross, :hand, :move, :text, :wait\n\n  See cursor-image for specifying a generic image as the cursor\n  symbol."}, :added "1.0", :name quil.core$macros/cursor, :variadic false, :subcategory nil, :file nil, :end-column 9, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [cursor-mode]), :arglists ([] [cursor-mode]), :arglists-meta (nil nil)}, :processing-name "cursor()", :method-params ([] [cursor-mode]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1280, :end-line 1286, :max-fixed-arity 1, :fn-var true, :arglists ([] [cursor-mode]), :doc "Sets the cursor to a predefined symbol or makes it\n  visible if already hidden (after no-cursor was called).\n\n  Available modes: :arrow, :cross, :hand, :move, :text, :wait\n\n  See cursor-image for specifying a generic image as the cursor\n  symbol."}, noise {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Random", :file quil.core, :end-column 8, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([x] [x y] [x y z]), :arglists ([x] [x y] [x y z]), :arglists-meta (nil nil nil)}, :processing-name "noise()", :column 3, :requires-bindings true, :line 2655, :end-line 2655, :arglists (quote ([x] [x y] [x y z])), :doc "Returns the Perlin noise value at specified coordinates. Perlin\n  noise is a random sequence generator producing a more natural\n  ordered, harmonic succession of numbers compared to the standard\n  random function. It was invented by Ken Perlin in the 1980s and\n  been used since in graphical applications to produce procedural\n  textures, natural motion, shapes, terrains etc.\n\n  The main difference to the random function is that Perlin noise is\n  defined in an infinite n-dimensional space where each pair of\n  coordinates corresponds to a fixed semi-random value (fixed only for\n  the lifespan of the program). The resulting value will always be\n  between 0.0 and 1.0. Processing can compute 1D, 2D and 3D noise,\n  depending on the number of coordinates given. The noise value can be\n  animated by moving through the noise space and the 2nd and 3rd\n  dimensions can also be interpreted as time.\n\n  The actual noise is structured similar to an audio signal, in\n  respect to the function's use of frequencies. Similar to the concept\n  of harmonics in physics, perlin noise is computed over several\n  octaves which are added together for the final result.\n\n  Another way to adjust the character of the resulting sequence is the\n  scale of the input coordinates. As the function works within an\n  infinite space the value of the coordinates doesn't matter as such,\n  only the distance between successive coordinates does (eg. when\n  using noise within a loop). As a general rule the smaller the\n  difference between coordinates, the smoother the resulting noise\n  sequence will be. Steps of 0.005-0.03 work best for most\n  applications, but this will differ depending on use."}, :added "1.0", :name quil.core$macros/noise, :variadic false, :subcategory "Random", :file nil, :end-column 8, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([x] [x y] [x y z]), :arglists ([x] [x y] [x y z]), :arglists-meta (nil nil nil)}, :processing-name "noise()", :method-params ([x] [x y] [x y z]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :requires-bindings true, :line 2649, :end-line 2655, :max-fixed-arity 3, :fn-var true, :arglists ([x] [x y] [x y z]), :doc "Returns the Perlin noise value at specified coordinates. Perlin\n  noise is a random sequence generator producing a more natural\n  ordered, harmonic succession of numbers compared to the standard\n  random function. It was invented by Ken Perlin in the 1980s and\n  been used since in graphical applications to produce procedural\n  textures, natural motion, shapes, terrains etc.\n\n  The main difference to the random function is that Perlin noise is\n  defined in an infinite n-dimensional space where each pair of\n  coordinates corresponds to a fixed semi-random value (fixed only for\n  the lifespan of the program). The resulting value will always be\n  between 0.0 and 1.0. Processing can compute 1D, 2D and 3D noise,\n  depending on the number of coordinates given. The noise value can be\n  animated by moving through the noise space and the 2nd and 3rd\n  dimensions can also be interpreted as time.\n\n  The actual noise is structured similar to an audio signal, in\n  respect to the function's use of frequencies. Similar to the concept\n  of harmonics in physics, perlin noise is computed over several\n  octaves which are added together for the final result.\n\n  Another way to adjust the character of the resulting sequence is the\n  scale of the input coordinates. As the function works within an\n  infinite space the value of the coordinates doesn't matter as such,\n  only the distance between successive coordinates does (eg. when\n  using noise within a loop). As a general rule the smaller the\n  difference between coordinates, the smoother the resulting noise\n  sequence will be. Steps of 0.005-0.03 work best for most\n  applications, but this will differ depending on use."}, push-style {:category "Structure", :protocol-inline nil, :meta {:category "Structure", :added "1.0", :subcategory nil, :file quil.core, :end-column 13, :processing-name "pushStyle()", :column 3, :requires-bindings true, :line 3079, :end-line 3079, :arglists (quote ([])), :doc "Saves the current style settings onto a 'style stack'. Use with\n  pop-style which restores the prior settings. Note that these\n  functions are always used together. They allow you to change the\n  style settings and later return to what you had. When a new style is\n  started with push-style, it builds on the current style\n  information. The push-style and pop-style fns can be embedded to\n  provide more control.\n\n  The style information controlled by the following functions are\n  included in the style: fill, stroke, tint, stroke-weight,\n  stroke-cap, stroke-join, image-mode, rect-mode, ellipse-mode,\n  shape-mode, color-mode, text-align, text-font, text-mode, text-size,\n  text-leading, emissive, specular, shininess, and ambient"}, :added "1.0", :name quil.core$macros/push-style, :variadic false, :subcategory nil, :file nil, :end-column 13, :processing-name "pushStyle()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3073, :end-line 3079, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Saves the current style settings onto a 'style stack'. Use with\n  pop-style which restores the prior settings. Note that these\n  functions are always used together. They allow you to change the\n  style settings and later return to what you had. When a new style is\n  started with push-style, it builds on the current style\n  information. The push-style and pop-style fns can be embedded to\n  provide more control.\n\n  The style information controlled by the following functions are\n  included in the style: fill, stroke, tint, stroke-weight,\n  stroke-cap, stroke-join, image-mode, rect-mode, ellipse-mode,\n  shape-mode, color-mode, text-align, text-font, text-mode, text-size,\n  text-leading, emissive, specular, shininess, and ambient"}, bezier-vertex {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "Vertex", :file quil.core, :end-column 16, :top-fn {:variadic false, :max-fixed-arity 9, :method-params ([cx1 cy1 cx2 cy2 x y] [cx1 cy1 cz1 cx2 cy2 cz2 x y z]), :arglists ([cx1 cy1 cx2 cy2 x y] [cx1 cy1 cz1 cx2 cy2 cz2 x y z]), :arglists-meta (nil nil)}, :processing-name "bezierVertex()", :column 3, :requires-bindings true, :line 735, :end-line 735, :arglists (quote ([cx1 cy1 cx2 cy2 x y] [cx1 cy1 cz1 cx2 cy2 cz2 x y z])), :doc "Specifies vertex coordinates for Bezier curves. Each call to\n  bezier-vertex defines the position of two control points and one\n  anchor point of a Bezier curve, adding a new segment to a line or\n  shape. The first time bezier-vertex is used within a begin-shape\n  call, it must be prefaced with a call to vertex to set the first\n  anchor point. This function must be used between begin-shape and\n  end-shape and only when there is no parameter specified to\n  begin-shape."}, :added "1.0", :name quil.core$macros/bezier-vertex, :variadic false, :subcategory "Vertex", :file nil, :end-column 16, :top-fn {:variadic false, :max-fixed-arity 9, :method-params ([cx1 cy1 cx2 cy2 x y] [cx1 cy1 cz1 cx2 cy2 cz2 x y z]), :arglists ([cx1 cy1 cx2 cy2 x y] [cx1 cy1 cz1 cx2 cy2 cz2 x y z]), :arglists-meta (nil nil)}, :processing-name "bezierVertex()", :method-params ([cx1 cy1 cx2 cy2 x y] [cx1 cy1 cz1 cx2 cy2 cz2 x y z]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 729, :end-line 735, :max-fixed-arity 9, :fn-var true, :arglists ([cx1 cy1 cx2 cy2 x y] [cx1 cy1 cz1 cx2 cy2 cz2 x y z]), :doc "Specifies vertex coordinates for Bezier curves. Each call to\n  bezier-vertex defines the position of two control points and one\n  anchor point of a Bezier curve, adding a new segment to a line or\n  shape. The first time bezier-vertex is used within a begin-shape\n  call, it must be prefaced with a call to vertex to set the first\n  anchor point. This function must be used between begin-shape and\n  end-shape and only when there is no parameter specified to\n  begin-shape."}, light-falloff {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Lights", :file quil.core, :end-column 16, :processing-name "lightFalloff()", :column 3, :requires-bindings true, :line 2207, :end-line 2207, :arglists (quote ([constant linear quadratic])), :doc "Sets the falloff rates for point lights, spot lights, and ambient\n  lights. The parameters are used to determine the falloff with the\n  following equation:\n\n  d = distance from light position to vertex position\n  falloff = 1 / (CONSTANT + d * LINEAR + (d*d) * QUADRATIC)\n\n  Like fill, it affects only the elements which are created after it\n  in the code. The default value is (light-falloff 1.0 0.0 0.0).\n  Thinking about an ambient light with a falloff can be tricky. It is\n  used, for example, if you wanted a region of your scene to be lit\n  ambiently one color and another region to be lit ambiently by\n  another color, you would use an ambient light with location and\n  falloff. You can think of it as a point light that doesn't care\n  which direction a surface is facing."}, :added "1.0", :name quil.core$macros/light-falloff, :variadic false, :subcategory "Lights", :file nil, :end-column 16, :processing-name "lightFalloff()", :method-params ([constant linear quadratic]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2201, :end-line 2207, :max-fixed-arity 3, :fn-var true, :arglists (quote ([constant linear quadratic])), :doc "Sets the falloff rates for point lights, spot lights, and ambient\n  lights. The parameters are used to determine the falloff with the\n  following equation:\n\n  d = distance from light position to vertex position\n  falloff = 1 / (CONSTANT + d * LINEAR + (d*d) * QUADRATIC)\n\n  Like fill, it affects only the elements which are created after it\n  in the code. The default value is (light-falloff 1.0 0.0 0.0).\n  Thinking about an ambient light with a falloff can be tricky. It is\n  used, for example, if you wanted a region of your scene to be lit\n  ambiently one color and another region to be lit ambiently by\n  another color, you would use an ambient light with location and\n  falloff. You can think of it as a point light that doesn't care\n  which direction a surface is facing."}, noise-detail {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Random", :file quil.core, :end-column 15, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([octaves] [octaves falloff]), :arglists ([octaves] [octaves falloff]), :arglists-meta (nil nil)}, :processing-name "noiseDetail()", :column 3, :requires-bindings true, :line 2695, :end-line 2695, :arglists (quote ([octaves] [octaves falloff])), :doc "Adjusts the character and level of detail produced by the Perlin\n  noise function. Similar to harmonics in physics, noise is computed\n  over several octaves. Lower octaves contribute more to the output\n  signal and as such define the overal intensity of the noise, whereas\n  higher octaves create finer grained details in the noise\n  sequence. By default, noise is computed over 4 octaves with each\n  octave contributing exactly half than its predecessor, starting at\n  50% strength for the 1st octave. This falloff amount can be changed\n  by adding an additional function parameter. Eg. a falloff factor of\n  0.75 means each octave will now have 75% impact (25% less) of the\n  previous lower octave. Any value between 0.0 and 1.0 is valid,\n  however note that values greater than 0.5 might result in greater\n  than 1.0 values returned by noise.\n\n  By changing these parameters, the signal created by the noise\n  function can be adapted to fit very specific needs and\n  characteristics."}, :added "1.0", :name quil.core$macros/noise-detail, :variadic false, :subcategory "Random", :file nil, :end-column 15, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([octaves] [octaves falloff]), :arglists ([octaves] [octaves falloff]), :arglists-meta (nil nil)}, :processing-name "noiseDetail()", :method-params ([octaves] [octaves falloff]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2689, :end-line 2695, :max-fixed-arity 2, :fn-var true, :arglists ([octaves] [octaves falloff]), :doc "Adjusts the character and level of detail produced by the Perlin\n  noise function. Similar to harmonics in physics, noise is computed\n  over several octaves. Lower octaves contribute more to the output\n  signal and as such define the overal intensity of the noise, whereas\n  higher octaves create finer grained details in the noise\n  sequence. By default, noise is computed over 4 octaves with each\n  octave contributing exactly half than its predecessor, starting at\n  50% strength for the 1st octave. This falloff amount can be changed\n  by adding an additional function parameter. Eg. a falloff factor of\n  0.75 means each octave will now have 75% impact (25% less) of the\n  previous lower octave. Any value between 0.0 and 1.0 is valid,\n  however note that values greater than 0.5 might result in greater\n  than 1.0 values returned by noise.\n\n  By changing these parameters, the signal created by the noise\n  function can be adapted to fit very specific needs and\n  characteristics."}, save {:category "Output", :protocol-inline nil, :meta {:category "Output", :added "1.0", :subcategory "Image", :file quil.core, :end-column 7, :processing-name "save()", :column 3, :requires-bindings true, :line 3504, :end-line 3504, :arglists (quote ([filename])), :doc "Saves an image from the display window. Images are saved in TIFF,\n  TARGA, JPEG, and PNG format depending on the extension within the\n  filename parameter. For example, image.tif will have a TIFF image\n  and image.png will save a PNG image. If no extension is included in\n  the filename, the image will save in TIFF format and .tif will be\n  added to the name. All images saved from the main drawing window\n  will be opaque. To save images without a background, use\n  create-graphics."}, :added "1.0", :name quil.core$macros/save, :variadic false, :subcategory "Image", :file nil, :end-column 7, :processing-name "save()", :method-params ([filename]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3498, :end-line 3504, :max-fixed-arity 1, :fn-var true, :arglists (quote ([filename])), :doc "Saves an image from the display window. Images are saved in TIFF,\n  TARGA, JPEG, and PNG format depending on the extension within the\n  filename parameter. For example, image.tif will have a TIFF image\n  and image.png will save a PNG image. If no extension is included in\n  the filename, the image will save in TIFF format and .tif will be\n  added to the name. All images saved from the main drawing window\n  will be opaque. To save images without a background, use\n  create-graphics."}, curve-point {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "Curves", :file quil.core, :end-column 14, :processing-name "curvePoint()", :column 3, :requires-bindings true, :line 1362, :end-line 1362, :arglists (quote ([a b c d t])), :doc "Evalutes the curve at point t for points a, b, c, d. The parameter\n  t varies between 0 and 1, a and d are points on the curve, and b c\n  and are the control points. This can be done once with the x\n  coordinates and a second time with the y coordinates to get the\n  location of a curve at t."}, :added "1.0", :name quil.core$macros/curve-point, :variadic false, :subcategory "Curves", :file nil, :end-column 14, :processing-name "curvePoint()", :method-params ([a b c d t]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1356, :end-line 1362, :max-fixed-arity 5, :fn-var true, :arglists (quote ([a b c d t])), :doc "Evalutes the curve at point t for points a, b, c, d. The parameter\n  t varies between 0 and 1, a and d are points on the curve, and b c\n  and are the control points. This can be done once with the x\n  coordinates and a second time with the y coordinates to get the\n  location of a curve at t."}, state {:category "State", :protocol-inline nil, :meta {:category "State", :added "1.0", :subcategory nil, :file quil.core, :end-column 8, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [key]), :arglists ([] [key]), :arglists-meta (nil nil)}, :column 3, :requires-bindings true, :line 215, :end-line 215, :arglists (quote ([] [key])), :doc "Retrieve sketch-specific state by key. Must initially call\n  set-state! to store state. If no parameter passed whole\n  state map is returned.\n\n  (set-state! :foo 1)\n  (state :foo) ;=> 1\n  (state) ;=> {:foo 1}"}, :added "1.0", :name quil.core$macros/state, :variadic false, :subcategory nil, :file nil, :end-column 8, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [key]), :arglists ([] [key]), :arglists-meta (nil nil)}, :method-params ([] [key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 210, :end-line 215, :max-fixed-arity 1, :fn-var true, :arglists ([] [key]), :doc "Retrieve sketch-specific state by key. Must initially call\n  set-state! to store state. If no parameter passed whole\n  state map is returned.\n\n  (set-state! :foo 1)\n  (state :foo) ;=> 1\n  (state) ;=> {:foo 1}"}, load-shader {:category "Rendering", :protocol-inline nil, :meta {:category "Rendering", :added "2.0", :subcategory "Shaders", :file quil.core, :end-column 14, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([fragment-filename] [fragment-filename vertex-filename]), :arglists ([fragment-filename] [fragment-filename vertex-filename]), :arglists-meta (nil nil)}, :processing-name "loadShader()", :column 3, :requires-bindings true, :line 2382, :end-line 2382, :arglists (quote ([fragment-filename] [fragment-filename vertex-filename])), :doc "Loads a shader into the PShader object. Shaders are compatible with the\n  P2D and P3D renderers, but not with the default renderer."}, :added "2.0", :name quil.core$macros/load-shader, :variadic false, :subcategory "Shaders", :file nil, :end-column 14, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([fragment-filename] [fragment-filename vertex-filename]), :arglists ([fragment-filename] [fragment-filename vertex-filename]), :arglists-meta (nil nil)}, :processing-name "loadShader()", :method-params ([fragment-filename] [fragment-filename vertex-filename]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2376, :end-line 2382, :max-fixed-arity 2, :fn-var true, :arglists ([fragment-filename] [fragment-filename vertex-filename]), :doc "Loads a shader into the PShader object. Shaders are compatible with the\n  P2D and P3D renderers, but not with the default renderer."}, resize {:category "Image", :protocol-inline nil, :meta {:category "Image", :added "2.1.0", :file quil.core, :end-column 9, :processing-name "resize()", :column 3, :processing-link "http://processing.org/reference/PImage_resize_.html", :requires-bindings true, :line 3370, :end-line 3370, :arglists (quote ([img w h])), :doc "Resize the image to a new width and height.\n  To make the image scale proportionally, use 0 as the value for the wide or\n  high parameter. For instance, to make the width of an image 150 pixels,\n  and change the height using the same proportion, use resize(150, 0).\n\n  Even though a PGraphics is technically a PImage, it is not possible\n  to rescale the image data found in a PGraphics.\n  (It's simply not possible to do this consistently across renderers:\n  technically infeasible with P3D, or what would it even do with PDF?)\n  If you want to resize PGraphics content, first get a copy of its image data\n  using the get() method, and call resize() on the PImage that is returned."}, :added "2.1.0", :name quil.core$macros/resize, :variadic false, :file nil, :end-column 9, :processing-name "resize()", :method-params ([img w h]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :processing-link "http://processing.org/reference/PImage_resize_.html", :requires-bindings true, :line 3364, :end-line 3370, :max-fixed-arity 3, :fn-var true, :arglists (quote ([img w h])), :doc "Resize the image to a new width and height.\n  To make the image scale proportionally, use 0 as the value for the wide or\n  high parameter. For instance, to make the width of an image 150 pixels,\n  and change the height using the same proportion, use resize(150, 0).\n\n  Even though a PGraphics is technically a PImage, it is not possible\n  to rescale the image data found in a PGraphics.\n  (It's simply not possible to do this consistently across renderers:\n  technically infeasible with P3D, or what would it even do with PDF?)\n  If you want to resize PGraphics content, first get a copy of its image data\n  using the get() method, and call resize() on the PImage that is returned."}, normal {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Lights", :file quil.core, :end-column 9, :processing-name "normal()", :column 3, :requires-bindings true, :line 2788, :end-line 2788, :arglists (quote ([nx ny nz])), :doc "Sets the current normal vector. This is for drawing three\n  dimensional shapes and surfaces and specifies a vector perpendicular\n  to the surface of the shape which determines how lighting affects\n  it. Processing attempts to automatically assign normals to shapes,\n  but since that's imperfect, this is a better option when you want\n  more control. This function is identical to glNormal3f() in OpenGL."}, :added "1.0", :name quil.core$macros/normal, :variadic false, :subcategory "Lights", :file nil, :end-column 9, :processing-name "normal()", :method-params ([nx ny nz]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2782, :end-line 2788, :max-fixed-arity 3, :fn-var true, :arglists (quote ([nx ny nz])), :doc "Sets the current normal vector. This is for drawing three\n  dimensional shapes and surfaces and specifies a vector perpendicular\n  to the surface of the shape which determines how lighting affects\n  it. Processing attempts to automatically assign normals to shapes,\n  but since that's imperfect, this is a better option when you want\n  more control. This function is identical to glNormal3f() in OpenGL."}, perspective {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Camera", :file quil.core, :end-column 14, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([] [fovy aspect z-near z-far]), :arglists ([] [fovy aspect z-near z-far]), :arglists-meta (nil nil)}, :processing-name "perspective()", :column 3, :requires-bindings true, :line 2860, :end-line 2860, :arglists (quote ([] [fovy aspect z-near z-far])), :doc "Sets a perspective projection applying foreshortening, making\n  distant objects appear smaller than closer ones. The parameters\n  define a viewing volume with the shape of truncated pyramid. Objects\n  near to the front of the volume appear their actual size, while\n  farther objects appear smaller. This projection simulates the\n  perspective of the world more accurately than orthographic\n  projection. The version of perspective without parameters sets the\n  default perspective and the version with four parameters allows the\n  programmer to set the area precisely. The default values are:\n  perspective(PI/3.0, width/height, cameraZ/10.0, cameraZ*10.0) where\n  cameraZ is ((height/2.0) / tan(PI*60.0/360.0));"}, :added "1.0", :name quil.core$macros/perspective, :variadic false, :subcategory "Camera", :file nil, :end-column 14, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([] [fovy aspect z-near z-far]), :arglists ([] [fovy aspect z-near z-far]), :arglists-meta (nil nil)}, :processing-name "perspective()", :method-params ([] [fovy aspect z-near z-far]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2854, :end-line 2860, :max-fixed-arity 4, :fn-var true, :arglists ([] [fovy aspect z-near z-far]), :doc "Sets a perspective projection applying foreshortening, making\n  distant objects appear smaller than closer ones. The parameters\n  define a viewing volume with the shape of truncated pyramid. Objects\n  near to the front of the volume appear their actual size, while\n  farther objects appear smaller. This projection simulates the\n  perspective of the world more accurately than orthographic\n  projection. The version of perspective without parameters sets the\n  default perspective and the version with four parameters allows the\n  programmer to set the area precisely. The default values are:\n  perspective(PI/3.0, width/height, cameraZ/10.0, cameraZ*10.0) where\n  cameraZ is ((height/2.0) / tan(PI*60.0/360.0));"}, seconds {:category "Input", :protocol-inline nil, :meta {:category "Input", :added "1.0", :subcategory "Time & Date", :file quil.core, :end-column 10, :processing-name "second()", :column 3, :requires-bindings false, :line 3637, :end-line 3637, :arglists (quote ([])), :doc "Returns the current second as a value from 0 - 59."}, :added "1.0", :name quil.core$macros/seconds, :variadic false, :subcategory "Time & Date", :file nil, :end-column 10, :processing-name "second()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 3631, :end-line 3637, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Returns the current second as a value from 0 - 59."}, hint {:category "Rendering", :protocol-inline nil, :meta {:category "Rendering", :added "1.0", :subcategory nil, :file quil.core, :end-column 7, :processing-name "hint()", :column 3, :processing-link nil, :requires-bindings true, :line 1963, :end-line 1963, :arglists (quote ([hint-type])), :doc "Set various hints and hacks for the renderer. This is used to\n  handle obscure rendering features that cannot be implemented in a\n  consistent manner across renderers. Many options will often graduate\n  to standard features instead of hints over time.\n\n  Options:\n\n  :enable-native-fonts - Use the native version fonts when they are\n    installed, rather than the bitmapped version from a .vlw\n    file. This is useful with the default (or JAVA2D) renderer\n    setting, as it will improve font rendering speed. This is not\n    enabled by default, because it can be misleading while testing\n    because the type will look great on your machine (because you have\n    the font installed) but lousy on others' machines if the identical\n    font is unavailable. This option can only be set per-sketch, and\n    must be called before any use of text-font.\n\n  :disable-native-fonts - Disables native font support.\n\n  :disable-depth-test - Disable the zbuffer, allowing you to draw on\n    top of everything at will. When depth testing is disabled, items\n    will be drawn to the screen sequentially, like a painting. This\n    hint is most often used to draw in 3D, then draw in 2D on top of\n    it (for instance, to draw GUI controls in 2D on top of a 3D\n    interface). Starting in release 0149, this will also clear the\n    depth buffer. Restore the default with :enable-depth-test\n    but note that with the depth buffer cleared, any 3D drawing that\n    happens later in draw will ignore existing shapes on the screen.\n\n  :enable-depth-test - Enables the zbuffer.\n\n  :enable-depth-sort - Enable primitive z-sorting of triangles and\n    lines in :p3d and :opengl rendering modes. This can slow\n    performance considerably, and the algorithm is not yet perfect.\n\n  :disable-depth-sort - Disables hint :enable-depth-sort\n\n  :disable-opengl-errors - Speeds up the OPENGL renderer setting\n     by not checking for errors while running.\n\n  :enable-opengl-errors - Turns on OpenGL error checking\n\n  :enable-depth-mask\n  :disable-depth-mask\n\n  :enable-optimized-stroke\n  :disable-optimized-stroke\n  :enable-retina-pixels\n  :disable-retina-pixels\n  :enable-stroke-perspective\n  :disable-stroke-perspective\n  :enable-stroke-pure\n  :disable-stroke-pure\n  :enable-texture-mipmaps\n  :disable-texture-mipmaps\n"}, :added "1.0", :name quil.core$macros/hint, :variadic false, :subcategory nil, :file nil, :end-column 7, :processing-name "hint()", :method-params ([hint-type]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :processing-link nil, :requires-bindings true, :line 1956, :end-line 1963, :max-fixed-arity 1, :fn-var true, :arglists (quote ([hint-type])), :doc "Set various hints and hacks for the renderer. This is used to\n  handle obscure rendering features that cannot be implemented in a\n  consistent manner across renderers. Many options will often graduate\n  to standard features instead of hints over time.\n\n  Options:\n\n  :enable-native-fonts - Use the native version fonts when they are\n    installed, rather than the bitmapped version from a .vlw\n    file. This is useful with the default (or JAVA2D) renderer\n    setting, as it will improve font rendering speed. This is not\n    enabled by default, because it can be misleading while testing\n    because the type will look great on your machine (because you have\n    the font installed) but lousy on others' machines if the identical\n    font is unavailable. This option can only be set per-sketch, and\n    must be called before any use of text-font.\n\n  :disable-native-fonts - Disables native font support.\n\n  :disable-depth-test - Disable the zbuffer, allowing you to draw on\n    top of everything at will. When depth testing is disabled, items\n    will be drawn to the screen sequentially, like a painting. This\n    hint is most often used to draw in 3D, then draw in 2D on top of\n    it (for instance, to draw GUI controls in 2D on top of a 3D\n    interface). Starting in release 0149, this will also clear the\n    depth buffer. Restore the default with :enable-depth-test\n    but note that with the depth buffer cleared, any 3D drawing that\n    happens later in draw will ignore existing shapes on the screen.\n\n  :enable-depth-test - Enables the zbuffer.\n\n  :enable-depth-sort - Enable primitive z-sorting of triangles and\n    lines in :p3d and :opengl rendering modes. This can slow\n    performance considerably, and the algorithm is not yet perfect.\n\n  :disable-depth-sort - Disables hint :enable-depth-sort\n\n  :disable-opengl-errors - Speeds up the OPENGL renderer setting\n     by not checking for errors while running.\n\n  :enable-opengl-errors - Turns on OpenGL error checking\n\n  :enable-depth-mask\n  :disable-depth-mask\n\n  :enable-optimized-stroke\n  :disable-optimized-stroke\n  :enable-retina-pixels\n  :disable-retina-pixels\n  :enable-stroke-perspective\n  :disable-stroke-perspective\n  :enable-stroke-pure\n  :disable-stroke-pure\n  :enable-texture-mipmaps\n  :disable-texture-mipmaps\n"}, sphere-detail {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "3D Primitives", :file quil.core, :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([res] [ures vres]), :arglists ([res] [ures vres]), :arglists-meta (nil nil)}, :processing-name "sphereDetail()", :column 3, :requires-bindings true, :line 3886, :end-line 3886, :arglists (quote ([res] [ures vres])), :doc "Controls the detail used to render a sphere by adjusting the number\n  of vertices of the sphere mesh. The default resolution is 30, which\n  creates a fairly detailed sphere definition with vertices every\n  360/30 = 12 degrees. If you're going to render a great number of\n  spheres per frame, it is advised to reduce the level of detail using\n  this function. The setting stays active until sphere-detail is\n  called again with a new parameter and so should not be called prior\n  to every sphere statement, unless you wish to render spheres with\n  different settings, e.g. using less detail for smaller spheres or\n  ones further away from the camera. To controla the detail of the\n  horizontal and vertical resolution independently, use the version of\n  the functions with two parameters."}, :added "1.0", :name quil.core$macros/sphere-detail, :variadic false, :subcategory "3D Primitives", :file nil, :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([res] [ures vres]), :arglists ([res] [ures vres]), :arglists-meta (nil nil)}, :processing-name "sphereDetail()", :method-params ([res] [ures vres]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3880, :end-line 3886, :max-fixed-arity 2, :fn-var true, :arglists ([res] [ures vres]), :doc "Controls the detail used to render a sphere by adjusting the number\n  of vertices of the sphere mesh. The default resolution is 30, which\n  creates a fairly detailed sphere definition with vertices every\n  360/30 = 12 degrees. If you're going to render a great number of\n  spheres per frame, it is advised to reduce the level of detail using\n  this function. The setting stays active until sphere-detail is\n  called again with a new parameter and so should not be called prior\n  to every sphere statement, unless you wish to render spheres with\n  different settings, e.g. using less detail for smaller spheres or\n  ones further away from the camera. To controla the detail of the\n  horizontal and vertical resolution independently, use the version of\n  the functions with two parameters."}, vertex {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "Vertex", :file quil.core, :end-column 9, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([x y] [x y z] [x y u v] [x y z u v]), :arglists ([x y] [x y z] [x y u v] [x y z u v]), :arglists-meta (nil nil nil nil)}, :processing-name "vertex()", :column 3, :requires-bindings true, :line 4533, :end-line 4533, :arglists (quote ([x y] [x y z] [x y u v] [x y z u v])), :doc "All shapes are constructed by connecting a series of\n  vertices. vertex is used to specify the vertex coordinates for\n  points, lines, triangles, quads, and polygons and is used\n  exclusively within the begin-shape and end-shape fns.\n\n  Drawing a vertex in 3D using the z parameter requires the :p3d or\n  :opengl renderers to be used.\n\n  This function is also used to map a texture onto the geometry. The\n  texture fn declares the texture to apply to the geometry and the u\n  and v coordinates set define the mapping of this texture to the\n  form. By default, the coordinates used for u and v are specified in\n  relation to the image's size in pixels, but this relation can be\n  changed with texture-mode."}, :added "1.0", :name quil.core$macros/vertex, :variadic false, :subcategory "Vertex", :file nil, :end-column 9, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([x y] [x y z] [x y u v] [x y z u v]), :arglists ([x y] [x y z] [x y u v] [x y z u v]), :arglists-meta (nil nil nil nil)}, :processing-name "vertex()", :method-params ([x y] [x y z] [x y u v] [x y z u v]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :requires-bindings true, :line 4527, :end-line 4533, :max-fixed-arity 5, :fn-var true, :arglists ([x y] [x y z] [x y u v] [x y z u v]), :doc "All shapes are constructed by connecting a series of\n  vertices. vertex is used to specify the vertex coordinates for\n  points, lines, triangles, quads, and polygons and is used\n  exclusively within the begin-shape and end-shape fns.\n\n  Drawing a vertex in 3D using the z parameter requires the :p3d or\n  :opengl renderers to be used.\n\n  This function is also used to map a texture onto the geometry. The\n  texture fn declares the texture to apply to the geometry and the u\n  and v coordinates set define the mapping of this texture to the\n  form. By default, the coordinates used for u and v are specified in\n  relation to the image's size in pixels, but this relation can be\n  changed with texture-mode."}, delay-frame {:category "Structure", :protocol-inline nil, :meta {:category "Structure", :added "1.0", :subcategory nil, :file quil.core, :end-column 14, :processing-name "delay()", :column 3, :processing-link nil, :requires-bindings true, :line 1458, :end-line 1458, :arglists (quote ([freeze-ms])), :doc "Forces the program to stop running for a specified time. Delay\n  times are specified in thousandths of a second, therefore the\n  function call (delay 3000) will stop the program for three\n  seconds. Because the screen is updated only at the end of draw,\n  the program may appear to 'freeze', because the screen will not\n  update when the delay fn is used. This function has no affect\n  inside setup."}, :added "1.0", :name quil.core$macros/delay-frame, :variadic false, :subcategory nil, :file nil, :end-column 14, :processing-name "delay()", :method-params ([freeze-ms]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :processing-link nil, :requires-bindings true, :line 1451, :end-line 1458, :max-fixed-arity 1, :fn-var true, :arglists (quote ([freeze-ms])), :doc "Forces the program to stop running for a specified time. Delay\n  times are specified in thousandths of a second, therefore the\n  function call (delay 3000) will stop the program for three\n  seconds. Because the screen is updated only at the end of draw,\n  the program may appear to 'freeze', because the screen will not\n  update when the delay fn is used. This function has no affect\n  inside setup."}, horizontal-alignment-modes {:name quil.core$macros/horizontal-alignment-modes, :file nil, :line 45, :column 1, :end-line 66, :end-column 28, :meta {:file quil.core, :line 66, :column 2, :end-line 66, :end-column 28}}, spot-light {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Lights", :file quil.core, :end-column 13, :top-fn {:variadic false, :max-fixed-arity 11, :method-params ([r g b x y z nx ny nz angle concentration] [[r g b] [x y z] [nx ny nz] angle concentration]), :arglists ([r g b x y z nx ny nz angle concentration] [[r g b] [x y z] [nx ny nz] angle concentration]), :arglists-meta (nil nil)}, :processing-name "spotLight()", :column 3, :requires-bindings true, :line 3908, :end-line 3908, :arglists (quote ([r g b x y z nx ny nz angle concentration] [[r g b] [x y z] [nx ny nz] angle concentration])), :doc "Adds a spot light. Lights need to be included in the draw to\n  remain persistent in a looping program. Placing them in the setup\n  of a looping program will cause them to only have an effect the\n  first time through the loop. The affect of the r, g, and b\n  parameters is determined by the current color mode. The x, y, and z\n  parameters specify the position of the light and nx, ny, nz specify\n  the direction or light. The angle parameter affects angle of the\n  spotlight cone."}, :added "1.0", :name quil.core$macros/spot-light, :variadic false, :subcategory "Lights", :file nil, :end-column 13, :top-fn {:variadic false, :max-fixed-arity 11, :method-params ([r g b x y z nx ny nz angle concentration] [[r g b] [x y z] [nx ny nz] angle concentration]), :arglists ([r g b x y z nx ny nz angle concentration] [[r g b] [x y z] [nx ny nz] angle concentration]), :arglists-meta (nil nil)}, :processing-name "spotLight()", :method-params ([r g b x y z nx ny nz angle concentration] [[r g b] [x y z] [nx ny nz] angle concentration]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3902, :end-line 3908, :max-fixed-arity 11, :fn-var true, :arglists ([r g b x y z nx ny nz angle concentration] [[r g b] [x y z] [nx ny nz] angle concentration]), :doc "Adds a spot light. Lights need to be included in the draw to\n  remain persistent in a looping program. Placing them in the setup\n  of a looping program will cause them to only have an effect the\n  first time through the loop. The affect of the r, g, and b\n  parameters is determined by the current color mode. The x, y, and z\n  parameters specify the position of the light and nx, ny, nz specify\n  the direction or light. The angle parameter affects angle of the\n  spotlight cone."}, target-frame-rate {:category "Environment", :protocol-inline nil, :meta {:category "Environment", :added "1.5.0", :subcategory nil, :file quil.core, :end-column 20, :column 3, :requires-bindings true, :line 4079, :end-line 4079, :arglists (quote ([])), :doc "Returns the target framerate specified with the fn frame-rate"}, :added "1.5.0", :name quil.core$macros/target-frame-rate, :variadic false, :subcategory nil, :file nil, :end-column 20, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 4074, :end-line 4079, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Returns the target framerate specified with the fn frame-rate"}, tint {:category "Image", :protocol-inline nil, :meta {:category "Image", :added "1.0", :subcategory "Loading & Displaying", :file quil.core, :end-column 7, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([rgb] [rgb alpha] [r g b] [r g b a]), :arglists ([rgb] [rgb alpha] [r g b] [r g b a]), :arglists-meta (nil nil nil nil)}, :processing-name "tint()", :column 3, :requires-bindings true, :line 4414, :end-line 4414, :arglists (quote ([rgb] [rgb alpha] [r g b] [r g b a])), :doc "Sets the fill value for displaying images. Images can be tinted to\n  specified colors or made transparent by setting the alpha.\n\n  To make an image transparent, but not change it's color, use white\n  as the tint color and specify an alpha value. For instance,\n  tint(255, 128) will make an image 50% transparent (unless\n  colorMode() has been used).\n\n  The value for the parameter gray must be less than or equal to the\n  current maximum value as specified by colorMode(). The default\n  maximum value is 255.\n\n  Also used to control the coloring of textures in 3D."}, :added "1.0", :name quil.core$macros/tint, :variadic false, :subcategory "Loading & Displaying", :file nil, :end-column 7, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([rgb] [rgb alpha] [r g b] [r g b a]), :arglists ([rgb] [rgb alpha] [r g b] [r g b a]), :arglists-meta (nil nil nil nil)}, :processing-name "tint()", :method-params ([rgb] [rgb alpha] [r g b] [r g b a]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :requires-bindings true, :line 4408, :end-line 4414, :max-fixed-arity 4, :fn-var true, :arglists ([rgb] [rgb alpha] [r g b] [r g b a]), :doc "Sets the fill value for displaying images. Images can be tinted to\n  specified colors or made transparent by setting the alpha.\n\n  To make an image transparent, but not change it's color, use white\n  as the tint color and specify an alpha value. For instance,\n  tint(255, 128) will make an image 50% transparent (unless\n  colorMode() has been used).\n\n  The value for the parameter gray must be less than or equal to the\n  current maximum value as specified by colorMode(). The default\n  maximum value is 255.\n\n  Also used to control the coloring of textures in 3D."}, bezier-tangent {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "Curves", :file quil.core, :end-column 17, :processing-name "bezierTangent()", :column 3, :requires-bindings true, :line 722, :end-line 722, :arglists (quote ([a b c d t])), :doc "Calculates the tangent of a point on a Bezier curve.\n  (See http://en.wikipedia.org/wiki/Tangent)"}, :added "1.0", :name quil.core$macros/bezier-tangent, :variadic false, :subcategory "Curves", :file nil, :end-column 17, :processing-name "bezierTangent()", :method-params ([a b c d t]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 716, :end-line 722, :max-fixed-arity 5, :fn-var true, :arglists (quote ([a b c d t])), :doc "Calculates the tangent of a point on a Bezier curve.\n  (See http://en.wikipedia.org/wiki/Tangent)"}, asin {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Trigonometry", :file quil.core, :end-column 7, :processing-name "asin()", :column 3, :requires-bindings false, :line 444, :end-line 444, :arglists (quote ([n])), :doc "The inverse of sin, returns the arc sine of a value. This function\n  expects the values in the range of -1 to 1 and values are returned\n  in the range -PI/2 to PI/2."}, :added "1.0", :name quil.core$macros/asin, :variadic false, :subcategory "Trigonometry", :file nil, :end-column 7, :processing-name "asin()", :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 438, :end-line 444, :max-fixed-arity 1, :fn-var true, :arglists (quote ([n])), :doc "The inverse of sin, returns the arc sine of a value. This function\n  expects the values in the range of -1 to 1 and values are returned\n  in the range -PI/2 to PI/2."}, lerp {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Calculation", :file quil.core, :end-column 7, :processing-name "lerp()", :column 3, :requires-bindings false, :line 2246, :end-line 2246, :arglists (quote ([start stop amt])), :doc "Calculates a number between two numbers at a specific\n  increment. The amt parameter is the amount to interpolate between\n  the two values where 0.0 equal to the first point, 0.1 is very near\n  the first point, 0.5 is half-way in between, etc. The lerp function\n  is convenient for creating motion along a straight path and for\n  drawing dotted lines."}, :added "1.0", :name quil.core$macros/lerp, :variadic false, :subcategory "Calculation", :file nil, :end-column 7, :processing-name "lerp()", :method-params ([start stop amt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 2240, :end-line 2246, :max-fixed-arity 3, :fn-var true, :arglists (quote ([start stop amt])), :doc "Calculates a number between two numbers at a specific\n  increment. The amt parameter is the amount to interpolate between\n  the two values where 0.0 equal to the first point, 0.1 is very near\n  the first point, 0.5 is half-way in between, etc. The lerp function\n  is convenient for creating motion along a straight path and for\n  drawing dotted lines."}, unhex {:category "Data", :protocol-inline nil, :meta {:category "Data", :require-binding false, :subcategory "Conversion", :file quil.core, :end-column 8, :processing-name "hex()", :column 3, :line 4491, :end-line 4491, :arglists (quote ([hex-str])), :doc "Converts a String representation of a hexadecimal number to its\n  equivalent integer value."}, :require-binding false, :name quil.core$macros/unhex, :variadic false, :subcategory "Conversion", :file nil, :end-column 8, :processing-name "hex()", :method-params ([hex-str]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4486, :end-line 4491, :max-fixed-arity 1, :fn-var true, :arglists (quote ([hex-str])), :doc "Converts a String representation of a hexadecimal number to its\n  equivalent integer value."}, begin-camera {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Camera", :file quil.core, :end-column 15, :processing-name "beginCamera()", :column 3, :requires-bindings true, :line 585, :end-line 585, :arglists (quote ([])), :doc "Sets the matrix mode to the camera matrix so calls such as\n  translate, rotate, apply-matrix and reset-matrix affect the\n  camera. begin-camera should always be used with a following\n  end-camera and pairs of begin-camera and end-camera cannot be\n  nested.\n\n  For most situations the camera function will be sufficient."}, :added "1.0", :name quil.core$macros/begin-camera, :variadic false, :subcategory "Camera", :file nil, :end-column 15, :processing-name "beginCamera()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 579, :end-line 585, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Sets the matrix mode to the camera matrix so calls such as\n  translate, rotate, apply-matrix and reset-matrix affect the\n  camera. begin-camera should always be used with a following\n  end-camera and pairs of begin-camera and end-camera cannot be\n  nested.\n\n  For most situations the camera function will be sufficient."}, text-num {:category "Typography", :protocol-inline nil, :meta {:category "Typography", :added "1.0", :subcategory "Loading & Displaying", :file quil.core, :end-column 11, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([num x y] [num x y z]), :arglists ([num x y] [num x y z]), :arglists-meta (nil nil)}, :processing-name "text()", :column 3, :requires-bindings true, :line 4113, :end-line 4113, :arglists (quote ([num x y] [num x y z])), :doc "Draws a number to the screen in the specified position. See text fn\n  for more details."}, :added "1.0", :name quil.core$macros/text-num, :variadic false, :subcategory "Loading & Displaying", :file nil, :end-column 11, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([num x y] [num x y z]), :arglists ([num x y] [num x y z]), :arglists-meta (nil nil)}, :processing-name "text()", :method-params ([num x y] [num x y z]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 4107, :end-line 4113, :max-fixed-arity 4, :fn-var true, :arglists ([num x y] [num x y z]), :doc "Draws a number to the screen in the specified position. See text fn\n  for more details."}, round {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Calculation", :file quil.core, :end-column 8, :processing-name "round()", :column 3, :requires-bindings false, :line 3480, :end-line 3480, :arglists (quote ([val])), :doc "Calculates the integer closest to the value parameter. For example,\n  (round 9.2) returns the value 9."}, :added "1.0", :name quil.core$macros/round, :variadic false, :subcategory "Calculation", :file nil, :end-column 8, :processing-name "round()", :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 3474, :end-line 3480, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :doc "Calculates the integer closest to the value parameter. For example,\n  (round 9.2) returns the value 9."}, background-image {:category "Color", :protocol-inline nil, :meta {:category "Color", :added "1.0", :subcategory "Setting", :file quil.core, :end-column 19, :processing-name "background()", :column 3, :requires-bindings true, :line 572, :end-line 572, :arglists (quote ([img])), :doc "Specify an image to be used as the background for a sketch. Its\n  width and height must be the same size as the sketch window. Images\n  used as background will ignore the current tint setting."}, :added "1.0", :name quil.core$macros/background-image, :variadic false, :subcategory "Setting", :file nil, :end-column 19, :processing-name "background()", :method-params ([img]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 566, :end-line 572, :max-fixed-arity 1, :fn-var true, :arglists (quote ([img])), :doc "Specify an image to be used as the background for a sketch. Its\n  width and height must be the same size as the sketch window. Images\n  used as background will ignore the current tint setting."}, load-shape {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "Loading & Displaying", :file quil.core, :end-column 13, :processing-name "loadShape()", :column 3, :requires-bindings true, :line 2396, :end-line 2396, :arglists (quote ([filename])), :doc "Load a geometry from a file as a PShape."}, :added "1.0", :name quil.core$macros/load-shape, :variadic false, :subcategory "Loading & Displaying", :file nil, :end-column 13, :processing-name "loadShape()", :method-params ([filename]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2390, :end-line 2396, :max-fixed-arity 1, :fn-var true, :arglists (quote ([filename])), :doc "Load a geometry from a file as a PShape."}, vertical-alignment-modes {:name quil.core$macros/vertical-alignment-modes, :file nil, :line 45, :column 1, :end-line 67, :end-column 26, :meta {:file quil.core, :line 67, :column 2, :end-line 67, :end-column 26}}, blend-color {:category "Color", :protocol-inline nil, :meta {:category "Color", :added "1.0", :subcategory "Creating & Reading", :file quil.core, :end-column 14, :processing-name "blendColor()", :column 3, :processing-link nil, :requires-bindings false, :line 828, :end-line 828, :arglists (quote ([c1 c2 mode])), :doc "Blends two color values together based on the blending mode given specified\n  with the mode keyword.\n\n  Available blend modes are:\n\n  :blend      - linear interpolation of colours: C = A*factor + B\n  :add        - additive blending with white clip:\n                                            C = min(A*factor + B, 255)\n  :subtract   - subtractive blending with black clip:\n                                            C = max(B - A*factor, 0)\n  :darkest    - only the darkest colour succeeds:\n                                            C = min(A*factor, B)\n  :lightest   - only the lightest colour succeeds:\n                                            C = max(A*factor, B)\n  :difference - subtract colors from underlying image.\n  :exclusion  - similar to :difference, but less extreme.\n  :multiply   - Multiply the colors, result will always be darker.\n  :screen     - Opposite multiply, uses inverse values of the colors.\n  :overlay    - A mix of :multiply and :screen. Multiplies dark values\n                and screens light values.\n  :hard-light - :screen when greater than 50% gray, :multiply when\n                lower.\n  :soft-light - Mix of :darkest and :lightest. Works like :overlay,\n                but not as harsh.\n  :dodge      - Lightens light tones and increases contrast, ignores\n                darks.\n                Called \"Color Dodge\" in Illustrator and Photoshop.\n  :burn       - Darker areas are applied, increasing contrast, ignores\n                lights. Called \"Color Burn\" in Illustrator and\n                Photoshop."}, :added "1.0", :name quil.core$macros/blend-color, :variadic false, :subcategory "Creating & Reading", :file nil, :end-column 14, :processing-name "blendColor()", :method-params ([c1 c2 mode]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :processing-link nil, :requires-bindings false, :line 821, :end-line 828, :max-fixed-arity 3, :fn-var true, :arglists (quote ([c1 c2 mode])), :doc "Blends two color values together based on the blending mode given specified\n  with the mode keyword.\n\n  Available blend modes are:\n\n  :blend      - linear interpolation of colours: C = A*factor + B\n  :add        - additive blending with white clip:\n                                            C = min(A*factor + B, 255)\n  :subtract   - subtractive blending with black clip:\n                                            C = max(B - A*factor, 0)\n  :darkest    - only the darkest colour succeeds:\n                                            C = min(A*factor, B)\n  :lightest   - only the lightest colour succeeds:\n                                            C = max(A*factor, B)\n  :difference - subtract colors from underlying image.\n  :exclusion  - similar to :difference, but less extreme.\n  :multiply   - Multiply the colors, result will always be darker.\n  :screen     - Opposite multiply, uses inverse values of the colors.\n  :overlay    - A mix of :multiply and :screen. Multiplies dark values\n                and screens light values.\n  :hard-light - :screen when greater than 50% gray, :multiply when\n                lower.\n  :soft-light - Mix of :darkest and :lightest. Works like :overlay,\n                but not as harsh.\n  :dodge      - Lightens light tones and increases contrast, ignores\n                darks.\n                Called \"Color Dodge\" in Illustrator and Photoshop.\n  :burn       - Darker areas are applied, increasing contrast, ignores\n                lights. Called \"Color Burn\" in Illustrator and\n                Photoshop."}, QUARTER-PI {:name quil.core$macros/QUARTER-PI, :file nil, :line 79, :column 1, :end-line 79, :end-column 16, :meta {:file quil.core, :line 79, :column 6, :end-line 79, :end-column 16}}, stroke-cap {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "Attributes", :file quil.core, :end-column 13, :processing-name "strokeCap()", :column 3, :requires-bindings true, :line 4017, :end-line 4017, :arglists (quote ([cap-mode])), :doc "Sets the style for rendering line endings. These ends are either\n  squared, extended, or rounded and specified with the corresponding\n  parameters :square, :project, and :round. The default cap is :round."}, :added "1.0", :name quil.core$macros/stroke-cap, :variadic false, :subcategory "Attributes", :file nil, :end-column 13, :processing-name "strokeCap()", :method-params ([cap-mode]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 4011, :end-line 4017, :max-fixed-arity 1, :fn-var true, :arglists (quote ([cap-mode])), :doc "Sets the style for rendering line endings. These ends are either\n  squared, extended, or rounded and specified with the corresponding\n  parameters :square, :project, and :round. The default cap is :round."}, blend-modes {:name quil.core$macros/blend-modes, :file nil, :line 45, :column 1, :end-line 48, :end-column 13, :meta {:file quil.core, :line 48, :column 2, :end-line 48, :end-column 13}}, no-fill {:category "Color", :protocol-inline nil, :meta {:category "Color", :added "1.0", :subcategory "Setting", :file quil.core, :end-column 10, :processing-name "noFill()", :column 3, :requires-bindings true, :line 2643, :end-line 2643, :arglists (quote ([])), :doc "Disables filling geometry. If both no-stroke and no-fill are called,\n  nothing will be drawn to the screen."}, :added "1.0", :name quil.core$macros/no-fill, :variadic false, :subcategory "Setting", :file nil, :end-column 10, :processing-name "noFill()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2637, :end-line 2643, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Disables filling geometry. If both no-stroke and no-fill are called,\n  nothing will be drawn to the screen."}, year {:category "Input", :protocol-inline nil, :meta {:category "Input", :added "1.0", :subcategory "Time & Date", :file quil.core, :end-column 7, :processing-name "year()", :column 3, :requires-bindings false, :line 4560, :end-line 4560, :arglists (quote ([])), :doc "Returns the current year as an integer (2003, 2004, 2005, etc)."}, :added "1.0", :name quil.core$macros/year, :variadic false, :subcategory "Time & Date", :file nil, :end-column 7, :processing-name "year()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 4554, :end-line 4560, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Returns the current year as an integer (2003, 2004, 2005, etc)."}, key-coded? {:category "Input", :protocol-inline nil, :meta {:category "Input", :added "1.6", :subcategory "Keyboard", :file quil.core, :end-column 13, :processing-name nil, :column 3, :requires-bindings false, :line 4839, :end-line 4839, :arglists (quote ([c])), :doc "Returns true if char c is a 'coded' char i.e. it is necessary to\n  fetch the key-code as an integer and use that to determine the\n  specific key pressed. See key-keyword."}, :added "1.6", :name quil.core$macros/key-coded?, :variadic false, :subcategory "Keyboard", :file nil, :end-column 13, :processing-name nil, :method-params ([c]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 4834, :end-line 4839, :max-fixed-arity 1, :fn-var true, :arglists (quote ([c])), :doc "Returns true if char c is a 'coded' char i.e. it is necessary to\n  fetch the key-code as an integer and use that to determine the\n  specific key pressed. See key-keyword."}, curve-tangent {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "Curves", :file quil.core, :end-column 16, :processing-name "curveTangent()", :column 3, :requires-bindings true, :line 1377, :end-line 1377, :arglists (quote ([a b c d t])), :doc "Calculates the tangent of a point on a curve.\n  See: http://en.wikipedia.org/wiki/Tangent"}, :added "1.0", :name quil.core$macros/curve-tangent, :variadic false, :subcategory "Curves", :file nil, :end-column 16, :processing-name "curveTangent()", :method-params ([a b c d t]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1371, :end-line 1377, :max-fixed-arity 5, :fn-var true, :arglists (quote ([a b c d t])), :doc "Calculates the tangent of a point on a curve.\n  See: http://en.wikipedia.org/wiki/Tangent"}, ellipse-modes {:name quil.core$macros/ellipse-modes, :file nil, :line 45, :column 1, :end-line 52, :end-column 15, :meta {:file quil.core, :line 52, :column 2, :end-line 52, :end-column 15}}, pmouse-y {:category "Input", :protocol-inline nil, :meta {:category "Input", :added "1.0", :subcategory "Mouse", :file quil.core, :end-column 11, :processing-name "pmouseY", :column 3, :requires-bindings true, :line 2935, :end-line 2935, :arglists (quote ([])), :doc "Vertical coordinate of the mouse in the previous frame"}, :added "1.0", :name quil.core$macros/pmouse-y, :variadic false, :subcategory "Mouse", :file nil, :end-column 11, :processing-name "pmouseY", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2929, :end-line 2935, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Vertical coordinate of the mouse in the previous frame"}, hex {:category "Data", :protocol-inline nil, :meta {:category "Data", :require-binding false, :subcategory "Conversion", :file quil.core, :end-column 6, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([val] [val num-digits]), :arglists ([val] [val num-digits]), :arglists-meta (nil nil)}, :processing-name "hex()", :column 3, :line 1931, :end-line 1931, :arglists (quote ([val] [val num-digits])), :doc "Converts a byte, char, int, or color to a String containing the\n  equivalent hexadecimal notation. For example color(0, 102, 153) will\n  convert to the String \"FF006699\". This function can help make your\n  geeky debugging sessions much happier. "}, :require-binding false, :name quil.core$macros/hex, :variadic false, :subcategory "Conversion", :file nil, :end-column 6, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([val] [val num-digits]), :arglists ([val] [val num-digits]), :arglists-meta (nil nil)}, :processing-name "hex()", :method-params ([val] [val num-digits]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1926, :end-line 1931, :max-fixed-arity 2, :fn-var true, :arglists ([val] [val num-digits]), :doc "Converts a byte, char, int, or color to a String containing the\n  equivalent hexadecimal notation. For example color(0, 102, 153) will\n  convert to the String \"FF006699\". This function can help make your\n  geeky debugging sessions much happier. "}, with-fill {:category "Color", :protocol-inline nil, :meta {:category "Color", :added "1.7", :subcategory "Utility Macros", :file quil.core, :end-column 13, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env fill-args body)], :arglists ([&form &env fill-args & body]), :arglists-meta (nil)}, :processing-name nil, :column 4, :requires-bindings true, :line 4585, :macro true, :end-line 4585, :arglists (quote ([fill-args & body])), :doc "Temporarily set the fill color for the body of this macro.\n   The code outside of with-fill form will have the previous fill color set.\n\n   The fill color has to be in a vector!\n   Example: (with-fill [255] ...)\n            (with-fill [10 80 98] ...)"}, :added "1.7", :name quil.core$macros/with-fill, :variadic true, :subcategory "Utility Macros", :file nil, :end-column 13, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env fill-args body)], :arglists ([&form &env fill-args & body]), :arglists-meta (nil)}, :processing-name nil, :method-params [(&form &env fill-args body)], :protocol-impl nil, :arglists-meta (nil), :column 1, :requires-bindings true, :line 4579, :macro true, :end-line 4585, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env fill-args & body]), :doc "Temporarily set the fill color for the body of this macro.\n   The code outside of with-fill form will have the previous fill color set.\n\n   The fill color has to be in a vector!\n   Example: (with-fill [255] ...)\n            (with-fill [10 80 98] ...)"}, no-cursor {:category "Environment", :protocol-inline nil, :meta {:category "Environment", :added "1.0", :subcategory nil, :file quil.core, :end-column 12, :processing-name "noCursor()", :column 3, :requires-bindings true, :line 2631, :end-line 2631, :arglists (quote ([])), :doc "Hides the cursor from view. Will not work when running the in full\n  screen (Present) mode."}, :added "1.0", :name quil.core$macros/no-cursor, :variadic false, :subcategory nil, :file nil, :end-column 12, :processing-name "noCursor()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2625, :end-line 2631, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Hides the cursor from view. Will not work when running the in full\n  screen (Present) mode."}, create-font {:category "Typography", :protocol-inline nil, :meta {:category "Typography", :added "1.0", :subcategory "Loading & Displaying", :file quil.core, :end-column 14, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([name size] [name size smooth] [name size smooth charset]), :arglists ([name size] [name size smooth] [name size smooth charset]), :arglists-meta (nil nil nil)}, :processing-name "createFont()", :column 3, :requires-bindings true, :line 1167, :end-line 1167, :arglists (quote ([name size] [name size smooth] [name size smooth charset])), :doc "Dynamically converts a font to the format used by Processing (a\n  PFont) from either a font name that's installed on the computer, or\n  from a .ttf or .otf file inside the sketches 'data' folder. This\n  function is an advanced feature for precise control.\n\n  Use available-fonts to obtain the names for the fonts recognized by\n  the computer and are compatible with this function.\n\n  The size parameter states the font size you want to generate. The\n  smooth parameter specifies if the font should be antialiased or not,\n  and the charset parameter is an array of chars that specifies the\n  characters to generate.\n\n  This function creates a bitmapped version of a font It loads a font\n  by name, and converts it to a series of images based on the size of\n  the font. When possible, the text function will use a native font\n  rather than the bitmapped version created behind the scenes with\n  create-font. For instance, when using the default renderer\n  setting (JAVA2D), the actual native version of the font will be\n  employed by the sketch, improving drawing quality and\n  performance. With the :p2d, :p3d, and :opengl renderer settings, the\n  bitmapped version will be used. While this can drastically improve\n  speed and appearance, results are poor when exporting if the sketch\n  does not include the .otf or .ttf file, and the requested font is\n  not available on the machine running the sketch."}, :added "1.0", :name quil.core$macros/create-font, :variadic false, :subcategory "Loading & Displaying", :file nil, :end-column 14, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([name size] [name size smooth] [name size smooth charset]), :arglists ([name size] [name size smooth] [name size smooth charset]), :arglists-meta (nil nil nil)}, :processing-name "createFont()", :method-params ([name size] [name size smooth] [name size smooth charset]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :requires-bindings true, :line 1161, :end-line 1167, :max-fixed-arity 4, :fn-var true, :arglists ([name size] [name size smooth] [name size smooth charset]), :doc "Dynamically converts a font to the format used by Processing (a\n  PFont) from either a font name that's installed on the computer, or\n  from a .ttf or .otf file inside the sketches 'data' folder. This\n  function is an advanced feature for precise control.\n\n  Use available-fonts to obtain the names for the fonts recognized by\n  the computer and are compatible with this function.\n\n  The size parameter states the font size you want to generate. The\n  smooth parameter specifies if the font should be antialiased or not,\n  and the charset parameter is an array of chars that specifies the\n  characters to generate.\n\n  This function creates a bitmapped version of a font It loads a font\n  by name, and converts it to a series of images based on the size of\n  the font. When possible, the text function will use a native font\n  rather than the bitmapped version created behind the scenes with\n  create-font. For instance, when using the default renderer\n  setting (JAVA2D), the actual native version of the font will be\n  employed by the sketch, improving drawing quality and\n  performance. With the :p2d, :p3d, and :opengl renderer settings, the\n  bitmapped version will be used. While this can drastically improve\n  speed and appearance, results are poor when exporting if the sketch\n  does not include the .otf or .ttf file, and the requested font is\n  not available on the machine running the sketch."}, current-graphics {:category "Environment", :protocol-inline nil, :meta {:category "Environment", :added "2.0", :subcategory nil, :file quil.core, :end-column 19, :column 3, :requires-bindings true, :line 32, :end-line 32, :tag PGraphics, :arglists (quote ([])), :doc "Graphics currently used for drawing. By default it is sketch graphics,\n  but if called inside with-graphics macro - graphics passed to the macro\n  is returned. This method should be used if you need to call some methods\n  that are not implemented by quil. Example:\n  (.beginDraw (current-graphics))."}, :added "2.0", :name quil.core$macros/current-graphics, :variadic false, :subcategory nil, :file nil, :end-column 19, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 26, :ret-tag PGraphics, :end-line 32, :max-fixed-arity 0, :tag PGraphics, :fn-var true, :arglists (quote ([])), :doc "Graphics currently used for drawing. By default it is sketch graphics,\n  but if called inside with-graphics macro - graphics passed to the macro\n  is returned. This method should be used if you need to call some methods\n  that are not implemented by quil. Example:\n  (.beginDraw (current-graphics))."}, abs {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Calculation", :file quil.core, :end-column 6, :processing-name "abs()", :column 3, :requires-bindings false, :line 281, :end-line 281, :arglists (quote ([n])), :doc "Calculates the absolute value (magnitude) of a number. The\n  absolute value of a number is always positive. Dynamically casts to\n  an int or float appropriately"}, :added "1.0", :name quil.core$macros/abs, :variadic false, :subcategory "Calculation", :file nil, :end-column 6, :processing-name "abs()", :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 275, :end-line 281, :max-fixed-arity 1, :fn-var true, :arglists (quote ([n])), :doc "Calculates the absolute value (magnitude) of a number. The\n  absolute value of a number is always positive. Dynamically casts to\n  an int or float appropriately"}, pop-style {:category "Structure", :protocol-inline nil, :meta {:category "Structure", :added "1.0", :subcategory nil, :file quil.core, :end-column 12, :processing-name "popStyle()", :column 3, :requires-bindings true, :line 2995, :end-line 2995, :arglists (quote ([])), :doc "Restores the prior settings on the 'style stack'. Used in\n  conjunction with push-style. Together they allow you to change the\n  style settings and later return to what you had. When a new style is\n  started with push-style, it builds on the current style information.\n  The push-style and pop-style functions can be nested to provide more\n  control"}, :added "1.0", :name quil.core$macros/pop-style, :variadic false, :subcategory nil, :file nil, :end-column 12, :processing-name "popStyle()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2989, :end-line 2995, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Restores the prior settings on the 'style stack'. Used in\n  conjunction with push-style. Together they allow you to change the\n  style settings and later return to what you had. When a new style is\n  started with push-style, it builds on the current style information.\n  The push-style and pop-style functions can be nested to provide more\n  control"}, focused {:category "Environment", :protocol-inline nil, :meta {:category "Environment", :added "1.0", :subcategory nil, :file quil.core, :end-column 10, :processing-name "focused", :column 3, :requires-bindings true, :line 1823, :end-line 1823, :arglists (quote ([])), :doc "Returns a boolean value representing whether the applet has focus."}, :added "1.0", :name quil.core$macros/focused, :variadic false, :subcategory nil, :file nil, :end-column 10, :processing-name "focused", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1817, :end-line 1823, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Returns a boolean value representing whether the applet has focus."}, background-float {:category "Color", :protocol-inline nil, :meta {:category "Color", :added "1.0", :subcategory "Setting", :file quil.core, :end-column 19, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([gray] [gray alpha] [r g b] [r g b a]), :arglists ([gray] [gray alpha] [r g b] [r g b a]), :arglists-meta (nil nil nil nil)}, :processing-name "background()", :column 3, :requires-bindings true, :line 512, :end-line 512, :arglists (quote ([gray] [gray alpha] [r g b] [r g b a])), :doc "Sets the color used for the background of the Processing\n  window. The default background is light gray. In the draw function,\n  the background color is used to clear the display window at the\n  beginning of each frame.\n\n  It is not possible to use transparency (alpha) in background colors\n  with the main drawing surface, however they will work properly with\n  create-graphics. Converts args to floats."}, :added "1.0", :name quil.core$macros/background-float, :variadic false, :subcategory "Setting", :file nil, :end-column 19, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([gray] [gray alpha] [r g b] [r g b a]), :arglists ([gray] [gray alpha] [r g b] [r g b a]), :arglists-meta (nil nil nil nil)}, :processing-name "background()", :method-params ([gray] [gray alpha] [r g b] [r g b a]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :requires-bindings true, :line 506, :end-line 512, :max-fixed-arity 4, :fn-var true, :arglists ([gray] [gray alpha] [r g b] [r g b a]), :doc "Sets the color used for the background of the Processing\n  window. The default background is light gray. In the draw function,\n  the background color is used to clear the display window at the\n  beginning of each frame.\n\n  It is not possible to use transparency (alpha) in background colors\n  with the main drawing surface, however they will work properly with\n  create-graphics. Converts args to floats."}, text-mode {:category "Typography", :protocol-inline nil, :meta {:category "Typography", :added "1.0", :subcategory "Attributes", :file quil.core, :end-column 12, :processing-name "textMode()", :column 3, :requires-bindings true, :line 4260, :end-line 4260, :arglists (quote ([mode])), :doc "Sets the way text draws to the screen - available modes\n  are :model and :shape\n\n  In the default configuration (the :model mode), it's possible to\n  rotate, scale, and place letters in two and three dimensional space.\n\n  The :shape mode draws text using the glyph outlines of individual\n  characters rather than as textures. This mode is only supported with\n  the PDF and OPENGL renderer settings. With the PDF renderer, you\n  must specify the :shape text-mode before any other drawing occurs.\n  If the outlines are not available, then :shape will be ignored and\n  :model will be used instead.\n\n  The :shape option in OPENGL mode can be combined with begin-raw to\n  write vector-accurate text to 2D and 3D output files, for instance\n  DXF or PDF. :shape is not currently optimized for OPENGL, so if\n  recording shape data, use :model until you're ready to capture the\n  geometry with begin-raw."}, :added "1.0", :name quil.core$macros/text-mode, :variadic false, :subcategory "Attributes", :file nil, :end-column 12, :processing-name "textMode()", :method-params ([mode]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 4254, :end-line 4260, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mode])), :doc "Sets the way text draws to the screen - available modes\n  are :model and :shape\n\n  In the default configuration (the :model mode), it's possible to\n  rotate, scale, and place letters in two and three dimensional space.\n\n  The :shape mode draws text using the glyph outlines of individual\n  characters rather than as textures. This mode is only supported with\n  the PDF and OPENGL renderer settings. With the PDF renderer, you\n  must specify the :shape text-mode before any other drawing occurs.\n  If the outlines are not available, then :shape will be ignored and\n  :model will be used instead.\n\n  The :shape option in OPENGL mode can be combined with begin-raw to\n  write vector-accurate text to 2D and 3D output files, for instance\n  DXF or PDF. :shape is not currently optimized for OPENGL, so if\n  recording shape data, use :model until you're ready to capture the\n  geometry with begin-raw."}, image-mode {:category "Image", :protocol-inline nil, :meta {:category "Image", :added "1.0", :subcategory "Loading & Displaying", :file quil.core, :end-column 13, :processing-name "imageMode()", :column 3, :requires-bindings true, :line 2125, :end-line 2125, :arglists (quote ([mode])), :doc "Modifies the location from which images draw. The default mode is :corner.\n   Available modes are:\n\n  :corner  - specifies the location to be the upper left corner and\n             uses the fourth and fifth parameters of image to set the\n             image's width and height.\n\n  :corners - uses the second and third parameters of image to set the\n             location of one corner of the image and uses the fourth\n             and fifth parameters to set the opposite corner.\n\n  :center  - draw images centered at the given x and y position."}, :added "1.0", :name quil.core$macros/image-mode, :variadic false, :subcategory "Loading & Displaying", :file nil, :end-column 13, :processing-name "imageMode()", :method-params ([mode]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2119, :end-line 2125, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mode])), :doc "Modifies the location from which images draw. The default mode is :corner.\n   Available modes are:\n\n  :corner  - specifies the location to be the upper left corner and\n             uses the fourth and fifth parameters of image to set the\n             image's width and height.\n\n  :corners - uses the second and third parameters of image to set the\n             location of one corner of the image and uses the fourth\n             and fifth parameters to set the opposite corner.\n\n  :center  - draw images centered at the given x and y position."}, line {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "2D Primitives", :file quil.core, :end-column 7, :top-fn {:variadic false, :max-fixed-arity 6, :method-params ([p1 p2] [x1 y1 x2 y2] [x1 y1 z1 x2 y2 z2]), :arglists ([p1 p2] [x1 y1 x2 y2] [x1 y1 z1 x2 y2 z2]), :arglists-meta (nil nil nil)}, :processing-name "line()", :column 3, :requires-bindings true, :line 2302, :end-line 2302, :arglists (quote ([p1 p2] [x1 y1 x2 y2] [x1 y1 z1 x2 y2 z2])), :doc "Draws a line (a direct path between two points) to the screen. The\n  version of line with four parameters draws the line in 2D. To color\n  a line, use the stroke function. A line cannot be filled, therefore\n  the fill method will not affect the color of a line. 2D lines are\n  drawn with a width of one pixel by default, but this can be changed\n  with the stroke-weight function. The version with six parameters\n  allows the line to be placed anywhere within XYZ space. "}, :added "1.0", :name quil.core$macros/line, :variadic false, :subcategory "2D Primitives", :file nil, :end-column 7, :top-fn {:variadic false, :max-fixed-arity 6, :method-params ([p1 p2] [x1 y1 x2 y2] [x1 y1 z1 x2 y2 z2]), :arglists ([p1 p2] [x1 y1 x2 y2] [x1 y1 z1 x2 y2 z2]), :arglists-meta (nil nil nil)}, :processing-name "line()", :method-params ([p1 p2] [x1 y1 x2 y2] [x1 y1 z1 x2 y2 z2]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :requires-bindings true, :line 2296, :end-line 2302, :max-fixed-arity 6, :fn-var true, :arglists ([p1 p2] [x1 y1 x2 y2] [x1 y1 z1 x2 y2 z2]), :doc "Draws a line (a direct path between two points) to the screen. The\n  version of line with four parameters draws the line in 2D. To color\n  a line, use the stroke function. A line cannot be filled, therefore\n  the fill method will not affect the color of a line. 2D lines are\n  drawn with a width of one pixel by default, but this can be changed\n  with the stroke-weight function. The version with six parameters\n  allows the line to be placed anywhere within XYZ space. "}, red {:category "Color", :protocol-inline nil, :meta {:category "Color", :added "1.0", :subcategory "Creating & Reading", :file quil.core, :end-column 6, :processing-name "red()", :column 3, :requires-bindings true, :line 3286, :end-line 3286, :arglists (quote ([c])), :doc "Extracts the red value from a color, scaled to match current color-mode."}, :added "1.0", :name quil.core$macros/red, :variadic false, :subcategory "Creating & Reading", :file nil, :end-column 6, :processing-name "red()", :method-params ([c]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3280, :end-line 3286, :max-fixed-arity 1, :fn-var true, :arglists (quote ([c])), :doc "Extracts the red value from a color, scaled to match current color-mode."}, current-fill {:category "Color", :protocol-inline nil, :meta {:category "Color", :subcategory "Creating & Reading", :file quil.core, :end-column 15, :processing-name "PGraphics.fillColor", :column 3, :processing-link "http://processing.github.io/processing-javadocs/core/processing/core/PGraphics.html#fillColor", :requires-bindings true, :line 1264, :end-line 1264, :arglists (quote ([])), :doc "Return the current fill color."}, :name quil.core$macros/current-fill, :variadic false, :subcategory "Creating & Reading", :file nil, :end-column 15, :processing-name "PGraphics.fillColor", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :processing-link "http://processing.github.io/processing-javadocs/core/processing/core/PGraphics.html#fillColor", :requires-bindings true, :line 1258, :end-line 1264, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Return the current fill color."}, color-modes {:name quil.core$macros/color-modes, :file nil, :line 45, :column 1, :end-line 50, :end-column 13, :meta {:file quil.core, :line 50, :column 2, :end-line 50, :end-column 13}}, blue {:category "Color", :protocol-inline nil, :meta {:category "Color", :added "1.0", :subcategory "Creating & Reading", :file quil.core, :end-column 7, :processing-name "blue()", :column 3, :requires-bindings true, :line 905, :end-line 905, :arglists (quote ([color])), :doc "Extracts the blue value from a color, scaled to match current color-mode.\n  Returns a float."}, :added "1.0", :name quil.core$macros/blue, :variadic false, :subcategory "Creating & Reading", :file nil, :end-column 7, :processing-name "blue()", :method-params ([color]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 899, :end-line 905, :max-fixed-arity 1, :fn-var true, :arglists (quote ([color])), :doc "Extracts the blue value from a color, scaled to match current color-mode.\n  Returns a float."}, frustum {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Camera", :file quil.core, :end-column 10, :processing-name "frustum()", :column 3, :requires-bindings true, :line 1877, :end-line 1877, :arglists (quote ([left right bottom top near far])), :doc "Sets a perspective matrix defined through the parameters. Works\n  like glFrustum, except it wipes out the current perspective matrix\n  rather than muliplying itself with it."}, :added "1.0", :name quil.core$macros/frustum, :variadic false, :subcategory "Camera", :file nil, :end-column 10, :processing-name "frustum()", :method-params ([left right bottom top near far]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1871, :end-line 1877, :max-fixed-arity 6, :fn-var true, :arglists (quote ([left right bottom top near far])), :doc "Sets a perspective matrix defined through the parameters. Works\n  like glFrustum, except it wipes out the current perspective matrix\n  rather than muliplying itself with it."}, with-rotation {:category "Transform", :protocol-inline nil, :meta {:category "Transform", :added "1.0", :subcategory "Utility Macros", :file quil.core, :end-column 16, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env rotation body)], :arglists ([&form &env rotation & body]), :arglists-meta (nil)}, :processing-name nil, :column 3, :requires-bindings true, :line 4641, :macro true, :end-line 4641, :arglists (quote ([rotation & body])), :doc "Performs body with rotation, restores current transformation on exit.\n  Accepts a vector [angle] or [angle x-axis y-axis z-axis].\n\n  Example:\n    (with-rotation [angle]\n      (vertex 1 2))"}, :added "1.0", :name quil.core$macros/with-rotation, :variadic true, :subcategory "Utility Macros", :file nil, :end-column 16, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(&form &env rotation body)], :arglists ([&form &env rotation & body]), :arglists-meta (nil)}, :processing-name nil, :method-params [(&form &env rotation body)], :protocol-impl nil, :arglists-meta (nil), :column 1, :requires-bindings true, :line 4635, :macro true, :end-line 4641, :max-fixed-arity 3, :fn-var true, :arglists ([&form &env rotation & body]), :doc "Performs body with rotation, restores current transformation on exit.\n  Accepts a vector [angle] or [angle x-axis y-axis z-axis].\n\n  Example:\n    (with-rotation [angle]\n      (vertex 1 2))"}, print-matrix {:category "Transform", :protocol-inline nil, :meta {:category "Transform", :added "1.0", :subcategory nil, :file quil.core, :end-column 15, :processing-name "printMatrix()", :column 3, :requires-bindings true, :line 3038, :end-line 3038, :arglists (quote ([])), :doc "Prints the current matrix to std out. Useful for debugging."}, :added "1.0", :name quil.core$macros/print-matrix, :variadic false, :subcategory nil, :file nil, :end-column 15, :processing-name "printMatrix()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3032, :end-line 3038, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Prints the current matrix to std out. Useful for debugging."}, ambient-light {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Lights", :file quil.core, :end-column 16, :top-fn {:variadic false, :max-fixed-arity 6, :method-params ([red green blue] [red green blue x y z]), :arglists ([red green blue] [red green blue x y z]), :arglists-meta (nil nil)}, :processing-name "ambientLight()", :column 3, :requires-bindings true, :line 375, :end-line 375, :arglists (quote ([red green blue] [red green blue x y z])), :doc "Adds an ambient light. Ambient light doesn't come from a specific direction,\n  the rays have light have bounced around so much that objects are\n  evenly lit from all sides. Ambient lights are almost always used in\n  combination with other types of lights. Lights need to be included\n  in the draw to remain persistent in a looping program. Placing them\n  in the setup of a looping program will cause them to only have an\n  effect the first time through the loop. The effect of the\n  parameters is determined by the current color mode."}, :added "1.0", :name quil.core$macros/ambient-light, :variadic false, :subcategory "Lights", :file nil, :end-column 16, :top-fn {:variadic false, :max-fixed-arity 6, :method-params ([red green blue] [red green blue x y z]), :arglists ([red green blue] [red green blue x y z]), :arglists-meta (nil nil)}, :processing-name "ambientLight()", :method-params ([red green blue] [red green blue x y z]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 369, :end-line 375, :max-fixed-arity 6, :fn-var true, :arglists ([red green blue] [red green blue x y z]), :doc "Adds an ambient light. Ambient light doesn't come from a specific direction,\n  the rays have light have bounced around so much that objects are\n  evenly lit from all sides. Ambient lights are almost always used in\n  combination with other types of lights. Lights need to be included\n  in the draw to remain persistent in a looping program. Placing them\n  in the setup of a looping program will cause them to only have an\n  effect the first time through the loop. The effect of the\n  parameters is determined by the current color mode."}, bezier-point {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "Curves", :file quil.core, :end-column 15, :processing-name "bezierPoint()", :column 3, :requires-bindings true, :line 706, :end-line 706, :arglists (quote ([a b c d t])), :doc "Evaluates the Bezier at point t for points a, b, c, d. The\n  parameter t varies between 0 and 1, a and d are points on the curve,\n  and b and c are the control points. This can be done once with the x\n  coordinates and a second time with the y coordinates to get the\n  location of a bezier curve at t."}, :added "1.0", :name quil.core$macros/bezier-point, :variadic false, :subcategory "Curves", :file nil, :end-column 15, :processing-name "bezierPoint()", :method-params ([a b c d t]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 700, :end-line 706, :max-fixed-arity 5, :fn-var true, :arglists (quote ([a b c d t])), :doc "Evaluates the Bezier at point t for points a, b, c, d. The\n  parameter t varies between 0 and 1, a and d are points on the curve,\n  and b and c are the control points. This can be done once with the x\n  coordinates and a second time with the y coordinates to get the\n  location of a bezier curve at t."}, stroke-cap-modes {:name quil.core$macros/stroke-cap-modes, :file nil, :line 45, :column 1, :end-line 64, :end-column 18, :meta {:file quil.core, :line 64, :column 2, :end-line 64, :end-column 18}}, quad {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "2D Primitives", :file quil.core, :end-column 7, :processing-name "quad()", :column 3, :requires-bindings true, :line 3102, :end-line 3102, :arglists (quote ([x1 y1 x2 y2 x3 y3 x4 y4])), :doc "A quad is a quadrilateral, a four sided polygon. It is similar to a\n  rectangle, but the angles between its edges are not constrained to\n  be ninety degrees. The first pair of parameters (x1,y1) sets the\n  first vertex and the subsequent pairs should proceed clockwise or\n  counter-clockwise around the defined shape."}, :added "1.0", :name quil.core$macros/quad, :variadic false, :subcategory "2D Primitives", :file nil, :end-column 7, :processing-name "quad()", :method-params ([x1 y1 x2 y2 x3 y3 x4 y4]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3096, :end-line 3102, :max-fixed-arity 8, :fn-var true, :arglists (quote ([x1 y1 x2 y2 x3 y3 x4 y4])), :doc "A quad is a quadrilateral, a four sided polygon. It is similar to a\n  rectangle, but the angles between its edges are not constrained to\n  be ninety degrees. The first pair of parameters (x1,y1) sets the\n  first vertex and the subsequent pairs should proceed clockwise or\n  counter-clockwise around the defined shape."}, screen-x {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Coordinates", :file quil.core, :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([x y] [x y z]), :arglists ([x y] [x y z]), :arglists-meta (nil nil)}, :processing-name "screenX()", :column 3, :requires-bindings true, :line 3595, :end-line 3595, :arglists (quote ([x y] [x y z])), :doc "Takes a three-dimensional x, y, z position and returns the x value\n  for where it will appear on a (two-dimensional) screen, once\n  affected by translate, scale or any other transformations"}, :added "1.0", :name quil.core$macros/screen-x, :variadic false, :subcategory "Coordinates", :file nil, :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([x y] [x y z]), :arglists ([x y] [x y z]), :arglists-meta (nil nil)}, :processing-name "screenX()", :method-params ([x y] [x y z]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3589, :end-line 3595, :max-fixed-arity 3, :fn-var true, :arglists ([x y] [x y z]), :doc "Takes a three-dimensional x, y, z position and returns the x value\n  for where it will appear on a (two-dimensional) screen, once\n  affected by translate, scale or any other transformations"}, lights {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Lights", :file quil.core, :end-column 9, :processing-name "lights()", :column 3, :requires-bindings true, :line 2263, :end-line 2263, :arglists (quote ([])), :doc "Sets the default ambient light, directional light, falloff, and\n  specular values. The defaults are:\n\n  (ambient-light 128 128 128)\n  (directional-light 128 128 128 0 0 -1)\n  (light-falloff 1 0 0)\n  (light-specular 0 0 0).\n\n  Lights need to be included in the draw to remain persistent in a\n  looping program. Placing them in the setup of a looping program\n  will cause them to only have an effect the first time through the\n  loop."}, :added "1.0", :name quil.core$macros/lights, :variadic false, :subcategory "Lights", :file nil, :end-column 9, :processing-name "lights()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2257, :end-line 2263, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Sets the default ambient light, directional light, falloff, and\n  specular values. The defaults are:\n\n  (ambient-light 128 128 128)\n  (directional-light 128 128 128 0 0 -1)\n  (light-falloff 1 0 0)\n  (light-specular 0 0 0).\n\n  Lights need to be included in the draw to remain persistent in a\n  looping program. Placing them in the setup of a looping program\n  will cause them to only have an effect the first time through the\n  loop."}, *graphics* {:meta {:file quil.core, :line 22, :column 3, :end-line 22, :end-column 13, :private true, :dynamic true}, :private true, :name quil.core$macros/*graphics*, :file nil, :end-column 13, :column 1, :dynamic true, :line 20, :end-line 22}, KEY-CODES {:name quil.core$macros/KEY-CODES, :file nil, :line 122, :column 4, :end-line 123, :end-column 15, :private true, :meta {:file quil.core, :line 123, :column 6, :end-line 123, :end-column 15, :private true}}, curve-detail {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "Curves", :file quil.core, :end-column 15, :processing-name "curveDetail()", :column 3, :requires-bindings true, :line 1348, :end-line 1348, :arglists (quote ([detail])), :doc "Sets the resolution at which curves display. The default value is\n  20. This function is only useful when using the :p3d or :opengl\n  renderer as the default (:java2d) renderer does not use this\n  information."}, :added "1.0", :name quil.core$macros/curve-detail, :variadic false, :subcategory "Curves", :file nil, :end-column 15, :processing-name "curveDetail()", :method-params ([detail]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1342, :end-line 1348, :max-fixed-arity 1, :fn-var true, :arglists (quote ([detail])), :doc "Sets the resolution at which curves display. The default value is\n  20. This function is only useful when using the :p3d or :opengl\n  renderer as the default (:java2d) renderer does not use this\n  information."}, current-frame-rate {:category "Environment", :protocol-inline nil, :meta {:category "Environment", :added "1.0", :subcategory nil, :file quil.core, :end-column 21, :processing-name "frameRate", :column 3, :requires-bindings true, :line 1847, :end-line 1847, :arglists (quote ([])), :doc "Returns the current framerate"}, :added "1.0", :name quil.core$macros/current-frame-rate, :variadic false, :subcategory nil, :file nil, :end-column 21, :processing-name "frameRate", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1841, :end-line 1847, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Returns the current framerate"}, end-contour {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "2.0", :subcategory "Vertex", :file quil.core, :end-column 14, :processing-name "endContour()", :column 3, :requires-bindings true, :line 1605, :end-line 1605, :arglists (quote ([])), :doc "Use the begin-contour and end-contour function to create negative\n  shapes within shapes. These functions can only be within a\n  begin-shape/end-shape pair and they only work with the :p2d and :p3d\n  renderers."}, :added "2.0", :name quil.core$macros/end-contour, :variadic false, :subcategory "Vertex", :file nil, :end-column 14, :processing-name "endContour()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1599, :end-line 1605, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Use the begin-contour and end-contour function to create negative\n  shapes within shapes. These functions can only be within a\n  begin-shape/end-shape pair and they only work with the :p2d and :p3d\n  renderers."}, sin {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Trigonometry", :file quil.core, :end-column 6, :processing-name "sin()", :column 3, :requires-bindings false, :line 3816, :end-line 3816, :arglists (quote ([angle])), :doc "Calculates the sine of an angle. This function expects the values\n  of the angle parameter to be provided in radians (values from 0 to\n  6.28). A float within the range -1 to 1 is returned."}, :added "1.0", :name quil.core$macros/sin, :variadic false, :subcategory "Trigonometry", :file nil, :end-column 6, :processing-name "sin()", :method-params ([angle]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings false, :line 3810, :end-line 3816, :max-fixed-arity 1, :fn-var true, :arglists (quote ([angle])), :doc "Calculates the sine of an angle. This function expects the values\n  of the angle parameter to be provided in radians (values from 0 to\n  6.28). A float within the range -1 to 1 is returned."}, current-stroke {:category "Color", :protocol-inline nil, :meta {:category "Color", :subcategory "Creating & Reading", :file quil.core, :end-column 17, :processing-name "PGraphics.strokeColor", :column 3, :processing-link "http://processing.github.io/processing-javadocs/core/processing/core/PGraphics.html#strokeColor", :requires-bindings true, :line 1275, :end-line 1275, :arglists (quote ([])), :doc "Return the current stroke color."}, :name quil.core$macros/current-stroke, :variadic false, :subcategory "Creating & Reading", :file nil, :end-column 17, :processing-name "PGraphics.strokeColor", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :processing-link "http://processing.github.io/processing-javadocs/core/processing/core/PGraphics.html#strokeColor", :requires-bindings true, :line 1269, :end-line 1275, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Return the current stroke color."}, curve {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "Curves", :file quil.core, :end-column 8, :top-fn {:variadic false, :max-fixed-arity 12, :method-params ([x1 y1 x2 y2 x3 y3 x4 y4] [x1 y1 z1 x2 y2 z2 x3 y3 z3 x4 y4 z4]), :arglists ([x1 y1 x2 y2 x3 y3 x4 y4] [x1 y1 z1 x2 y2 z2 x3 y3 z3 x4 y4 z4]), :arglists-meta (nil nil)}, :processing-name "curve()", :column 3, :requires-bindings true, :line 1320, :end-line 1320, :arglists (quote ([x1 y1 x2 y2 x3 y3 x4 y4] [x1 y1 z1 x2 y2 z2 x3 y3 z3 x4 y4 z4])), :doc "Draws a curved line on the screen. The first and second parameters\n  specify the beginning control point and the last two parameters\n  specify the ending control point. The middle parameters specify the\n  start and stop of the curve. Longer curves can be created by putting\n  a series of curve fns together or using curve-vertex. An additional\n  fn called curve-tightness provides control for the visual quality of\n  the curve. The curve fn is an implementation of Catmull-Rom\n  splines."}, :added "1.0", :name quil.core$macros/curve, :variadic false, :subcategory "Curves", :file nil, :end-column 8, :top-fn {:variadic false, :max-fixed-arity 12, :method-params ([x1 y1 x2 y2 x3 y3 x4 y4] [x1 y1 z1 x2 y2 z2 x3 y3 z3 x4 y4 z4]), :arglists ([x1 y1 x2 y2 x3 y3 x4 y4] [x1 y1 z1 x2 y2 z2 x3 y3 z3 x4 y4 z4]), :arglists-meta (nil nil)}, :processing-name "curve()", :method-params ([x1 y1 x2 y2 x3 y3 x4 y4] [x1 y1 z1 x2 y2 z2 x3 y3 z3 x4 y4 z4]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1314, :end-line 1320, :max-fixed-arity 12, :fn-var true, :arglists ([x1 y1 x2 y2 x3 y3 x4 y4] [x1 y1 z1 x2 y2 z2 x3 y3 z3 x4 y4 z4]), :doc "Draws a curved line on the screen. The first and second parameters\n  specify the beginning control point and the last two parameters\n  specify the ending control point. The middle parameters specify the\n  start and stop of the curve. Longer curves can be created by putting\n  a series of curve fns together or using curve-vertex. An additional\n  fn called curve-tightness provides control for the visual quality of\n  the curve. The curve fn is an implementation of Catmull-Rom\n  splines."}, shape {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "Loading & Displaying", :file quil.core, :end-column 8, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([sh] [sh x y] [sh x y width height]), :arglists ([sh] [sh x y] [sh x y width height]), :arglists-meta (nil nil nil)}, :processing-name "shape()", :column 3, :requires-bindings true, :line 3704, :end-line 3704, :arglists (quote ([sh] [sh x y] [sh x y width height])), :doc "Displays shapes to the screen. The shapes must have been loaded\n  with load-shape. Processing currently works with SVG shapes\n  only. The sh parameter specifies the shape to display and the x and\n  y parameters define the location of the shape from its upper-left\n  corner. The shape is displayed at its original size unless the width\n  and height parameters specify a different size. The shape-mode\n  fn changes the way the parameters work. A call to\n  (shape-mode :corners), for example, will change the width and height\n  parameters to define the x and y values of the opposite corner of\n  the shape.\n\n  Note complex shapes may draw awkwardly with the renderers :p2d, :p3d, and\n  :opengl. Those renderers do not yet support shapes that have holes\n  or complicated breaks."}, :added "1.0", :name quil.core$macros/shape, :variadic false, :subcategory "Loading & Displaying", :file nil, :end-column 8, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([sh] [sh x y] [sh x y width height]), :arglists ([sh] [sh x y] [sh x y width height]), :arglists-meta (nil nil nil)}, :processing-name "shape()", :method-params ([sh] [sh x y] [sh x y width height]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :requires-bindings true, :line 3698, :end-line 3704, :max-fixed-arity 5, :fn-var true, :arglists ([sh] [sh x y] [sh x y width height]), :doc "Displays shapes to the screen. The shapes must have been loaded\n  with load-shape. Processing currently works with SVG shapes\n  only. The sh parameter specifies the shape to display and the x and\n  y parameters define the location of the shape from its upper-left\n  corner. The shape is displayed at its original size unless the width\n  and height parameters specify a different size. The shape-mode\n  fn changes the way the parameters work. A call to\n  (shape-mode :corners), for example, will change the width and height\n  parameters to define the x and y values of the opposite corner of\n  the shape.\n\n  Note complex shapes may draw awkwardly with the renderers :p2d, :p3d, and\n  :opengl. Those renderers do not yet support shapes that have holes\n  or complicated breaks."}, image-formats {:name quil.core$macros/image-formats, :file nil, :line 45, :column 1, :end-line 51, :end-column 15, :meta {:file quil.core, :line 51, :column 2, :end-line 51, :end-column 15}}, text-descent {:category "Typography", :protocol-inline nil, :meta {:category "Typography", :added "1.0", :subcategory "Metrics", :file quil.core, :end-column 15, :processing-name "textDescent()", :column 3, :requires-bindings true, :line 4208, :end-line 4208, :arglists (quote ([])), :doc "Returns descent of the current font at its current size. This\n  information is useful for determining the height of the font below\n  the baseline. For example, adding the text-ascent and text-descent\n  values will give you the total height of the line."}, :added "1.0", :name quil.core$macros/text-descent, :variadic false, :subcategory "Metrics", :file nil, :end-column 15, :processing-name "textDescent()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 4202, :end-line 4208, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Returns descent of the current font at its current size. This\n  information is useful for determining the height of the font below\n  the baseline. For example, adding the text-ascent and text-descent\n  values will give you the total height of the line."}, screen-z {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Coordinates", :file quil.core, :end-column 11, :processing-name "screenZ()", :column 3, :requires-bindings true, :line 3621, :end-line 3621, :arglists (quote ([x y z])), :doc "Given an x, y, z coordinate, returns its z value.\n   This value can be used to determine if an x, y, z coordinate is in\n   front or in back of another (x, y, z) coordinate. The units are\n   based on how the zbuffer is set up, and don't relate to anything\n   'real'. They're only useful for in comparison to another value\n   obtained from screen-z, or directly out of the zbuffer"}, :added "1.0", :name quil.core$macros/screen-z, :variadic false, :subcategory "Coordinates", :file nil, :end-column 11, :processing-name "screenZ()", :method-params ([x y z]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3615, :end-line 3621, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x y z])), :doc "Given an x, y, z coordinate, returns its z value.\n   This value can be used to determine if an x, y, z coordinate is in\n   front or in back of another (x, y, z) coordinate. The units are\n   based on how the zbuffer is set up, and don't relate to anything\n   'real'. They're only useful for in comparison to another value\n   obtained from screen-z, or directly out of the zbuffer"}, ambient-int {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Material Properties", :file quil.core, :end-column 14, :processing-name "ambient()", :column 3, :requires-bindings true, :line 341, :end-line 341, :arglists (quote ([rgb])), :doc "Sets the ambient reflectance for shapes drawn to the screen. This\n  is combined with the ambient light component of environment. The rgb\n  color components set define the reflectance. Used in combination\n  with emissive, specular, and shininess in setting the material\n  properties of shapes."}, :added "1.0", :name quil.core$macros/ambient-int, :variadic false, :subcategory "Material Properties", :file nil, :end-column 14, :processing-name "ambient()", :method-params ([rgb]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 335, :end-line 341, :max-fixed-arity 1, :fn-var true, :arglists (quote ([rgb])), :doc "Sets the ambient reflectance for shapes drawn to the screen. This\n  is combined with the ambient light component of environment. The rgb\n  color components set define the reflectance. Used in combination\n  with emissive, specular, and shininess in setting the material\n  properties of shapes."}, ellipse {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "2D Primitives", :file quil.core, :end-column 10, :processing-name "ellipse()", :column 3, :requires-bindings true, :line 1512, :end-line 1512, :arglists (quote ([x y width height])), :doc "Draws an ellipse (oval) in the display window. An ellipse with an\n  equal width and height is a circle.  The origin may be changed with\n  the ellipse-mode function"}, :added "1.0", :name quil.core$macros/ellipse, :variadic false, :subcategory "2D Primitives", :file nil, :end-column 10, :processing-name "ellipse()", :method-params ([x y width height]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1506, :end-line 1512, :max-fixed-arity 4, :fn-var true, :arglists (quote ([x y width height])), :doc "Draws an ellipse (oval) in the display window. An ellipse with an\n  equal width and height is a circle.  The origin may be changed with\n  the ellipse-mode function"}, text-leading {:category "Typography", :protocol-inline nil, :meta {:category "Typography", :added "1.0", :subcategory "Attributes", :file quil.core, :end-column 15, :processing-name "textLeading()", :column 3, :requires-bindings true, :line 4248, :end-line 4248, :arglists (quote ([leading])), :doc "Sets the spacing between lines of text in units of pixels. This\n  setting will be used in all subsequent calls to the text function."}, :added "1.0", :name quil.core$macros/text-leading, :variadic false, :subcategory "Attributes", :file nil, :end-column 15, :processing-name "textLeading()", :method-params ([leading]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 4242, :end-line 4248, :max-fixed-arity 1, :fn-var true, :arglists (quote ([leading])), :doc "Sets the spacing between lines of text in units of pixels. This\n  setting will be used in all subsequent calls to the text function."}, image-filter {:category "Image", :protocol-inline nil, :meta {:category "Image", :added "2.0", :subcategory "Pixels", :file quil.core, :end-column 15, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([img mode] [img mode level]), :arglists ([img mode] [img mode level]), :arglists-meta (nil nil)}, :processing-name "PImage.filter()", :column 3, :requires-bindings true, :line 2085, :end-line 2085, :arglists (quote ([img mode] [img mode level])), :doc "Originally named filter in Processing Language.\n  Filters given image with the specified mode and level.\n  Level defines the quality of the filter and mode may be one of\n  the following keywords:\n\n  :threshold - converts the image to black and white pixels depending\n               if they are above or below the threshold defined by\n               the level parameter. The level must be between\n               0.0 (black) and 1.0 (white). If no level is specified,\n               0.5 is used.\n  :gray      - converts any colors in the image to grayscale\n               equivalents. Doesn't work with level.\n  :invert    - sets each pixel to its inverse value. Doesn't work with\n               level.\n  :posterize - limits each channel of the image to the number of\n               colors specified as the level parameter. The parameter can\n               be set to values between 2 and 255, but results are most\n               noticeable in the lower ranges.\n  :blur      - executes a Guassian blur with the level parameter\n               specifying the extent of the blurring. If no level\n               parameter is used, the blur is equivalent to Guassian\n               blur of radius 1.\n  :opaque    - sets the alpha channel to entirely opaque. Doesn't work\n               with level.\n  :erode     - reduces the light areas. Doesn't work with level.\n  :dilate    - increases the light areas.  Doesn't work with level."}, :added "2.0", :name quil.core$macros/image-filter, :variadic false, :subcategory "Pixels", :file nil, :end-column 15, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([img mode] [img mode level]), :arglists ([img mode] [img mode level]), :arglists-meta (nil nil)}, :processing-name "PImage.filter()", :method-params ([img mode] [img mode level]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2079, :end-line 2085, :max-fixed-arity 3, :fn-var true, :arglists ([img mode] [img mode level]), :doc "Originally named filter in Processing Language.\n  Filters given image with the specified mode and level.\n  Level defines the quality of the filter and mode may be one of\n  the following keywords:\n\n  :threshold - converts the image to black and white pixels depending\n               if they are above or below the threshold defined by\n               the level parameter. The level must be between\n               0.0 (black) and 1.0 (white). If no level is specified,\n               0.5 is used.\n  :gray      - converts any colors in the image to grayscale\n               equivalents. Doesn't work with level.\n  :invert    - sets each pixel to its inverse value. Doesn't work with\n               level.\n  :posterize - limits each channel of the image to the number of\n               colors specified as the level parameter. The parameter can\n               be set to values between 2 and 255, but results are most\n               noticeable in the lower ranges.\n  :blur      - executes a Guassian blur with the level parameter\n               specifying the extent of the blurring. If no level\n               parameter is used, the blur is equivalent to Guassian\n               blur of radius 1.\n  :opaque    - sets the alpha channel to entirely opaque. Doesn't work\n               with level.\n  :erode     - reduces the light areas. Doesn't work with level.\n  :dilate    - increases the light areas.  Doesn't work with level."}, random {:category "Math", :protocol-inline nil, :meta {:category "Math", :added "1.0", :subcategory "Random", :file quil.core, :end-column 9, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([max] [min max]), :arglists ([max] [min max]), :arglists-meta (nil nil)}, :processing-name "random()", :column 3, :requires-bindings true, :line 3160, :end-line 3160, :arglists (quote ([max] [min max])), :doc "Generates random numbers. Each time the random function is called,\n  it returns an unexpected value within the specified range. If one\n  parameter is passed to the function it will return a float between\n  zero and the value of the high parameter. The function call (random\n  5) returns values between 0 and 5 (starting at zero, up to but not\n  including 5). If two parameters are passed, it will return a float\n  with a value between the parameters. The function call\n  (random -5 10.2) returns values starting at -5 up to (but not\n  including) 10.2."}, :added "1.0", :name quil.core$macros/random, :variadic false, :subcategory "Random", :file nil, :end-column 9, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([max] [min max]), :arglists ([max] [min max]), :arglists-meta (nil nil)}, :processing-name "random()", :method-params ([max] [min max]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3154, :end-line 3160, :max-fixed-arity 2, :fn-var true, :arglists ([max] [min max]), :doc "Generates random numbers. Each time the random function is called,\n  it returns an unexpected value within the specified range. If one\n  parameter is passed to the function it will return a float between\n  zero and the value of the high parameter. The function call (random\n  5) returns values between 0 and 5 (starting at zero, up to but not\n  including 5). If two parameters are passed, it will return a float\n  with a value between the parameters. The function call\n  (random -5 10.2) returns values starting at -5 up to (but not\n  including) 10.2."}, texture-mode {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "Vertex", :file quil.core, :end-column 15, :processing-name "textureMode()", :column 3, :requires-bindings true, :line 4320, :end-line 4320, :arglists (quote ([mode])), :doc "Sets the coordinate space for texture mapping. There are two\n  options, :image and :normal.\n\n  :image refers to the actual coordinates of the image and :normal\n  refers to a normalized space of values ranging from 0 to 1. The\n  default mode is :image. In :image, if an image is 100 x 200 pixels,\n  mapping the image onto the entire size of a quad would require the\n  points (0,0) (0,100) (100,200) (0,200). The same mapping in\n  NORMAL_SPACE is (0,0) (0,1) (1,1) (0,1)."}, :added "1.0", :name quil.core$macros/texture-mode, :variadic false, :subcategory "Vertex", :file nil, :end-column 15, :processing-name "textureMode()", :method-params ([mode]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 4314, :end-line 4320, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mode])), :doc "Sets the coordinate space for texture mapping. There are two\n  options, :image and :normal.\n\n  :image refers to the actual coordinates of the image and :normal\n  refers to a normalized space of values ranging from 0 to 1. The\n  default mode is :image. In :image, if an image is 100 x 200 pixels,\n  mapping the image onto the entire size of a quad would require the\n  points (0,0) (0,100) (100,200) (0,200). The same mapping in\n  NORMAL_SPACE is (0,0) (0,1) (1,1) (0,1)."}, redraw {:category "Structure", :protocol-inline nil, :meta {:category "Structure", :added "1.0", :subcategory nil, :file quil.core, :end-column 9, :processing-name "redraw()", :column 3, :requires-bindings true, :line 3297, :end-line 3297, :arglists (quote ([])), :doc "Executes the code within the draw fn one time. This functions\n  allows the program to update the display window only when necessary,\n  for example when an event registered by mouse-pressed or\n  key-pressed occurs.\n\n  In structuring a program, it only makes sense to call redraw\n  within events such as mouse-pressed. This is because redraw does\n  not run draw immediately (it only sets a flag that indicates an\n  update is needed).\n\n  Calling redraw within draw has no effect because draw is\n  continuously called anyway."}, :added "1.0", :name quil.core$macros/redraw, :variadic false, :subcategory nil, :file nil, :end-column 9, :processing-name "redraw()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3291, :end-line 3297, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Executes the code within the draw fn one time. This functions\n  allows the program to update the display window only when necessary,\n  for example when an event registered by mouse-pressed or\n  key-pressed occurs.\n\n  In structuring a program, it only makes sense to call redraw\n  within events such as mouse-pressed. This is because redraw does\n  not run draw immediately (it only sets a flag that indicates an\n  update is needed).\n\n  Calling redraw within draw has no effect because draw is\n  continuously called anyway."}, RAD-TO-DEG {:name quil.core$macros/RAD-TO-DEG, :file nil, :line 83, :column 1, :end-line 83, :end-column 16, :meta {:file quil.core, :line 83, :column 6, :end-line 83, :end-column 16}}, get-pixel {:category "Image", :protocol-inline nil, :meta {:category "Image", :added "1.0", :subcategory "Pixels", :file quil.core, :end-column 12, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([] [img] [x y] [img x y] [x y w h] [img x y w h]), :arglists ([] [img] [x y] [img x y] [x y w h] [img x y w h]), :arglists-meta (nil nil nil nil nil nil)}, :processing-name "get()", :column 3, :requires-bindings true, :line 1891, :end-line 1891, :arglists (quote ([] [img] [x y] [img x y] [x y w h] [img x y w h])), :doc "Reads the color of any pixel or grabs a section of an image. If no\n  parameters are specified, a copy of entire image is returned. Get the\n  value of one pixel by specifying an x,y coordinate. Get a section of\n  the image by specifying an additional width and height parameter.\n  If the pixel requested is outside of the image window, black is returned.\n  The numbers returned are scaled according to the current color ranges,\n  but only RGB values are returned by this function. For example, even though\n  you may have drawn a shape with (color-mode :hsb), the numbers returned\n  will be in RGB.\n\n  Getting the color of a single pixel with (get x y) is easy, but not\n  as fast as grabbing the data directly using the pixels fn.\n\n  If no img specified - current-graphics is used."}, :added "1.0", :name quil.core$macros/get-pixel, :variadic false, :subcategory "Pixels", :file nil, :end-column 12, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([] [img] [x y] [img x y] [x y w h] [img x y w h]), :arglists ([] [img] [x y] [img x y] [x y w h] [img x y w h]), :arglists-meta (nil nil nil nil nil nil)}, :processing-name "get()", :method-params ([] [img] [x y] [img x y] [x y w h] [img x y w h]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil nil), :column 1, :requires-bindings true, :line 1885, :end-line 1891, :max-fixed-arity 5, :fn-var true, :arglists ([] [img] [x y] [img x y] [x y w h] [img x y w h]), :doc "Reads the color of any pixel or grabs a section of an image. If no\n  parameters are specified, a copy of entire image is returned. Get the\n  value of one pixel by specifying an x,y coordinate. Get a section of\n  the image by specifying an additional width and height parameter.\n  If the pixel requested is outside of the image window, black is returned.\n  The numbers returned are scaled according to the current color ranges,\n  but only RGB values are returned by this function. For example, even though\n  you may have drawn a shape with (color-mode :hsb), the numbers returned\n  will be in RGB.\n\n  Getting the color of a single pixel with (get x y) is easy, but not\n  as fast as grabbing the data directly using the pixels fn.\n\n  If no img specified - current-graphics is used."}, rotate {:category "Transform", :protocol-inline nil, :meta {:category "Transform", :added "1.0", :subcategory nil, :file quil.core, :end-column 9, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([angle] [angle vx vy vz]), :arglists ([angle] [angle vx vy vz]), :arglists-meta (nil nil)}, :processing-name "rotate()", :column 3, :requires-bindings true, :line 3391, :end-line 3391, :arglists (quote ([angle] [angle vx vy vz])), :doc "Rotates a shape the amount specified by the angle parameter. Angles\n  should be specified in radians (values from 0 to TWO-PI) or\n  converted to radians with the radians function.\n\n  Objects are always rotated around their relative position to the\n  origin and positive numbers rotate objects in a clockwise\n  direction. Transformations apply to everything that happens after\n  and subsequent calls to the function accumulates the effect. For\n  example, calling (rotate HALF-PI) and then (rotate HALF-PI) is the\n  same as (rotate PI). All tranformations are reset when draw begins\n  again.\n\n  Technically, rotate multiplies the current transformation matrix by\n  a rotation matrix. This function can be further controlled by the\n  push-matrix and pop-matrix."}, :added "1.0", :name quil.core$macros/rotate, :variadic false, :subcategory nil, :file nil, :end-column 9, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([angle] [angle vx vy vz]), :arglists ([angle] [angle vx vy vz]), :arglists-meta (nil nil)}, :processing-name "rotate()", :method-params ([angle] [angle vx vy vz]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3385, :end-line 3391, :max-fixed-arity 4, :fn-var true, :arglists ([angle] [angle vx vy vz]), :doc "Rotates a shape the amount specified by the angle parameter. Angles\n  should be specified in radians (values from 0 to TWO-PI) or\n  converted to radians with the radians function.\n\n  Objects are always rotated around their relative position to the\n  origin and positive numbers rotate objects in a clockwise\n  direction. Transformations apply to everything that happens after\n  and subsequent calls to the function accumulates the effect. For\n  example, calling (rotate HALF-PI) and then (rotate HALF-PI) is the\n  same as (rotate PI). All tranformations are reset when draw begins\n  again.\n\n  Technically, rotate multiplies the current transformation matrix by\n  a rotation matrix. This function can be further controlled by the\n  push-matrix and pop-matrix."}, set-pixel {:category "Image", :protocol-inline nil, :meta {:category "Image", :added "1.0", :subcategory "Pixels", :file quil.core, :end-column 12, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([x y c] [img x y c]), :arglists ([x y c] [img x y c]), :arglists-meta (nil nil)}, :processing-name "set()", :column 3, :requires-bindings true, :line 3649, :end-line 3649, :arglists (quote ([x y c] [img x y c])), :doc "Changes the color of any pixel in the display window. The x and y\n  parameters specify the pixel to change and the color parameter\n  specifies the color value. The color parameter is affected by the\n  current color mode (the default is RGB values from 0 to 255).\n\n  Setting the color of a single pixel with (set x, y) is easy, but not\n  as fast as putting the data directly into pixels[].\n\n  This function ignores imageMode().\n\n  Due to what appears to be a bug in Apple's Java implementation, the\n  point() and set() methods are extremely slow in some circumstances\n  when used with the default renderer. Using :p2d or :p3d will fix the\n  problem. Grouping many calls to point or set-pixel together can also\n  help. (Bug 1094)"}, :added "1.0", :name quil.core$macros/set-pixel, :variadic false, :subcategory "Pixels", :file nil, :end-column 12, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([x y c] [img x y c]), :arglists ([x y c] [img x y c]), :arglists-meta (nil nil)}, :processing-name "set()", :method-params ([x y c] [img x y c]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3643, :end-line 3649, :max-fixed-arity 4, :fn-var true, :arglists ([x y c] [img x y c]), :doc "Changes the color of any pixel in the display window. The x and y\n  parameters specify the pixel to change and the color parameter\n  specifies the color value. The color parameter is affected by the\n  current color mode (the default is RGB values from 0 to 255).\n\n  Setting the color of a single pixel with (set x, y) is easy, but not\n  as fast as putting the data directly into pixels[].\n\n  This function ignores imageMode().\n\n  Due to what appears to be a bug in Apple's Java implementation, the\n  point() and set() methods are extremely slow in some circumstances\n  when used with the default renderer. Using :p2d or :p3d will fix the\n  problem. Grouping many calls to point or set-pixel together can also\n  help. (Bug 1094)"}, push-matrix {:category "Transform", :protocol-inline nil, :meta {:category "Transform", :added "1.0", :subcategory nil, :file quil.core, :end-column 14, :processing-name "pushMatrix()", :column 3, :requires-bindings true, :line 3061, :end-line 3061, :arglists (quote ([])), :doc "Pushes the current transformation matrix onto the matrix\n  stack. Understanding push-matrix and pop-matrix requires\n  understanding the concept of a matrix stack. The push-matrix\n  function saves the current coordinate system to the stack and\n  pop-matrix restores the prior coordinate system. push-matrix and\n  pop-matrix are used in conjuction with the other transformation\n  methods and may be embedded to control the scope of the\n  transformations."}, :added "1.0", :name quil.core$macros/push-matrix, :variadic false, :subcategory nil, :file nil, :end-column 14, :processing-name "pushMatrix()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3055, :end-line 3061, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Pushes the current transformation matrix onto the matrix\n  stack. Understanding push-matrix and pop-matrix requires\n  understanding the concept of a matrix stack. The push-matrix\n  function saves the current coordinate system to the stack and\n  pop-matrix restores the prior coordinate system. push-matrix and\n  pop-matrix are used in conjuction with the other transformation\n  methods and may be embedded to control the scope of the\n  transformations."}, no-smooth {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "Attributes", :file quil.core, :end-column 12, :processing-name "noSmooth()", :column 3, :requires-bindings true, :line 2804, :end-line 2804, :arglists (quote ([])), :doc "Draws all geometry with jagged (aliased) edges. Must be called inside\n  :settings handler."}, :added "1.0", :name quil.core$macros/no-smooth, :variadic false, :subcategory "Attributes", :file nil, :end-column 12, :processing-name "noSmooth()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2798, :end-line 2804, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Draws all geometry with jagged (aliased) edges. Must be called inside\n  :settings handler."}, alpha {:category "Color", :protocol-inline nil, :meta {:category "Color", :added "1.0", :subcategory "Creating & Reading", :file quil.core, :end-column 8, :processing-name "alpha()", :column 3, :requires-bindings true, :line 313, :end-line 313, :arglists (quote ([color])), :doc "Extracts the alpha value from a color."}, :added "1.0", :name quil.core$macros/alpha, :variadic false, :subcategory "Creating & Reading", :file nil, :end-column 8, :processing-name "alpha()", :method-params ([color]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 307, :end-line 313, :max-fixed-arity 1, :fn-var true, :arglists (quote ([color])), :doc "Extracts the alpha value from a color."}, camera {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Camera", :file quil.core, :end-column 9, :top-fn {:variadic false, :max-fixed-arity 9, :method-params ([] [eyeX eyeY eyeZ centerX centerY centerZ upX upY upZ]), :arglists ([] [eyeX eyeY eyeZ centerX centerY centerZ upX upY upZ]), :arglists-meta (nil nil)}, :processing-name "camera()", :column 3, :requires-bindings true, :line 939, :end-line 939, :arglists (quote ([] [eyeX eyeY eyeZ centerX centerY centerZ upX upY upZ])), :doc "Sets the position of the camera through setting the eye position,\n  the center of the scene, and which axis is facing upward. Moving the\n  eye position and the direction it is pointing (the center of the\n  scene) allows the images to be seen from different angles. The\n  version without any parameters sets the camera to the default\n  position, pointing to the center of the display window with the Y\n  axis as up. The default values are:\n\n  eyeX:     (/ (width) 2.0)\n  eyeY:     (/ (height) 2.0)\n  eyeZ:     (/ (/ (height) 2.0) (tan (/ (* Math/PI 60.0) 360.0)))\n  centerX:  (/ (width) 2.0)\n  centerY:  (/ (height) 2.0)\n  centerZ:  0\n  upX:      0\n  upY:      1\n  upZ:      0\n\n  Similar imilar to gluLookAt() in OpenGL, but it first clears the\n  current camera settings."}, :added "1.0", :name quil.core$macros/camera, :variadic false, :subcategory "Camera", :file nil, :end-column 9, :top-fn {:variadic false, :max-fixed-arity 9, :method-params ([] [eyeX eyeY eyeZ centerX centerY centerZ upX upY upZ]), :arglists ([] [eyeX eyeY eyeZ centerX centerY centerZ upX upY upZ]), :arglists-meta (nil nil)}, :processing-name "camera()", :method-params ([] [eyeX eyeY eyeZ centerX centerY centerZ upX upY upZ]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 933, :end-line 939, :max-fixed-arity 9, :fn-var true, :arglists ([] [eyeX eyeY eyeZ centerX centerY centerZ upX upY upZ]), :doc "Sets the position of the camera through setting the eye position,\n  the center of the scene, and which axis is facing upward. Moving the\n  eye position and the direction it is pointing (the center of the\n  scene) allows the images to be seen from different angles. The\n  version without any parameters sets the camera to the default\n  position, pointing to the center of the display window with the Y\n  axis as up. The default values are:\n\n  eyeX:     (/ (width) 2.0)\n  eyeY:     (/ (height) 2.0)\n  eyeZ:     (/ (/ (height) 2.0) (tan (/ (* Math/PI 60.0) 360.0)))\n  centerX:  (/ (width) 2.0)\n  centerY:  (/ (height) 2.0)\n  centerZ:  0\n  upX:      0\n  upY:      1\n  upZ:      0\n\n  Similar imilar to gluLookAt() in OpenGL, but it first clears the\n  current camera settings."}, translate {:category "Transform", :protocol-inline nil, :meta {:category "Transform", :added "1.0", :subcategory nil, :file quil.core, :end-column 12, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([v] [tx ty] [tx ty tz]), :arglists ([v] [tx ty] [tx ty tz]), :arglists-meta (nil nil nil)}, :processing-name "translate()", :column 3, :requires-bindings true, :line 4441, :end-line 4441, :arglists (quote ([v] [tx ty] [tx ty tz])), :doc "Specifies an amount to displace objects within the display\n  window. The x parameter specifies left/right translation, the y\n  parameter specifies up/down translation, and the z parameter\n  specifies translations toward/away from the screen.  Transformations\n  apply to everything that happens after and subsequent calls to the\n  function accumulates the effect. For example, calling (translate 50\n  0) and then (translate 20, 0) is the same as (translate 70, 0). If\n  translate is called within draw, the transformation is reset when\n  the loop begins again. This function can be further controlled by\n  the push-matrix and pop-matrix."}, :added "1.0", :name quil.core$macros/translate, :variadic false, :subcategory nil, :file nil, :end-column 12, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([v] [tx ty] [tx ty tz]), :arglists ([v] [tx ty] [tx ty tz]), :arglists-meta (nil nil nil)}, :processing-name "translate()", :method-params ([v] [tx ty] [tx ty tz]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :requires-bindings true, :line 4435, :end-line 4441, :max-fixed-arity 3, :fn-var true, :arglists ([v] [tx ty] [tx ty tz]), :doc "Specifies an amount to displace objects within the display\n  window. The x parameter specifies left/right translation, the y\n  parameter specifies up/down translation, and the z parameter\n  specifies translations toward/away from the screen.  Transformations\n  apply to everything that happens after and subsequent calls to the\n  function accumulates the effect. For example, calling (translate 50\n  0) and then (translate 20, 0) is the same as (translate 70, 0). If\n  translate is called within draw, the transformation is reset when\n  the loop begins again. This function can be further controlled by\n  the push-matrix and pop-matrix."}, load-font {:category "Typography", :protocol-inline nil, :meta {:category "Typography", :added "1.0", :subcategory "Loading & Displaying", :file quil.core, :end-column 12, :processing-name "loadFont()", :column 3, :requires-bindings true, :line 2322, :end-line 2322, :arglists (quote ([filename])), :doc "Loads a font into a variable of type PFont. To load correctly,\n  fonts must be located in the data directory of the current sketch.\n  To create a font to use with Processing use the create-font fn.\n\n  Like load-image and other methods that load data, the load-font fn\n  should not be used inside draw, because it will slow down the sketch\n  considerably, as the font will be re-loaded from the disk (or\n  network) on each frame.\n\n  For most renderers, Processing displays fonts using the .vlw font\n  format, which uses images for each letter, rather than defining them\n  through vector data. When hint :enable-native-fonts is used with the\n  JAVA2D renderer, the native version of a font will be used if it is\n  installed on the user's machine.\n\n  Using create-font (instead of load-font) enables vector data to be\n  used with the JAVA2D (default) renderer setting. This can be helpful\n  when many font sizes are needed, or when using any renderer based on\n  JAVA2D, such as the PDF library."}, :added "1.0", :name quil.core$macros/load-font, :variadic false, :subcategory "Loading & Displaying", :file nil, :end-column 12, :processing-name "loadFont()", :method-params ([filename]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2316, :end-line 2322, :max-fixed-arity 1, :fn-var true, :arglists (quote ([filename])), :doc "Loads a font into a variable of type PFont. To load correctly,\n  fonts must be located in the data directory of the current sketch.\n  To create a font to use with Processing use the create-font fn.\n\n  Like load-image and other methods that load data, the load-font fn\n  should not be used inside draw, because it will slow down the sketch\n  considerably, as the font will be re-loaded from the disk (or\n  network) on each frame.\n\n  For most renderers, Processing displays fonts using the .vlw font\n  format, which uses images for each letter, rather than defining them\n  through vector data. When hint :enable-native-fonts is used with the\n  JAVA2D renderer, the native version of a font will be used if it is\n  installed on the user's machine.\n\n  Using create-font (instead of load-font) enables vector data to be\n  used with the JAVA2D (default) renderer setting. This can be helpful\n  when many font sizes are needed, or when using any renderer based on\n  JAVA2D, such as the PDF library."}, ambient {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Material Properties", :file quil.core, :end-column 10, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([rgb] [x y z]), :arglists ([rgb] [x y z]), :arglists-meta (nil nil)}, :processing-name "ambient()", :column 3, :requires-bindings true, :line 356, :end-line 356, :arglists (quote ([rgb] [x y z])), :doc "Sets the ambient reflectance for shapes drawn to the screen. This\n  is combined with the ambient light component of environment. The\n  color components set through the parameters define the\n  reflectance. For example in the default color mode, setting x=255,\n  y=126, z=0, would cause all the red light to reflect and half of the\n  green light to reflect. Used in combination with emissive, specular,\n  and shininess in setting the material properties of shapes."}, :added "1.0", :name quil.core$macros/ambient, :variadic false, :subcategory "Material Properties", :file nil, :end-column 10, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([rgb] [x y z]), :arglists ([rgb] [x y z]), :arglists-meta (nil nil)}, :processing-name "ambient()", :method-params ([rgb] [x y z]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 350, :end-line 356, :max-fixed-arity 3, :fn-var true, :arglists ([rgb] [x y z]), :doc "Sets the ambient reflectance for shapes drawn to the screen. This\n  is combined with the ambient light component of environment. The\n  color components set through the parameters define the\n  reflectance. For example in the default color mode, setting x=255,\n  y=126, z=0, would cause all the red light to reflect and half of the\n  green light to reflect. Used in combination with emissive, specular,\n  and shininess in setting the material properties of shapes."}, shear-y {:category "Transform", :protocol-inline nil, :meta {:category "Transform", :added "1.0", :subcategory nil, :file quil.core, :end-column 10, :processing-name "shearY()", :column 3, :requires-bindings true, :line 3754, :end-line 3754, :arglists (quote ([angle])), :doc "Shears a shape around the y-axis the amount specified by the angle\n  parameter. Angles should be specified in radians (values from 0 to\n  PI*2) or converted to radians with the radians() function. Objects\n  are always sheared around their relative position to the origin and\n  positive numbers shear objects in a clockwise direction.\n  Transformations apply to everything that happens after and\n  subsequent calls to the function accumulates the effect. For\n  example, calling (shear-y (/ PI 2)) and then (shear-y (/ PI 2)) is\n  the same as (shear-y PI). If shear-y is called within the draw fn,\n  the transformation is reset when the loop begins again. This\n  function works in P2D or JAVA2D mode.\n\n  Technically, shear-y multiplies the current transformation matrix\n  by a rotation matrix. This function can be further controlled by the\n  push-matrix and pop-matrix fns."}, :added "1.0", :name quil.core$macros/shear-y, :variadic false, :subcategory nil, :file nil, :end-column 10, :processing-name "shearY()", :method-params ([angle]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 3748, :end-line 3754, :max-fixed-arity 1, :fn-var true, :arglists (quote ([angle])), :doc "Shears a shape around the y-axis the amount specified by the angle\n  parameter. Angles should be specified in radians (values from 0 to\n  PI*2) or converted to radians with the radians() function. Objects\n  are always sheared around their relative position to the origin and\n  positive numbers shear objects in a clockwise direction.\n  Transformations apply to everything that happens after and\n  subsequent calls to the function accumulates the effect. For\n  example, calling (shear-y (/ PI 2)) and then (shear-y (/ PI 2)) is\n  the same as (shear-y PI). If shear-y is called within the draw fn,\n  the transformation is reset when the loop begins again. This\n  function works in P2D or JAVA2D mode.\n\n  Technically, shear-y multiplies the current transformation matrix\n  by a rotation matrix. This function can be further controlled by the\n  push-matrix and pop-matrix fns."}, cursor-modes {:name quil.core$macros/cursor-modes, :file nil, :line 45, :column 1, :end-line 72, :end-column 14, :meta {:file quil.core, :line 72, :column 2, :end-line 72, :end-column 14}}, mouse-y {:category "Input", :protocol-inline nil, :meta {:category "Input", :added "1.0", :subcategory "Mouse", :file quil.core, :end-column 10, :processing-name "mouseY", :column 3, :requires-bindings true, :line 2608, :end-line 2608, :arglists (quote ([])), :doc "Current vertical coordinate of the mouse."}, :added "1.0", :name quil.core$macros/mouse-y, :variadic false, :subcategory "Mouse", :file nil, :end-column 10, :processing-name "mouseY", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2602, :end-line 2608, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Current vertical coordinate of the mouse."}, mouse-button {:category "Input", :protocol-inline nil, :meta {:category "Input", :added "1.0", :subcategory "Mouse", :file quil.core, :end-column 15, :processing-name "mouseButton", :column 3, :requires-bindings true, :line 2559, :end-line 2559, :arglists (quote ([])), :doc "The value of the system variable mouseButton is either :left, :right,\n  or :center depending on which button is pressed. nil if no button pressed"}, :added "1.0", :name quil.core$macros/mouse-button, :variadic false, :subcategory "Mouse", :file nil, :end-column 15, :processing-name "mouseButton", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2553, :end-line 2559, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "The value of the system variable mouseButton is either :left, :right,\n  or :center depending on which button is pressed. nil if no button pressed"}, p-shape-modes {:name quil.core$macros/p-shape-modes, :file nil, :line 45, :column 1, :end-line 63, :end-column 15, :meta {:file quil.core, :line 63, :column 2, :end-line 63, :end-column 15}}, image {:category "Image", :protocol-inline nil, :meta {:category "Image", :added "1.0", :subcategory "Loading & Displaying", :file quil.core, :end-column 8, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([img x y] [img x y c d]), :arglists ([img x y] [img x y c d]), :arglists-meta (nil nil)}, :processing-name "image()", :column 3, :requires-bindings true, :line 2056, :end-line 2056, :arglists (quote ([img x y] [img x y c d])), :doc "Displays images to the screen. Processing currently works with GIF,\n  JPEG, and Targa images. The color of an image may be modified with\n  the tint function and if a GIF has transparency, it will maintain\n  its transparency. The img parameter specifies the image to display\n  and the x and y parameters define the location of the image from its\n  upper-left corner. The image is displayed at its original size\n  unless the width and height parameters specify a different size. The\n  image-mode fn changes the way the parameters work. A call to\n  (image-mode :corners) will change the width and height parameters to\n  define the x and y values of the opposite corner of the image.\n\n  Starting with release 0124, when using the default (JAVA2D)\n  renderer, smooth will also improve image quality of resized\n  images."}, :added "1.0", :name quil.core$macros/image, :variadic false, :subcategory "Loading & Displaying", :file nil, :end-column 8, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([img x y] [img x y c d]), :arglists ([img x y] [img x y c d]), :arglists-meta (nil nil)}, :processing-name "image()", :method-params ([img x y] [img x y c d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2050, :end-line 2056, :max-fixed-arity 5, :fn-var true, :arglists ([img x y] [img x y c d]), :doc "Displays images to the screen. Processing currently works with GIF,\n  JPEG, and Targa images. The color of an image may be modified with\n  the tint function and if a GIF has transparency, it will maintain\n  its transparency. The img parameter specifies the image to display\n  and the x and y parameters define the location of the image from its\n  upper-left corner. The image is displayed at its original size\n  unless the width and height parameters specify a different size. The\n  image-mode fn changes the way the parameters work. A call to\n  (image-mode :corners) will change the width and height parameters to\n  define the x and y values of the opposite corner of the image.\n\n  Starting with release 0124, when using the default (JAVA2D)\n  renderer, smooth will also improve image quality of resized\n  images."}, unbinary {:category "Data", :protocol-inline nil, :meta {:category "Data", :require-binding false, :added "1.0", :subcategory "Conversion", :file quil.core, :end-column 11, :processing-name "unbinary()", :column 3, :line 4479, :end-line 4479, :arglists (quote ([str-val])), :doc "Unpack a binary string to an integer. See binary for converting\n  integers to strings."}, :require-binding false, :added "1.0", :name quil.core$macros/unbinary, :variadic false, :subcategory "Conversion", :file nil, :end-column 11, :processing-name "unbinary()", :method-params ([str-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4473, :end-line 4479, :max-fixed-arity 1, :fn-var true, :arglists (quote ([str-val])), :doc "Unpack a binary string to an integer. See binary for converting\n  integers to strings."}, no-tint {:category "Image", :protocol-inline nil, :meta {:category "Image", :added "1.0", :subcategory "Loading & Displaying", :file quil.core, :end-column 10, :processing-name "noTint()", :column 3, :requires-bindings true, :line 2827, :end-line 2827, :arglists (quote ([])), :doc "Removes the current fill value for displaying images and reverts to\n  displaying images with their original hues."}, :added "1.0", :name quil.core$macros/no-tint, :variadic false, :subcategory "Loading & Displaying", :file nil, :end-column 10, :processing-name "noTint()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2821, :end-line 2827, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Removes the current fill value for displaying images and reverts to\n  displaying images with their original hues."}, no-lights {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Lights", :file quil.core, :end-column 12, :processing-name "noLights()", :column 3, :requires-bindings true, :line 2736, :end-line 2736, :arglists (quote ([])), :doc "Disable all lighting. Lighting is turned off by default and enabled\n  with the lights fn. This function can be used to disable lighting so\n  that 2D geometry (which does not require lighting) can be drawn\n  after a set of lighted 3D geometry."}, :added "1.0", :name quil.core$macros/no-lights, :variadic false, :subcategory "Lights", :file nil, :end-column 12, :processing-name "noLights()", :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2730, :end-line 2736, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Disable all lighting. Lighting is turned off by default and enabled\n  with the lights fn. This function can be used to disable lighting so\n  that 2D geometry (which does not require lighting) can be drawn\n  after a set of lighted 3D geometry."}, emissive-int {:category "Lights, Camera", :protocol-inline nil, :meta {:category "Lights, Camera", :added "1.0", :subcategory "Material Properties", :file quil.core, :end-column 15, :processing-name "emissive()", :column 3, :requires-bindings true, :line 1561, :end-line 1561, :arglists (quote ([int-val])), :doc "Sets the emissive color of the material used for drawing shapes\n  drawn to the screen. Used in combination with ambient, specular, and\n  shininess in setting the material properties of shapes. Converts all\n  args to ints"}, :added "1.0", :name quil.core$macros/emissive-int, :variadic false, :subcategory "Material Properties", :file nil, :end-column 15, :processing-name "emissive()", :method-params ([int-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 1555, :end-line 1561, :max-fixed-arity 1, :fn-var true, :arglists (quote ([int-val])), :doc "Sets the emissive color of the material used for drawing shapes\n  drawn to the screen. Used in combination with ambient, specular, and\n  shininess in setting the material properties of shapes. Converts all\n  args to ints"}, point {:category "Shape", :protocol-inline nil, :meta {:category "Shape", :added "1.0", :subcategory "2D Primitives", :file quil.core, :end-column 8, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([x y] [x y z]), :arglists ([x y] [x y z]), :arglists-meta (nil nil)}, :processing-name "point()", :column 3, :requires-bindings true, :line 2946, :end-line 2946, :arglists (quote ([x y] [x y z])), :doc "Draws a point, a coordinate in space at the dimension of one\n  pixel. The first parameter is the horizontal value for the point,\n  the second value is the vertical value for the point, and the\n  optional third value is the depth value. Drawing this shape in 3D\n  using the z parameter requires the :P3D or :opengl renderer to be\n  used."}, :added "1.0", :name quil.core$macros/point, :variadic false, :subcategory "2D Primitives", :file nil, :end-column 8, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([x y] [x y z]), :arglists ([x y] [x y z]), :arglists-meta (nil nil)}, :processing-name "point()", :method-params ([x y] [x y z]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :requires-bindings true, :line 2940, :end-line 2946, :max-fixed-arity 3, :fn-var true, :arglists ([x y] [x y z]), :doc "Draws a point, a coordinate in space at the dimension of one\n  pixel. The first parameter is the horizontal value for the point,\n  the second value is the vertical value for the point, and the\n  optional third value is the depth value. Drawing this shape in 3D\n  using the z parameter requires the :P3D or :opengl renderer to be\n  used."}}, :require-macros {ap quil.sketch, quil.sketch quil.sketch, u quil.util, quil.util quil.util}, :cljs.analyzer/constants {:seen #{:shift .endDraw :open :baseline :disable-stroke-perspective :hsb :quads :arrow :dilate quil.core/current-fill try quil.core/*graphics* :quad-strip :down :disable-depth-mask :burn :posterize quil.sketch/with-sketch :f8 quil.core/translate :screen :enable-depth-test :gray :enable-depth-sort :f1 :corner :disable-texture-mipmaps :darkest :f10 :dodge :bottom :bevel :disable-stroke-pure :replace :alt :top :disable-depth-test finally :pie quil.core/pop-matrix :enable-stroke-perspective let :chord :rgb :lines :argb :move :f5 :command quil.core/stroke tr__13__auto__ :miter :points :hand :close :radius :normal :threshold :up :center :round :disable-optimized-stroke :corners :f11 :opaque :overlay :enable-opengl-errors :enable-stroke-pure :blur :project :triangle-fan :f3 :enable-depth-mask :f2 :control :difference quil.core/push-matrix :square :enable-optimized-stroke :p2d tr__14__auto__ :shape :f12 :exclusion quil.core/fill :disable-opengl-errors :unknown-key :alpha :wait :right quil.core/current-stroke :repeat :hard-light quil.sketch$macros/defsketch :image :multiply binding :lightest quil.core/rotate :f7 :blend :disable-depth-sort :f9 :erode :add :soft-light :subtract :clamp apply :f6 :f4 :triangle-strip old-fill__11__auto__ :cross old-stroke__12__auto__ :triangles .beginDraw :left :invert :text :enable-texture-mipmaps :model}, :order [:open :chord :pie :arrow :cross :hand :move :text :wait :points :lines :triangles :triangle-fan :triangle-strip :quads :quad-strip :burn :screen :darkest :dodge :replace :overlay :difference :exclusion :hard-light :multiply :lightest :blend :add :soft-light :subtract :rgb :hsb :argb :alpha :center :radius :corner :corners :disable-stroke-perspective :disable-depth-mask :enable-depth-test :enable-depth-sort :disable-texture-mipmaps :disable-stroke-pure :disable-depth-test :enable-stroke-perspective :disable-optimized-stroke :enable-opengl-errors :enable-stroke-pure :enable-depth-mask :enable-optimized-stroke :disable-opengl-errors :disable-depth-sort :enable-texture-mipmaps :square :round :project :model :miter :bevel :left :right :top :bottom :baseline :shape :image :normal :clamp :repeat :threshold :gray :invert :posterize :blur :opaque :erode :dilate :up :down :shift :f1 :control :f2 :alt :f3 :f4 :f5 :f6 :f7 :f8 :f9 :f10 :f11 :f12 :command quil.sketch/with-sketch :p2d :close let old-fill__11__auto__ quil.core/current-fill apply quil.core/fill old-stroke__12__auto__ quil.core/current-stroke quil.core/stroke tr__13__auto__ quil.core/push-matrix try quil.core/translate finally quil.core/pop-matrix tr__14__auto__ quil.core/rotate binding quil.core/*graphics* .beginDraw .endDraw quil.sketch$macros/defsketch :unknown-key]}, :doc nil}, :source "goog.provide(\"quil.core$macros\");\nquil.core$macros._STAR_graphics_STAR_ = null;\nquil.core$macros.no_fill_prop = \"no-fill-quil\";\n/**\n * Graphics currently used for drawing. By default it is sketch graphics,\n *   but if called inside with-graphics macro - graphics passed to the macro\n *   is returned. This method should be used if you need to call some methods\n *   that are not implemented by quil. Example:\n *   (.beginDraw (current-graphics)).\n */\nquil.core$macros.current_graphics = (function quil$core$macros$current_graphics(){\nvar or__2423__auto__ = quil.core$macros._STAR_graphics_STAR_;\nif(cljs.core.truth_(or__2423__auto__)){\nreturn or__2423__auto__;\n} else {\nreturn quil.sketch.current_applet.call(null);\n}\n});\nquil.core$macros.arc_modes = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"open\",\"open\",(-1763596448)),(Processing.prototype.PConstants[\"OPEN\"]),new cljs.core.Keyword(null,\"chord\",\"chord\",(-696248342)),(Processing.prototype.PConstants[\"CHORD\"]),new cljs.core.Keyword(null,\"pie\",\"pie\",(1530441672)),(Processing.prototype.PConstants[\"PIE\"])], null);\n\nquil.core$macros.shape_modes = new cljs.core.PersistentArrayMap(null, 7, [new cljs.core.Keyword(null,\"points\",\"points\",(-1486596883)),(Processing.prototype.PConstants[\"POINTS\"]),new cljs.core.Keyword(null,\"lines\",\"lines\",(-700165781)),(Processing.prototype.PConstants[\"LINES\"]),new cljs.core.Keyword(null,\"triangles\",\"triangles\",(-1525417058)),(Processing.prototype.PConstants[\"TRIANGLES\"]),new cljs.core.Keyword(null,\"triangle-fan\",\"triangle-fan\",(1743150739)),(Processing.prototype.PConstants[\"TRIANGLE_FAN\"]),new cljs.core.Keyword(null,\"triangle-strip\",\"triangle-strip\",(221845500)),(Processing.prototype.PConstants[\"TRIANGLE_STRIP\"]),new cljs.core.Keyword(null,\"quads\",\"quads\",(1347497505)),(Processing.prototype.PConstants[\"QUADS\"]),new cljs.core.Keyword(null,\"quad-strip\",\"quad-strip\",(-1297270686)),(Processing.prototype.PConstants[\"QUAD_STRIP\"])], null);\n\nquil.core$macros.blend_modes = cljs.core.PersistentHashMap.fromArrays([new cljs.core.Keyword(null,\"burn\",\"burn\",(-458179293)),new cljs.core.Keyword(null,\"screen\",\"screen\",(1990059748)),new cljs.core.Keyword(null,\"darkest\",\"darkest\",(68197253)),new cljs.core.Keyword(null,\"dodge\",\"dodge\",(-1556666427)),new cljs.core.Keyword(null,\"replace\",\"replace\",(-786587770)),new cljs.core.Keyword(null,\"overlay\",\"overlay\",(-139131598)),new cljs.core.Keyword(null,\"difference\",\"difference\",(1916101396)),new cljs.core.Keyword(null,\"exclusion\",\"exclusion\",(531897910)),new cljs.core.Keyword(null,\"hard-light\",\"hard-light\",(-37591145)),new cljs.core.Keyword(null,\"multiply\",\"multiply\",(-1036907048)),new cljs.core.Keyword(null,\"lightest\",\"lightest\",(-2043115912)),new cljs.core.Keyword(null,\"blend\",\"blend\",(249565561)),new cljs.core.Keyword(null,\"add\",\"add\",(235287739)),new cljs.core.Keyword(null,\"soft-light\",\"soft-light\",(513207899)),new cljs.core.Keyword(null,\"subtract\",\"subtract\",(2136988635))],[(Processing.prototype.PConstants[\"BURN\"]),(Processing.prototype.PConstants[\"SCREEN\"]),(Processing.prototype.PConstants[\"DARKEST\"]),(Processing.prototype.PConstants[\"DODGE\"]),(Processing.prototype.PConstants[\"REPLACE\"]),(Processing.prototype.PConstants[\"OVERLAY\"]),(Processing.prototype.PConstants[\"DIFFERENCE\"]),(Processing.prototype.PConstants[\"EXCLUSION\"]),(Processing.prototype.PConstants[\"HARD_LIGHT\"]),(Processing.prototype.PConstants[\"MULTIPLY\"]),(Processing.prototype.PConstants[\"LIGHTEST\"]),(Processing.prototype.PConstants[\"BLEND\"]),(Processing.prototype.PConstants[\"ADD\"]),(Processing.prototype.PConstants[\"SOFT_LIGHT\"]),(Processing.prototype.PConstants[\"SUBTRACT\"])]);\n\nquil.core$macros.color_modes = new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"rgb\",\"rgb\",(1432123467)),(Processing.prototype.PConstants[\"RGB\"]),new cljs.core.Keyword(null,\"hsb\",\"hsb\",(-753472031)),(Processing.prototype.PConstants[\"HSB\"])], null);\n\nquil.core$macros.image_formats = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"rgb\",\"rgb\",(1432123467)),(Processing.prototype.PConstants[\"RGB\"]),new cljs.core.Keyword(null,\"argb\",\"argb\",(633844107)),(Processing.prototype.PConstants[\"ARGB\"]),new cljs.core.Keyword(null,\"alpha\",\"alpha\",(-1574982441)),(Processing.prototype.PConstants[\"ALPHA\"])], null);\n\nquil.core$macros.ellipse_modes = new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"center\",\"center\",(-748944368)),(Processing.prototype.PConstants[\"CENTER\"]),new cljs.core.Keyword(null,\"radius\",\"radius\",(-2073122258)),(Processing.prototype.PConstants[\"RADIUS\"]),new cljs.core.Keyword(null,\"corner\",\"corner\",(1296717125)),(Processing.prototype.PConstants[\"CORNER\"]),new cljs.core.Keyword(null,\"corners\",\"corners\",(-137817903)),(Processing.prototype.PConstants[\"CORNERS\"])], null);\n\nquil.core$macros.hint_options = cljs.core.PersistentHashMap.fromArrays([new cljs.core.Keyword(null,\"disable-stroke-perspective\",\"disable-stroke-perspective\",(479198433)),new cljs.core.Keyword(null,\"disable-depth-mask\",\"disable-depth-mask\",(3298562)),new cljs.core.Keyword(null,\"enable-depth-test\",\"enable-depth-test\",(1519326084)),new cljs.core.Keyword(null,\"enable-depth-sort\",\"enable-depth-sort\",(-383089627)),new cljs.core.Keyword(null,\"disable-texture-mipmaps\",\"disable-texture-mipmaps\",(1697917541)),new cljs.core.Keyword(null,\"disable-stroke-pure\",\"disable-stroke-pure\",(735493926)),new cljs.core.Keyword(null,\"disable-depth-test\",\"disable-depth-test\",(284606407)),new cljs.core.Keyword(null,\"enable-stroke-perspective\",\"enable-stroke-perspective\",(-259923319)),new cljs.core.Keyword(null,\"disable-optimized-stroke\",\"disable-optimized-stroke\",(74038544)),new cljs.core.Keyword(null,\"enable-opengl-errors\",\"enable-opengl-errors\",(89998962)),new cljs.core.Keyword(null,\"enable-stroke-pure\",\"enable-stroke-pure\",(881345587)),new cljs.core.Keyword(null,\"enable-depth-mask\",\"enable-depth-mask\",(872785875)),new cljs.core.Keyword(null,\"enable-optimized-stroke\",\"enable-optimized-stroke\",(1537575253)),new cljs.core.Keyword(null,\"disable-opengl-errors\",\"disable-opengl-errors\",(506822839)),new cljs.core.Keyword(null,\"disable-depth-sort\",\"disable-depth-sort\",(-1568352839)),new cljs.core.Keyword(null,\"enable-texture-mipmaps\",\"enable-texture-mipmaps\",(1241892671))],[(Processing.prototype.PConstants[\"DISABLE_STROKE_PERSPECTIVE\"]),(Processing.prototype.PConstants[\"DISABLE_DEPTH_MASK\"]),(Processing.prototype.PConstants[\"ENABLE_DEPTH_TEST\"]),(Processing.prototype.PConstants[\"ENABLE_DEPTH_SORT\"]),(Processing.prototype.PConstants[\"DISABLE_TEXTURE_MIPMAPS\"]),(Processing.prototype.PConstants[\"DISABLE_STROKE_PURE\"]),(Processing.prototype.PConstants[\"DISABLE_DEPTH_TEST\"]),(Processing.prototype.PConstants[\"ENABLE_STROKE_PERSPECTIVE\"]),(Processing.prototype.PConstants[\"DISABLE_OPTIMIZED_STROKE\"]),(Processing.prototype.PConstants[\"ENABLE_OPENGL_ERRORS\"]),(Processing.prototype.PConstants[\"ENABLE_STROKE_PURE\"]),(Processing.prototype.PConstants[\"ENABLE_DEPTH_MASK\"]),(Processing.prototype.PConstants[\"ENABLE_OPTIMIZED_STROKE\"]),(Processing.prototype.PConstants[\"DISABLE_OPENGL_ERRORS\"]),(Processing.prototype.PConstants[\"DISABLE_DEPTH_SORT\"]),(Processing.prototype.PConstants[\"ENABLE_TEXTURE_MIPMAPS\"])]);\n\nquil.core$macros.image_modes = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"corner\",\"corner\",(1296717125)),(Processing.prototype.PConstants[\"CORNER\"]),new cljs.core.Keyword(null,\"corners\",\"corners\",(-137817903)),(Processing.prototype.PConstants[\"CORNERS\"]),new cljs.core.Keyword(null,\"center\",\"center\",(-748944368)),(Processing.prototype.PConstants[\"CENTER\"])], null);\n\nquil.core$macros.rect_modes = new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"corner\",\"corner\",(1296717125)),(Processing.prototype.PConstants[\"CORNER\"]),new cljs.core.Keyword(null,\"corners\",\"corners\",(-137817903)),(Processing.prototype.PConstants[\"CORNERS\"]),new cljs.core.Keyword(null,\"center\",\"center\",(-748944368)),(Processing.prototype.PConstants[\"CENTER\"]),new cljs.core.Keyword(null,\"radius\",\"radius\",(-2073122258)),(Processing.prototype.PConstants[\"RADIUS\"])], null);\n\nquil.core$macros.p_shape_modes = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"corner\",\"corner\",(1296717125)),(Processing.prototype.PConstants[\"CORNER\"]),new cljs.core.Keyword(null,\"corners\",\"corners\",(-137817903)),(Processing.prototype.PConstants[\"CORNERS\"]),new cljs.core.Keyword(null,\"center\",\"center\",(-748944368)),(Processing.prototype.PConstants[\"CENTER\"])], null);\n\nquil.core$macros.stroke_cap_modes = new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"square\",\"square\",(812434677)),(Processing.prototype.PConstants[\"SQUARE\"]),new cljs.core.Keyword(null,\"round\",\"round\",(2009433328)),(Processing.prototype.PConstants[\"ROUND\"]),new cljs.core.Keyword(null,\"project\",\"project\",(1124394579)),(Processing.prototype.PConstants[\"PROJECT\"]),new cljs.core.Keyword(null,\"model\",\"model\",(331153215)),(Processing.prototype.PConstants[\"MODEL\"])], null);\n\nquil.core$macros.stroke_join_modes = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"miter\",\"miter\",(327727052)),(Processing.prototype.PConstants[\"MITER\"]),new cljs.core.Keyword(null,\"bevel\",\"bevel\",(2090515654)),(Processing.prototype.PConstants[\"BEVEL\"]),new cljs.core.Keyword(null,\"round\",\"round\",(2009433328)),(Processing.prototype.PConstants[\"ROUND\"])], null);\n\nquil.core$macros.horizontal_alignment_modes = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"left\",\"left\",(-399115937)),(Processing.prototype.PConstants[\"LEFT\"]),new cljs.core.Keyword(null,\"center\",\"center\",(-748944368)),(Processing.prototype.PConstants[\"CENTER\"]),new cljs.core.Keyword(null,\"right\",\"right\",(-452581833)),(Processing.prototype.PConstants[\"RIGHT\"])], null);\n\nquil.core$macros.vertical_alignment_modes = new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"top\",\"top\",(-1856271961)),(Processing.prototype.PConstants[\"TOP\"]),new cljs.core.Keyword(null,\"bottom\",\"bottom\",(-1550509018)),(Processing.prototype.PConstants[\"BOTTOM\"]),new cljs.core.Keyword(null,\"center\",\"center\",(-748944368)),(Processing.prototype.PConstants[\"CENTER\"]),new cljs.core.Keyword(null,\"baseline\",\"baseline\",(1151033280)),(Processing.prototype.PConstants[\"BASELINE\"])], null);\n\nquil.core$macros.text_modes = new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"model\",\"model\",(331153215)),(Processing.prototype.PConstants[\"MODEL\"]),new cljs.core.Keyword(null,\"shape\",\"shape\",(1190694006)),(Processing.prototype.PConstants[\"SHAPE\"])], null);\n\nquil.core$macros.texture_modes = new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"image\",\"image\",(-58725096)),(Processing.prototype.PConstants[\"IMAGE\"]),new cljs.core.Keyword(null,\"normal\",\"normal\",(-1519123858)),(Processing.prototype.PConstants[\"NORMAL\"])], null);\n\nquil.core$macros.texture_wrap_modes = new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"clamp\",\"clamp\",(1803814940)),(Processing.prototype.PConstants[\"CLAMP\"]),new cljs.core.Keyword(null,\"repeat\",\"repeat\",(832692087)),(Processing.prototype.PConstants[\"REPEAT\"])], null);\n\nquil.core$macros.filter_modes = new cljs.core.PersistentArrayMap(null, 8, [new cljs.core.Keyword(null,\"threshold\",\"threshold\",(204221583)),(Processing.prototype.PConstants[\"THRESHOLD\"]),new cljs.core.Keyword(null,\"gray\",\"gray\",(1013268388)),(Processing.prototype.PConstants[\"GRAY\"]),new cljs.core.Keyword(null,\"invert\",\"invert\",(1553577503)),(Processing.prototype.PConstants[\"INVERT\"]),new cljs.core.Keyword(null,\"posterize\",\"posterize\",(-148251901)),(Processing.prototype.PConstants[\"POSTERIZE\"]),new cljs.core.Keyword(null,\"blur\",\"blur\",(-453500461)),(Processing.prototype.PConstants[\"BLUR\"]),new cljs.core.Keyword(null,\"opaque\",\"opaque\",(-1243552654)),(Processing.prototype.PConstants[\"OPAQUE\"]),new cljs.core.Keyword(null,\"erode\",\"erode\",(1539530618)),(Processing.prototype.PConstants[\"ERODE\"]),new cljs.core.Keyword(null,\"dilate\",\"dilate\",(1504745153)),(Processing.prototype.PConstants[\"DILATE\"])], null);\n\nquil.core$macros.cursor_modes = new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\"arrow\",\"arrow\",(1071351425)),(Processing.prototype.PConstants[\"ARROW\"]),new cljs.core.Keyword(null,\"cross\",\"cross\",(194557789)),(Processing.prototype.PConstants[\"CROSS\"]),new cljs.core.Keyword(null,\"hand\",\"hand\",(791601933)),(Processing.prototype.PConstants[\"HAND\"]),new cljs.core.Keyword(null,\"move\",\"move\",(-2110884309)),(Processing.prototype.PConstants[\"MOVE\"]),new cljs.core.Keyword(null,\"text\",\"text\",(-1790561697)),(Processing.prototype.PConstants[\"TEXT\"]),new cljs.core.Keyword(null,\"wait\",\"wait\",(-260664777)),(Processing.prototype.PConstants[\"WAIT\"])], null);\nquil.core$macros.PI = Math.PI;\nquil.core$macros.HALF_PI = (quil.core$macros.PI / (2));\nquil.core$macros.THIRD_PI = (quil.core$macros.PI / (3));\nquil.core$macros.QUARTER_PI = (quil.core$macros.PI / (4));\nquil.core$macros.TWO_PI = (quil.core$macros.PI * (2));\nquil.core$macros.DEG_TO_RAD = (quil.core$macros.PI / (180));\nquil.core$macros.RAD_TO_DEG = ((180) / quil.core$macros.PI);\nquil.core$macros.KEY_CODES = cljs.core.PersistentHashMap.fromArrays([(37),(38),(39),(40),(16),(112),(17),(113),(18),(114),(115),(116),(117),(118),(119),(120),(121),(122),(123),(157)],[new cljs.core.Keyword(null,\"left\",\"left\",(-399115937)),new cljs.core.Keyword(null,\"up\",\"up\",(-269712113)),new cljs.core.Keyword(null,\"right\",\"right\",(-452581833)),new cljs.core.Keyword(null,\"down\",\"down\",(1565245570)),new cljs.core.Keyword(null,\"shift\",\"shift\",(997140064)),new cljs.core.Keyword(null,\"f1\",\"f1\",(1714532389)),new cljs.core.Keyword(null,\"control\",\"control\",(1892578036)),new cljs.core.Keyword(null,\"f2\",\"f2\",(396168596)),new cljs.core.Keyword(null,\"alt\",\"alt\",(-3214426)),new cljs.core.Keyword(null,\"f3\",\"f3\",(1954829043)),new cljs.core.Keyword(null,\"f4\",\"f4\",(990968764)),new cljs.core.Keyword(null,\"f5\",\"f5\",(1587057387)),new cljs.core.Keyword(null,\"f6\",\"f6\",(2103080604)),new cljs.core.Keyword(null,\"f7\",\"f7\",(356150168)),new cljs.core.Keyword(null,\"f8\",\"f8\",(-2141475484)),new cljs.core.Keyword(null,\"f9\",\"f9\",(704633338)),new cljs.core.Keyword(null,\"f10\",\"f10\",(627525541)),new cljs.core.Keyword(null,\"f11\",\"f11\",(-1417398799)),new cljs.core.Keyword(null,\"f12\",\"f12\",(853352790)),new cljs.core.Keyword(null,\"command\",\"command\",(-894540724))]);\n/**\n * Writes to the text area of the Processing environment's console.\n *   This is often helpful for looking at the data a program is producing.\n *   Each call to this function creates a new line of output.\n *   Individual elements can be separated with quotes (\"\") and joined with the string concatenation operator (+).\n *   Also writes the content of an array to the text area of the Processing environment.\n *   This is often helpful for looking at the data a program is producing.\n *   A new line is put between each element of the array. This function can only print 1D arrays,\n *   but can test to see if the content are null or not null for 2+ dimensional arrays.\n */\nquil.core$macros.prc_println = (function quil$core$macros$prc_println(msg){\nreturn quil.sketch.current_applet.call(null).println(msg);\n});\n/**\n * Writes to the console area of the Processing environment.\n *   This is often helpful for looking at the data a program is producing.\n *   The companion function println() works like print(), but creates a new line of text for each call to the function.\n * Individual elements can be separated with quotes (\"\") and joined with the addition operator (+). \n */\nquil.core$macros.prc_print = (function quil$core$macros$prc_print(msg){\nreturn quil.sketch.current_applet.call(null).print(msg);\n});\n/**\n * Returns sketch object by id of canvas element of sketch.\n */\nquil.core$macros.get_sketch_by_id = (function quil$core$macros$get_sketch_by_id(id){\nreturn Processing.getInstanceById(id);\n});\nquil.core$macros.with_sketch = (function quil$core$macros$with_sketch(var_args){\nvar args__3281__auto__ = [];\nvar len__3279__auto___95 = arguments.length;\nvar i__3280__auto___96 = (0);\nwhile(true){\nif((i__3280__auto___96 < len__3279__auto___95)){\nargs__3281__auto__.push((arguments[i__3280__auto___96]));\n\nvar G__97 = (i__3280__auto___96 + (1));\ni__3280__auto___96 = G__97;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__3282__auto__ = ((((3) < args__3281__auto__.length))?(new cljs.core.IndexedSeq(args__3281__auto__.slice((3)),(0),null)):null);\nreturn quil.core$macros.with_sketch.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__3282__auto__);\n});\n\nquil.core$macros.with_sketch.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,applet,body){\nif(cljs.core.truth_(quil.util.clj_compilation_QMARK_.call(null))){\nreturn null;\n} else {\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.sketch\",\"with-sketch\",\"quil.sketch/with-sketch\",(-634067708),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,applet),body));\n}\n});\n\nquil.core$macros.with_sketch.cljs$lang$maxFixedArity = (3);\n\nquil.core$macros.with_sketch.cljs$lang$applyTo = (function (seq91){\nvar G__92 = cljs.core.first.call(null,seq91);\nvar seq91__$1 = cljs.core.next.call(null,seq91);\nvar G__93 = cljs.core.first.call(null,seq91__$1);\nvar seq91__$2 = cljs.core.next.call(null,seq91__$1);\nvar G__94 = cljs.core.first.call(null,seq91__$2);\nvar seq91__$3 = cljs.core.next.call(null,seq91__$2);\nreturn quil.core$macros.with_sketch.cljs$core$IFn$_invoke$arity$variadic(G__92,G__93,G__94,seq91__$3);\n});\n\nquil.core$macros.with_sketch.cljs$lang$macro = true;\n/**\n * Retrieve sketch-specific state-atom. All changes to the\n *   atom will be reflected in the state.\n * \n *   (set-state! :foo 1)\n *   (state :foo) ;=> 1\n *   (swap! (state-atom) update-in [:foo] inc)\n *   (state :foo) ;=> 2\n */\nquil.core$macros.state_atom = (function quil$core$macros$state_atom(){\nreturn quil.sketch.current_applet.call(null).quil;\n});\n/**\n * Retrieve sketch-specific state by key. Must initially call\n *   set-state! to store state. If no parameter passed whole\n *   state map is returned.\n * \n *   (set-state! :foo 1)\n *   (state :foo) ;=> 1\n *   (state) ;=> {:foo 1}\n */\nquil.core$macros.state = (function quil$core$macros$state(var_args){\nvar args98 = [];\nvar len__3279__auto___101 = arguments.length;\nvar i__3280__auto___102 = (0);\nwhile(true){\nif((i__3280__auto___102 < len__3279__auto___101)){\nargs98.push((arguments[i__3280__auto___102]));\n\nvar G__103 = (i__3280__auto___102 + (1));\ni__3280__auto___102 = G__103;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__100 = args98.length;\nswitch (G__100) {\ncase (0):\nreturn quil.core$macros.state.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.state.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args98.length)].join('')));\n\n}\n});\n\nquil.core$macros.state.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn cljs.core.deref.call(null,quil.core$macros.state_atom.call(null));\n});\n\nquil.core$macros.state.cljs$core$IFn$_invoke$arity$1 = (function (key){\nvar state = quil.core$macros.state.call(null);\nif(cljs.core.contains_QMARK_.call(null,state,key)){\n} else {\nthrow Error([cljs.core.str(\"Unable to find state with key: \"),cljs.core.str(key)].join(''));\n}\n\nreturn cljs.core.get.call(null,state,key);\n});\n\nquil.core$macros.state.cljs$lang$maxFixedArity = (1);\n/**\n * Set sketch-specific state. May only be called once (ideally in the\n *   setup fn).  Subsequent calls have no effect.\n * \n *   Example:\n *   (set-state! :foo 1 :bar (atom true) :baz (/ (width) 2))\n */\nquil.core$macros.set_state_BANG_ = (function quil$core$macros$set_state_BANG_(var_args){\nvar args__3281__auto__ = [];\nvar len__3279__auto___106 = arguments.length;\nvar i__3280__auto___107 = (0);\nwhile(true){\nif((i__3280__auto___107 < len__3279__auto___106)){\nargs__3281__auto__.push((arguments[i__3280__auto___107]));\n\nvar G__108 = (i__3280__auto___107 + (1));\ni__3280__auto___107 = G__108;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__3282__auto__ = ((((0) < args__3281__auto__.length))?(new cljs.core.IndexedSeq(args__3281__auto__.slice((0)),(0),null)):null);\nreturn quil.core$macros.set_state_BANG_.cljs$core$IFn$_invoke$arity$variadic(argseq__3282__auto__);\n});\n\nquil.core$macros.set_state_BANG_.cljs$core$IFn$_invoke$arity$variadic = (function (state_vals){\nvar state_STAR_ = quil.core$macros.state_atom.call(null);\nif(cljs.core.truth_(cljs.core.deref.call(null,state_STAR_))){\nreturn null;\n} else {\nvar state_map = cljs.core.apply.call(null,cljs.core.hash_map,state_vals);\nreturn cljs.core.reset_BANG_.call(null,state_STAR_,state_map);\n}\n});\n\nquil.core$macros.set_state_BANG_.cljs$lang$maxFixedArity = (0);\n\nquil.core$macros.set_state_BANG_.cljs$lang$applyTo = (function (seq105){\nreturn quil.core$macros.set_state_BANG_.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq.call(null,seq105));\n});\n/**\n * Calculates the absolute value (magnitude) of a number. The\n *   absolute value of a number is always positive. Dynamically casts to\n *   an int or float appropriately\n */\nquil.core$macros.abs = (function quil$core$macros$abs(n){\nreturn quil.sketch.current_applet.call(null).abs(n);\n});\n/**\n * The inverse of cos, returns the arc cosine of a value. This\n *   function expects the values in the range of -1 to 1 and values are\n *   returned in the range 0 to Math/PI (3.1415927).\n */\nquil.core$macros.acos = (function quil$core$macros$acos(n){\nreturn quil.sketch.current_applet.call(null).acos(n);\n});\n/**\n * Extracts the alpha value from a color.\n */\nquil.core$macros.alpha = (function quil$core$macros$alpha(color){\nreturn quil.core$macros.current_graphics.call(null).alpha(cljs.core.unchecked_int.call(null,color));\n});\n/**\n * Sets the ambient reflectance for shapes drawn to the screen. This\n *   is combined with the ambient light component of environment. The\n *   color components set through the parameters define the\n *   reflectance. For example in the default color mode, setting x=255,\n *   y=126, z=0, would cause all the red light to reflect and half of the\n *   green light to reflect. Used in combination with emissive, specular,\n *   and shininess in setting the material properties of shapes.\n */\nquil.core$macros.ambient_float = (function quil$core$macros$ambient_float(var_args){\nvar args109 = [];\nvar len__3279__auto___112 = arguments.length;\nvar i__3280__auto___113 = (0);\nwhile(true){\nif((i__3280__auto___113 < len__3279__auto___112)){\nargs109.push((arguments[i__3280__auto___113]));\n\nvar G__114 = (i__3280__auto___113 + (1));\ni__3280__auto___113 = G__114;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__111 = args109.length;\nswitch (G__111) {\ncase (1):\nreturn quil.core$macros.ambient_float.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.ambient_float.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args109.length)].join('')));\n\n}\n});\n\nquil.core$macros.ambient_float.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nreturn quil.core$macros.current_graphics.call(null).ambient(gray);\n});\n\nquil.core$macros.ambient_float.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.current_graphics.call(null).ambient(x,y,z);\n});\n\nquil.core$macros.ambient_float.cljs$lang$maxFixedArity = (3);\n/**\n * Sets the ambient reflectance for shapes drawn to the screen. This\n *   is combined with the ambient light component of environment. The rgb\n *   color components set define the reflectance. Used in combination\n *   with emissive, specular, and shininess in setting the material\n *   properties of shapes.\n */\nquil.core$macros.ambient_int = (function quil$core$macros$ambient_int(rgb){\nreturn quil.core$macros.current_graphics.call(null).ambient((rgb | (0)));\n});\n/**\n * Sets the ambient reflectance for shapes drawn to the screen. This\n *   is combined with the ambient light component of environment. The\n *   color components set through the parameters define the\n *   reflectance. For example in the default color mode, setting x=255,\n *   y=126, z=0, would cause all the red light to reflect and half of the\n *   green light to reflect. Used in combination with emissive, specular,\n *   and shininess in setting the material properties of shapes.\n */\nquil.core$macros.ambient = (function quil$core$macros$ambient(var_args){\nvar args116 = [];\nvar len__3279__auto___119 = arguments.length;\nvar i__3280__auto___120 = (0);\nwhile(true){\nif((i__3280__auto___120 < len__3279__auto___119)){\nargs116.push((arguments[i__3280__auto___120]));\n\nvar G__121 = (i__3280__auto___120 + (1));\ni__3280__auto___120 = G__121;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__118 = args116.length;\nswitch (G__118) {\ncase (1):\nreturn quil.core$macros.ambient.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.ambient.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args116.length)].join('')));\n\n}\n});\n\nquil.core$macros.ambient.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core$macros.ambient_float.call(null,rgb);\n});\n\nquil.core$macros.ambient.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.ambient_float.call(null,x,y,z);\n});\n\nquil.core$macros.ambient.cljs$lang$maxFixedArity = (3);\n/**\n * Adds an ambient light. Ambient light doesn't come from a specific direction,\n *   the rays have light have bounced around so much that objects are\n *   evenly lit from all sides. Ambient lights are almost always used in\n *   combination with other types of lights. Lights need to be included\n *   in the draw to remain persistent in a looping program. Placing them\n *   in the setup of a looping program will cause them to only have an\n *   effect the first time through the loop. The effect of the\n *   parameters is determined by the current color mode.\n */\nquil.core$macros.ambient_light = (function quil$core$macros$ambient_light(var_args){\nvar args123 = [];\nvar len__3279__auto___126 = arguments.length;\nvar i__3280__auto___127 = (0);\nwhile(true){\nif((i__3280__auto___127 < len__3279__auto___126)){\nargs123.push((arguments[i__3280__auto___127]));\n\nvar G__128 = (i__3280__auto___127 + (1));\ni__3280__auto___127 = G__128;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__125 = args123.length;\nswitch (G__125) {\ncase (3):\nreturn quil.core$macros.ambient_light.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (6):\nreturn quil.core$macros.ambient_light.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args123.length)].join('')));\n\n}\n});\n\nquil.core$macros.ambient_light.cljs$core$IFn$_invoke$arity$3 = (function (red,green,blue){\nreturn quil.core$macros.current_graphics.call(null).ambientLight(red,green,blue);\n});\n\nquil.core$macros.ambient_light.cljs$core$IFn$_invoke$arity$6 = (function (red,green,blue,x,y,z){\nreturn quil.core$macros.current_graphics.call(null).ambientLight(red,green,blue,x,y,z);\n});\n\nquil.core$macros.ambient_light.cljs$lang$maxFixedArity = (6);\n/**\n * Multiplies the current matrix by the one specified through the\n *   parameters. This is very slow because it will try to calculate the\n *   inverse of the transform, so avoid it whenever possible. The\n *   equivalent function in OpenGL is glMultMatrix().\n */\nquil.core$macros.apply_matrix = (function quil$core$macros$apply_matrix(n00,n01,n02,n03,n10,n11,n12,n13,n20,n21,n22,n23,n30,n31,n32,n33){\nreturn quil.core$macros.current_graphics.call(null).applyMatrix(n00,n01,n02,n03,n10,n11,n12,n13,n20,n21,n22,n23,n30,n31,n32,n33);\n});\n/**\n * Draws an arc in the display window. Arcs are drawn along the outer\n *   edge of an ellipse defined by the x, y, width and height\n *   parameters. The origin or the arc's ellipse may be changed with the\n *   ellipse-mode function. The start and stop parameters specify the\n *   angles at which to draw the arc. The mode is either :open, :chord or :pie.\n */\nquil.core$macros.arc = (function quil$core$macros$arc(x,y,width,height,start,stop){\nreturn quil.core$macros.current_graphics.call(null).arc(x,y,width,height,start,stop);\n});\n/**\n * The inverse of sin, returns the arc sine of a value. This function\n *   expects the values in the range of -1 to 1 and values are returned\n *   in the range -PI/2 to PI/2.\n */\nquil.core$macros.asin = (function quil$core$macros$asin(n){\nreturn quil.sketch.current_applet.call(null).asin(n);\n});\n/**\n * The inverse of tan, returns the arc tangent of a value. This\n *   function expects the values in the range of -Infinity to\n *   Infinity (exclusive) and values are returned in the range -PI/2 to\n *   PI/2 .\n */\nquil.core$macros.atan = (function quil$core$macros$atan(n){\nreturn quil.sketch.current_applet.call(null).atan(n);\n});\n/**\n * Calculates the angle (in radians) from a specified point to the\n *   coordinate origin as measured from the positive x-axis. Values are\n *   returned as a float in the range from PI to -PI. The atan2 function\n *   is most often used for orienting geometry to the position of the\n *   cursor. Note: The y-coordinate of the point is the first parameter\n *   and the x-coordinate is the second due to the structure of\n *   calculating the tangent.\n */\nquil.core$macros.atan2 = (function quil$core$macros$atan2(y,x){\nreturn quil.sketch.current_applet.call(null).atan2(y,x);\n});\n/**\n * A sequence of strings representing the fonts on this system\n *   available for use.\n * \n *   Because of limitations in Java, not all fonts can be used and some\n *   might work with one operating system and not others. When sharing a\n *   sketch with other people or posting it on the web, you may need to\n *   include a .ttf or .otf version of your font in the data directory of\n *   the sketch because other people might not have the font installed on\n *   their computer. Only fonts that can legally be distributed should be\n *   included with a sketch.\n */\nquil.core$macros.available_fonts = (function quil$core$macros$available_fonts(){\nreturn cljs.core.seq.call(null,PFont.list());\n});\n/**\n * Sets the color used for the background of the Processing\n *   window. The default background is light gray. In the draw function,\n *   the background color is used to clear the display window at the\n *   beginning of each frame.\n * \n *   It is not possible to use transparency (alpha) in background colors\n *   with the main drawing surface, however they will work properly with\n *   create-graphics. Converts args to floats.\n */\nquil.core$macros.background_float = (function quil$core$macros$background_float(var_args){\nvar args130 = [];\nvar len__3279__auto___133 = arguments.length;\nvar i__3280__auto___134 = (0);\nwhile(true){\nif((i__3280__auto___134 < len__3279__auto___133)){\nargs130.push((arguments[i__3280__auto___134]));\n\nvar G__135 = (i__3280__auto___134 + (1));\ni__3280__auto___134 = G__135;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__132 = args130.length;\nswitch (G__132) {\ncase (1):\nreturn quil.core$macros.background_float.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.background_float.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.background_float.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.background_float.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args130.length)].join('')));\n\n}\n});\n\nquil.core$macros.background_float.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nreturn quil.core$macros.current_graphics.call(null).background(gray);\n});\n\nquil.core$macros.background_float.cljs$core$IFn$_invoke$arity$2 = (function (gray,alpha){\nreturn quil.core$macros.current_graphics.call(null).background(gray,alpha);\n});\n\nquil.core$macros.background_float.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core$macros.current_graphics.call(null).background(r,g,b);\n});\n\nquil.core$macros.background_float.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,a){\nreturn quil.core$macros.current_graphics.call(null).background(r,g,b,a);\n});\n\nquil.core$macros.background_float.cljs$lang$maxFixedArity = (4);\n/**\n * Sets the color used for the background of the Processing\n *   window. The default background is light gray. In the draw function,\n *   the background color is used to clear the display window at the\n *   beginning of each frame.\n * \n *   It is not possible to use transparency (alpha) in background colors\n *   with the main drawing surface, however they will work properly with\n *   create-graphics. Converts rgb to an int and alpha to a float.\n */\nquil.core$macros.background_int = (function quil$core$macros$background_int(var_args){\nvar args137 = [];\nvar len__3279__auto___140 = arguments.length;\nvar i__3280__auto___141 = (0);\nwhile(true){\nif((i__3280__auto___141 < len__3279__auto___140)){\nargs137.push((arguments[i__3280__auto___141]));\n\nvar G__142 = (i__3280__auto___141 + (1));\ni__3280__auto___141 = G__142;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__139 = args137.length;\nswitch (G__139) {\ncase (1):\nreturn quil.core$macros.background_int.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.background_int.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args137.length)].join('')));\n\n}\n});\n\nquil.core$macros.background_int.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core$macros.current_graphics.call(null).background(cljs.core.unchecked_int.call(null,rgb));\n});\n\nquil.core$macros.background_int.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core$macros.current_graphics.call(null).background(cljs.core.unchecked_int.call(null,rgb),alpha);\n});\n\nquil.core$macros.background_int.cljs$lang$maxFixedArity = (2);\n/**\n * Sets the color used for the background of the Processing\n *   window. The default background is light gray. In the draw function,\n *   the background color is used to clear the display window at the\n *   beginning of each frame.\n * \n *   It is not possible to use transparency (alpha) in background colors\n *   with the main drawing surface, however they will work properly with\n *   create-graphics. Converts args to floats.\n */\nquil.core$macros.background = (function quil$core$macros$background(var_args){\nvar args144 = [];\nvar len__3279__auto___147 = arguments.length;\nvar i__3280__auto___148 = (0);\nwhile(true){\nif((i__3280__auto___148 < len__3279__auto___147)){\nargs144.push((arguments[i__3280__auto___148]));\n\nvar G__149 = (i__3280__auto___148 + (1));\ni__3280__auto___148 = G__149;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__146 = args144.length;\nswitch (G__146) {\ncase (1):\nreturn quil.core$macros.background.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.background.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.background.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.background.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args144.length)].join('')));\n\n}\n});\n\nquil.core$macros.background.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core$macros.current_graphics.call(null).background(rgb);\n});\n\nquil.core$macros.background.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core$macros.current_graphics.call(null).background(rgb,alpha);\n});\n\nquil.core$macros.background.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core$macros.background_float.call(null,r,g,b);\n});\n\nquil.core$macros.background.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,a){\nreturn quil.core$macros.background_float.call(null,r,g,b,a);\n});\n\nquil.core$macros.background.cljs$lang$maxFixedArity = (4);\n/**\n * Specify an image to be used as the background for a sketch. Its\n *   width and height must be the same size as the sketch window. Images\n *   used as background will ignore the current tint setting.\n */\nquil.core$macros.background_image = (function quil$core$macros$background_image(img){\nreturn quil.core$macros.current_graphics.call(null).background(img);\n});\n/**\n * Sets the matrix mode to the camera matrix so calls such as\n *   translate, rotate, apply-matrix and reset-matrix affect the\n *   camera. begin-camera should always be used with a following\n *   end-camera and pairs of begin-camera and end-camera cannot be\n *   nested.\n * \n *   For most situations the camera function will be sufficient.\n */\nquil.core$macros.begin_camera = (function quil$core$macros$begin_camera(){\nreturn quil.core$macros.current_graphics.call(null).beginCamera();\n});\n/**\n * Use the begin-contour and end-contour function to create negative\n *   shapes within shapes. These functions can only be within a\n *   begin-shape/end-shape pair and they only work with the :p2d and :p3d\n *   renderers.\n */\nquil.core$macros.begin_contour = (function quil$core$macros$begin_contour(){\nreturn quil.core$macros.current_graphics.call(null).beginContour();\n});\n/**\n * Enables the creation of complex forms. begin-shape begins recording\n *   vertices for a shape and end-shape stops recording. Use the mode\n *   keyword to specify which shape create from the provided\n *   vertices. With no mode specified, the shape can be any irregular\n *   polygon.\n * \n *   The available mode keywords are :points, :lines, :triangles,\n *                                :triangle-fan, :triangle-strip,\n *                                :quads, :quad-strip.\n * \n *   After calling the begin-shape function, a series of vertex commands\n *   must follow. To stop drawing the shape, call end-shape. The vertex\n *   function with two parameters specifies a position in 2D and the\n *   vertex function with three parameters specifies a position in\n *   3D. Each shape will be outlined with the current stroke color and\n *   filled with the fill color.\n * \n *   Transformations such as translate, rotate, and scale do not work\n *   within begin-shape. It is also not possible to use other shapes,\n *   such as ellipse or rect within begin-shape.\n */\nquil.core$macros.begin_shape = (function quil$core$macros$begin_shape(var_args){\nvar args151 = [];\nvar len__3279__auto___154 = arguments.length;\nvar i__3280__auto___155 = (0);\nwhile(true){\nif((i__3280__auto___155 < len__3279__auto___154)){\nargs151.push((arguments[i__3280__auto___155]));\n\nvar G__156 = (i__3280__auto___155 + (1));\ni__3280__auto___155 = G__156;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__153 = args151.length;\nswitch (G__153) {\ncase (0):\nreturn quil.core$macros.begin_shape.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.begin_shape.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args151.length)].join('')));\n\n}\n});\n\nquil.core$macros.begin_shape.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.current_graphics.call(null).beginShape();\n});\n\nquil.core$macros.begin_shape.cljs$core$IFn$_invoke$arity$1 = (function (mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.shape_modes);\nreturn quil.core$macros.current_graphics.call(null).beginShape((mode__$1 | (0)));\n});\n\nquil.core$macros.begin_shape.cljs$lang$maxFixedArity = (1);\n/**\n * Draws a Bezier curve on the screen. These curves are defined by a\n *   series of anchor and control points. The first two parameters\n *   specify the first anchor point and the last two parameters specify\n *   the other anchor point. The middle parameters specify the control\n *   points which define the shape of the curve.\n */\nquil.core$macros.bezier = (function quil$core$macros$bezier(var_args){\nvar args158 = [];\nvar len__3279__auto___161 = arguments.length;\nvar i__3280__auto___162 = (0);\nwhile(true){\nif((i__3280__auto___162 < len__3279__auto___161)){\nargs158.push((arguments[i__3280__auto___162]));\n\nvar G__163 = (i__3280__auto___162 + (1));\ni__3280__auto___162 = G__163;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__160 = args158.length;\nswitch (G__160) {\ncase (8):\nreturn quil.core$macros.bezier.cljs$core$IFn$_invoke$arity$8((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]));\n\nbreak;\ncase (12):\nreturn quil.core$macros.bezier.cljs$core$IFn$_invoke$arity$12((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args158.length)].join('')));\n\n}\n});\n\nquil.core$macros.bezier.cljs$core$IFn$_invoke$arity$8 = (function (x1,y1,cx1,cy1,cx2,cy2,x2,y2){\nreturn quil.core$macros.current_graphics.call(null).bezier(x1,y1,cx1,cy1,cx2,cy2,x2,y2);\n});\n\nquil.core$macros.bezier.cljs$core$IFn$_invoke$arity$12 = (function (x1,y1,z1,cx1,cy1,cz1,cx2,cy2,cz2,x2,y2,z2){\nreturn quil.core$macros.current_graphics.call(null).bezier(x1,y1,z1,cx1,cy1,cz1,cx2,cy2,cz2,x2,y2,z2);\n});\n\nquil.core$macros.bezier.cljs$lang$maxFixedArity = (12);\n/**\n * Sets the resolution at which Beziers display. The default value is\n *   20. This function is only useful when using the :p3d or :opengl\n *   renderer as the default (:java2d) renderer does not use this\n *   information.\n */\nquil.core$macros.bezier_detail = (function quil$core$macros$bezier_detail(detail){\nreturn quil.core$macros.current_graphics.call(null).bezierDetail((detail | (0)));\n});\n/**\n * Evaluates the Bezier at point t for points a, b, c, d. The\n *   parameter t varies between 0 and 1, a and d are points on the curve,\n *   and b and c are the control points. This can be done once with the x\n *   coordinates and a second time with the y coordinates to get the\n *   location of a bezier curve at t.\n */\nquil.core$macros.bezier_point = (function quil$core$macros$bezier_point(a,b,c,d,t){\nreturn quil.core$macros.current_graphics.call(null).bezierPoint(a,b,c,d,t);\n});\n/**\n * Calculates the tangent of a point on a Bezier curve.\n *   (See http://en.wikipedia.org/wiki/Tangent)\n */\nquil.core$macros.bezier_tangent = (function quil$core$macros$bezier_tangent(a,b,c,d,t){\nreturn quil.core$macros.current_graphics.call(null).bezierTangent(a,b,c,d,t);\n});\n/**\n * Specifies vertex coordinates for Bezier curves. Each call to\n *   bezier-vertex defines the position of two control points and one\n *   anchor point of a Bezier curve, adding a new segment to a line or\n *   shape. The first time bezier-vertex is used within a begin-shape\n *   call, it must be prefaced with a call to vertex to set the first\n *   anchor point. This function must be used between begin-shape and\n *   end-shape and only when there is no parameter specified to\n *   begin-shape.\n */\nquil.core$macros.bezier_vertex = (function quil$core$macros$bezier_vertex(var_args){\nvar args165 = [];\nvar len__3279__auto___168 = arguments.length;\nvar i__3280__auto___169 = (0);\nwhile(true){\nif((i__3280__auto___169 < len__3279__auto___168)){\nargs165.push((arguments[i__3280__auto___169]));\n\nvar G__170 = (i__3280__auto___169 + (1));\ni__3280__auto___169 = G__170;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__167 = args165.length;\nswitch (G__167) {\ncase (6):\nreturn quil.core$macros.bezier_vertex.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ncase (9):\nreturn quil.core$macros.bezier_vertex.cljs$core$IFn$_invoke$arity$9((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args165.length)].join('')));\n\n}\n});\n\nquil.core$macros.bezier_vertex.cljs$core$IFn$_invoke$arity$6 = (function (cx1,cy1,cx2,cy2,x,y){\nreturn quil.core$macros.current_graphics.call(null).bezierVertex(cx1,cy1,cx2,cy2,x,y);\n});\n\nquil.core$macros.bezier_vertex.cljs$core$IFn$_invoke$arity$9 = (function (cx1,cy1,cz1,cx2,cy2,cz2,x,y,z){\nreturn quil.core$macros.current_graphics.call(null).bezierVertex(cx1,cy1,cz1,cx2,cy2,cz2,x,y,z);\n});\n\nquil.core$macros.bezier_vertex.cljs$lang$maxFixedArity = (9);\n/**\n * Returns a string representing the binary value of an int, char or\n *   byte. When converting an int to a string, it is possible to specify\n *   the number of digits used.\n */\nquil.core$macros.binary = (function quil$core$macros$binary(var_args){\nvar args172 = [];\nvar len__3279__auto___175 = arguments.length;\nvar i__3280__auto___176 = (0);\nwhile(true){\nif((i__3280__auto___176 < len__3279__auto___175)){\nargs172.push((arguments[i__3280__auto___176]));\n\nvar G__177 = (i__3280__auto___176 + (1));\ni__3280__auto___176 = G__177;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__174 = args172.length;\nswitch (G__174) {\ncase (1):\nreturn quil.core$macros.binary.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.binary.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args172.length)].join('')));\n\n}\n});\n\nquil.core$macros.binary.cljs$core$IFn$_invoke$arity$1 = (function (val){\nreturn quil.sketch.current_applet.call(null).binary(val);\n});\n\nquil.core$macros.binary.cljs$core$IFn$_invoke$arity$2 = (function (val,num_digits){\nreturn quil.sketch.current_applet.call(null).binary(val,num_digits);\n});\n\nquil.core$macros.binary.cljs$lang$maxFixedArity = (2);\n/**\n * Blends a region of pixels from one image into another with full alpha\n *   channel support. If src is not specified it defaults to current-graphics.\n *   If dest is not specified it defaults to current-graphics.\n * \n *   Note: blend-mode function is recommended to use instead of this one.\n * \n *   Available blend modes are:\n * \n *   :blend      - linear interpolation of colours: C = A*factor + B\n *   :add        - additive blending with white clip:\n *                                          C = min(A*factor + B, 255)\n *   :subtract   - subtractive blending with black clip:\n *                                          C = max(B - A*factor, 0)\n *   :darkest    - only the darkest colour succeeds:\n *                                          C = min(A*factor, B)\n *   :lightest   - only the lightest colour succeeds:\n *                                          C = max(A*factor, B)\n *   :difference - subtract colors from underlying image.\n *   :exclusion  - similar to :difference, but less extreme.\n *   :multiply   - Multiply the colors, result will always be darker.\n *   :screen     - Opposite multiply, uses inverse values of the colors.\n *   :overlay    - A mix of :multiply and :screen. Multiplies dark values\n *              and screens light values.\n *   :hard-light - :screen when greater than 50% gray, :multiply when\n *              lower.\n *   :soft-light - Mix of :darkest and :lightest. Works like :overlay,\n *              but not as harsh.\n *   :dodge      - Lightens light tones and increases contrast, ignores\n *              darks.\n *              Called \"Color Dodge\" in Illustrator and Photoshop.\n *   :burn       - Darker areas are applied, increasing contrast, ignores\n *              lights. Called \"Color Burn\" in Illustrator and\n *              Photoshop.\n */\nquil.core$macros.blend = (function quil$core$macros$blend(var_args){\nvar args179 = [];\nvar len__3279__auto___182 = arguments.length;\nvar i__3280__auto___183 = (0);\nwhile(true){\nif((i__3280__auto___183 < len__3279__auto___182)){\nargs179.push((arguments[i__3280__auto___183]));\n\nvar G__184 = (i__3280__auto___183 + (1));\ni__3280__auto___183 = G__184;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__181 = args179.length;\nswitch (G__181) {\ncase (9):\nreturn quil.core$macros.blend.cljs$core$IFn$_invoke$arity$9((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]));\n\nbreak;\ncase (10):\nreturn quil.core$macros.blend.cljs$core$IFn$_invoke$arity$10((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]));\n\nbreak;\ncase (11):\nreturn quil.core$macros.blend.cljs$core$IFn$_invoke$arity$11((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args179.length)].join('')));\n\n}\n});\n\nquil.core$macros.blend.cljs$core$IFn$_invoke$arity$9 = (function (x,y,width,height,dx,dy,dwidth,dheight,mode){\nreturn quil.core$macros.blend.call(null,quil.core$macros.current_graphics.call(null),quil.core$macros.current_graphics.call(null),x,y,width,height,dx,dy,dwidth,dheight,mode);\n});\n\nquil.core$macros.blend.cljs$core$IFn$_invoke$arity$10 = (function (src_img,x,y,width,height,dx,dy,dwidth,dheight,mode){\nreturn quil.core$macros.blend.call(null,src_img,quil.core$macros.current_graphics.call(null),x,y,width,height,dx,dy,dwidth,dheight,mode);\n});\n\nquil.core$macros.blend.cljs$core$IFn$_invoke$arity$11 = (function (src_img,dest_img,x,y,width,height,dx,dy,dwidth,dheight,mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.blend_modes);\nreturn dest_img.blend(src_img,(x | (0)),(y | (0)),(width | (0)),(height | (0)),(dx | (0)),(dy | (0)),(dwidth | (0)),(dheight | (0)),(mode__$1 | (0)));\n});\n\nquil.core$macros.blend.cljs$lang$maxFixedArity = (11);\n/**\n * Blends two color values together based on the blending mode given specified\n *   with the mode keyword.\n * \n *   Available blend modes are:\n * \n *   :blend      - linear interpolation of colours: C = A*factor + B\n *   :add        - additive blending with white clip:\n *                                          C = min(A*factor + B, 255)\n *   :subtract   - subtractive blending with black clip:\n *                                          C = max(B - A*factor, 0)\n *   :darkest    - only the darkest colour succeeds:\n *                                          C = min(A*factor, B)\n *   :lightest   - only the lightest colour succeeds:\n *                                          C = max(A*factor, B)\n *   :difference - subtract colors from underlying image.\n *   :exclusion  - similar to :difference, but less extreme.\n *   :multiply   - Multiply the colors, result will always be darker.\n *   :screen     - Opposite multiply, uses inverse values of the colors.\n *   :overlay    - A mix of :multiply and :screen. Multiplies dark values\n *              and screens light values.\n *   :hard-light - :screen when greater than 50% gray, :multiply when\n *              lower.\n *   :soft-light - Mix of :darkest and :lightest. Works like :overlay,\n *              but not as harsh.\n *   :dodge      - Lightens light tones and increases contrast, ignores\n *              darks.\n *              Called \"Color Dodge\" in Illustrator and Photoshop.\n *   :burn       - Darker areas are applied, increasing contrast, ignores\n *              lights. Called \"Color Burn\" in Illustrator and\n *              Photoshop.\n */\nquil.core$macros.blend_color = (function quil$core$macros$blend_color(c1,c2,mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.blend_modes);\nreturn quil.core$macros.current_graphics.call(null).blendColor(c1,c2,mode__$1);\n});\n/**\n * Extracts the blue value from a color, scaled to match current color-mode.\n *   Returns a float.\n */\nquil.core$macros.blue = (function quil$core$macros$blue(color){\nreturn quil.core$macros.current_graphics.call(null).blue(cljs.core.unchecked_int.call(null,color));\n});\n/**\n * Creates an extruded rectangle.\n */\nquil.core$macros.box = (function quil$core$macros$box(var_args){\nvar args186 = [];\nvar len__3279__auto___189 = arguments.length;\nvar i__3280__auto___190 = (0);\nwhile(true){\nif((i__3280__auto___190 < len__3279__auto___189)){\nargs186.push((arguments[i__3280__auto___190]));\n\nvar G__191 = (i__3280__auto___190 + (1));\ni__3280__auto___190 = G__191;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__188 = args186.length;\nswitch (G__188) {\ncase (1):\nreturn quil.core$macros.box.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.box.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args186.length)].join('')));\n\n}\n});\n\nquil.core$macros.box.cljs$core$IFn$_invoke$arity$1 = (function (size){\nreturn quil.core$macros.current_graphics.call(null).box(size);\n});\n\nquil.core$macros.box.cljs$core$IFn$_invoke$arity$3 = (function (width,height,depth){\nreturn quil.core$macros.current_graphics.call(null).box(width,height,depth);\n});\n\nquil.core$macros.box.cljs$lang$maxFixedArity = (3);\n/**\n * Extracts the brightness value from a color. Returns a float.\n */\nquil.core$macros.brightness = (function quil$core$macros$brightness(color){\nreturn quil.core$macros.current_graphics.call(null).brightness(cljs.core.unchecked_int.call(null,color));\n});\n/**\n * Sets the position of the camera through setting the eye position,\n *   the center of the scene, and which axis is facing upward. Moving the\n *   eye position and the direction it is pointing (the center of the\n *   scene) allows the images to be seen from different angles. The\n *   version without any parameters sets the camera to the default\n *   position, pointing to the center of the display window with the Y\n *   axis as up. The default values are:\n * \n *   eyeX:     (/ (width) 2.0)\n *   eyeY:     (/ (height) 2.0)\n *   eyeZ:     (/ (/ (height) 2.0) (tan (/ (* Math/PI 60.0) 360.0)))\n *   centerX:  (/ (width) 2.0)\n *   centerY:  (/ (height) 2.0)\n *   centerZ:  0\n *   upX:      0\n *   upY:      1\n *   upZ:      0\n * \n *   Similar imilar to gluLookAt() in OpenGL, but it first clears the\n *   current camera settings.\n */\nquil.core$macros.camera = (function quil$core$macros$camera(var_args){\nvar args193 = [];\nvar len__3279__auto___196 = arguments.length;\nvar i__3280__auto___197 = (0);\nwhile(true){\nif((i__3280__auto___197 < len__3279__auto___196)){\nargs193.push((arguments[i__3280__auto___197]));\n\nvar G__198 = (i__3280__auto___197 + (1));\ni__3280__auto___197 = G__198;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__195 = args193.length;\nswitch (G__195) {\ncase (0):\nreturn quil.core$macros.camera.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (9):\nreturn quil.core$macros.camera.cljs$core$IFn$_invoke$arity$9((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args193.length)].join('')));\n\n}\n});\n\nquil.core$macros.camera.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.current_graphics.call(null).camera();\n});\n\nquil.core$macros.camera.cljs$core$IFn$_invoke$arity$9 = (function (eyeX,eyeY,eyeZ,centerX,centerY,centerZ,upX,upY,upZ){\nreturn quil.core$macros.current_graphics.call(null).camera(eyeX,eyeY,eyeZ,centerX,centerY,centerZ,upX,upY,upZ);\n});\n\nquil.core$macros.camera.cljs$lang$maxFixedArity = (9);\n/**\n * Calculates the closest int value that is greater than or equal to\n *   the value of the parameter. For example, (ceil 9.03) returns the\n *   value 10.\n */\nquil.core$macros.ceil = (function quil$core$macros$ceil(n){\nreturn quil.sketch.current_applet.call(null).ceil(n);\n});\n/**\n * Creates an integer representation of a color The parameters are\n *   interpreted as RGB or HSB values depending on the current\n *   color-mode. The default mode is RGB values from 0 to 255 and\n *   therefore, the function call (color 255 204 0) will return a bright\n *   yellow. Args are cast to floats.\n * \n *   r - red or hue value\n *   g - green or saturation value\n *   b - blue or brightness value\n *   a - alpha value\n */\nquil.core$macros.color = (function quil$core$macros$color(var_args){\nvar args200 = [];\nvar len__3279__auto___203 = arguments.length;\nvar i__3280__auto___204 = (0);\nwhile(true){\nif((i__3280__auto___204 < len__3279__auto___203)){\nargs200.push((arguments[i__3280__auto___204]));\n\nvar G__205 = (i__3280__auto___204 + (1));\ni__3280__auto___204 = G__205;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__202 = args200.length;\nswitch (G__202) {\ncase (1):\nreturn quil.core$macros.color.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.color.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.color.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.color.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args200.length)].join('')));\n\n}\n});\n\nquil.core$macros.color.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nreturn quil.core$macros.current_graphics.call(null).color(gray);\n});\n\nquil.core$macros.color.cljs$core$IFn$_invoke$arity$2 = (function (gray,alpha){\nreturn quil.core$macros.current_graphics.call(null).color(gray,alpha);\n});\n\nquil.core$macros.color.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core$macros.current_graphics.call(null).color(r,g,b);\n});\n\nquil.core$macros.color.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,a){\nreturn quil.core$macros.current_graphics.call(null).color(r,g,b,a);\n});\n\nquil.core$macros.color.cljs$lang$maxFixedArity = (4);\n/**\n * Changes the way Processing interprets color data. Available modes\n *   are :rgb and :hsb.By default, the parameters for fill, stroke,\n *   background, and color are defined by values between 0 and 255 using\n *   the :rgb color model. The color-mode fn is used to change the\n *   numerical range used for specifying colors and to switch color\n *   systems. For example, calling\n *   (color-mode :rgb 1.0) will specify that values are specified between\n *   0 and 1. The limits for defining colors are altered by setting the\n *   parameters range1, range2, range3, and range 4.\n */\nquil.core$macros.color_mode = (function quil$core$macros$color_mode(var_args){\nvar args207 = [];\nvar len__3279__auto___210 = arguments.length;\nvar i__3280__auto___211 = (0);\nwhile(true){\nif((i__3280__auto___211 < len__3279__auto___210)){\nargs207.push((arguments[i__3280__auto___211]));\n\nvar G__212 = (i__3280__auto___211 + (1));\ni__3280__auto___211 = G__212;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__209 = args207.length;\nswitch (G__209) {\ncase (1):\nreturn quil.core$macros.color_mode.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.color_mode.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.color_mode.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (5):\nreturn quil.core$macros.color_mode.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args207.length)].join('')));\n\n}\n});\n\nquil.core$macros.color_mode.cljs$core$IFn$_invoke$arity$1 = (function (mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.color_modes);\nreturn quil.core$macros.current_graphics.call(null).colorMode((mode__$1 | (0)));\n});\n\nquil.core$macros.color_mode.cljs$core$IFn$_invoke$arity$2 = (function (mode,max){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.color_modes);\nreturn quil.core$macros.current_graphics.call(null).colorMode((mode__$1 | (0)),max);\n});\n\nquil.core$macros.color_mode.cljs$core$IFn$_invoke$arity$4 = (function (mode,max_x,max_y,max_z){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.color_modes);\nreturn quil.core$macros.current_graphics.call(null).colorMode((mode__$1 | (0)),max_x,max_y,max_z);\n});\n\nquil.core$macros.color_mode.cljs$core$IFn$_invoke$arity$5 = (function (mode,max_x,max_y,max_z,max_a){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.color_modes);\nreturn quil.core$macros.current_graphics.call(null).colorMode((mode__$1 | (0)),max_x,max_y,max_z,max_a);\n});\n\nquil.core$macros.color_mode.cljs$lang$maxFixedArity = (5);\n/**\n * Constrains a value to not exceed a maximum and minimum value.\n */\nquil.core$macros.constrain = (function quil$core$macros$constrain(amt,low,high){\nreturn quil.sketch.current_applet.call(null).constrain(amt,low,high);\n});\n/**\n * Copies a region of pixels from the one image to another. If src-img\n *   is not specified it defaults to current-graphics. If dest-img is not\n *   specified - it defaults to current-graphics. If the source\n *   and destination regions aren't the same size, it will automatically\n *   resize the source pixels to fit the specified target region. No\n *   alpha information is used in the process, however if the source\n *   image has an alpha channel set, it will be copied as well. \n */\nquil.core$macros.copy = (function quil$core$macros$copy(var_args){\nvar args214 = [];\nvar len__3279__auto___229 = arguments.length;\nvar i__3280__auto___230 = (0);\nwhile(true){\nif((i__3280__auto___230 < len__3279__auto___229)){\nargs214.push((arguments[i__3280__auto___230]));\n\nvar G__231 = (i__3280__auto___230 + (1));\ni__3280__auto___230 = G__231;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__216 = args214.length;\nswitch (G__216) {\ncase (2):\nreturn quil.core$macros.copy.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.copy.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.copy.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args214.length)].join('')));\n\n}\n});\n\nquil.core$macros.copy.cljs$core$IFn$_invoke$arity$2 = (function (p__217,p__218){\nvar vec__219 = p__217;\nvar sx = cljs.core.nth.call(null,vec__219,(0),null);\nvar sy = cljs.core.nth.call(null,vec__219,(1),null);\nvar swidth = cljs.core.nth.call(null,vec__219,(2),null);\nvar sheight = cljs.core.nth.call(null,vec__219,(3),null);\nvar vec__220 = p__218;\nvar dx = cljs.core.nth.call(null,vec__220,(0),null);\nvar dy = cljs.core.nth.call(null,vec__220,(1),null);\nvar dwidth = cljs.core.nth.call(null,vec__220,(2),null);\nvar dheight = cljs.core.nth.call(null,vec__220,(3),null);\nreturn quil.core$macros.current_graphics.call(null).copy((sx | (0)),(sy | (0)),(swidth | (0)),(sheight | (0)),(dx | (0)),(dy | (0)),(dwidth | (0)),(dheight | (0)));\n});\n\nquil.core$macros.copy.cljs$core$IFn$_invoke$arity$3 = (function (src_img,p__221,p__222){\nvar vec__223 = p__221;\nvar sx = cljs.core.nth.call(null,vec__223,(0),null);\nvar sy = cljs.core.nth.call(null,vec__223,(1),null);\nvar swidth = cljs.core.nth.call(null,vec__223,(2),null);\nvar sheight = cljs.core.nth.call(null,vec__223,(3),null);\nvar vec__224 = p__222;\nvar dx = cljs.core.nth.call(null,vec__224,(0),null);\nvar dy = cljs.core.nth.call(null,vec__224,(1),null);\nvar dwidth = cljs.core.nth.call(null,vec__224,(2),null);\nvar dheight = cljs.core.nth.call(null,vec__224,(3),null);\nreturn quil.core$macros.copy.call(null,src_img,quil.core$macros.current_graphics.call(null),new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [sx,sy,swidth,sheight], null),new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [dx,dy,dwidth,dheight], null));\n});\n\nquil.core$macros.copy.cljs$core$IFn$_invoke$arity$4 = (function (src_img,dest_img,p__225,p__226){\nvar vec__227 = p__225;\nvar sx = cljs.core.nth.call(null,vec__227,(0),null);\nvar sy = cljs.core.nth.call(null,vec__227,(1),null);\nvar swidth = cljs.core.nth.call(null,vec__227,(2),null);\nvar sheight = cljs.core.nth.call(null,vec__227,(3),null);\nvar vec__228 = p__226;\nvar dx = cljs.core.nth.call(null,vec__228,(0),null);\nvar dy = cljs.core.nth.call(null,vec__228,(1),null);\nvar dwidth = cljs.core.nth.call(null,vec__228,(2),null);\nvar dheight = cljs.core.nth.call(null,vec__228,(3),null);\nreturn dest_img.copy(src_img,(sx | (0)),(sy | (0)),(swidth | (0)),(sheight | (0)),(dx | (0)),(dy | (0)),(dwidth | (0)),(dheight | (0)));\n});\n\nquil.core$macros.copy.cljs$lang$maxFixedArity = (4);\n/**\n * Calculates the cosine of an angle. This function expects the values\n *   of the angle parameter to be provided in radians (values from 0 to\n *   Math/PI*2). Values are returned in the range -1 to 1.\n */\nquil.core$macros.cos = (function quil$core$macros$cos(angle){\nreturn quil.sketch.current_applet.call(null).cos(angle);\n});\n/**\n * Dynamically converts a font to the format used by Processing (a\n *   PFont) from either a font name that's installed on the computer, or\n *   from a .ttf or .otf file inside the sketches 'data' folder. This\n *   function is an advanced feature for precise control.\n * \n *   Use available-fonts to obtain the names for the fonts recognized by\n *   the computer and are compatible with this function.\n * \n *   The size parameter states the font size you want to generate. The\n *   smooth parameter specifies if the font should be antialiased or not,\n *   and the charset parameter is an array of chars that specifies the\n *   characters to generate.\n * \n *   This function creates a bitmapped version of a font It loads a font\n *   by name, and converts it to a series of images based on the size of\n *   the font. When possible, the text function will use a native font\n *   rather than the bitmapped version created behind the scenes with\n *   create-font. For instance, when using the default renderer\n *   setting (JAVA2D), the actual native version of the font will be\n *   employed by the sketch, improving drawing quality and\n *   performance. With the :p2d, :p3d, and :opengl renderer settings, the\n *   bitmapped version will be used. While this can drastically improve\n *   speed and appearance, results are poor when exporting if the sketch\n *   does not include the .otf or .ttf file, and the requested font is\n *   not available on the machine running the sketch.\n */\nquil.core$macros.create_font = (function quil$core$macros$create_font(var_args){\nvar args233 = [];\nvar len__3279__auto___236 = arguments.length;\nvar i__3280__auto___237 = (0);\nwhile(true){\nif((i__3280__auto___237 < len__3279__auto___236)){\nargs233.push((arguments[i__3280__auto___237]));\n\nvar G__238 = (i__3280__auto___237 + (1));\ni__3280__auto___237 = G__238;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__235 = args233.length;\nswitch (G__235) {\ncase (2):\nreturn quil.core$macros.create_font.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.create_font.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.create_font.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args233.length)].join('')));\n\n}\n});\n\nquil.core$macros.create_font.cljs$core$IFn$_invoke$arity$2 = (function (name,size){\nreturn quil.sketch.current_applet.call(null).createFont([cljs.core.str(name)].join(''),size);\n});\n\nquil.core$macros.create_font.cljs$core$IFn$_invoke$arity$3 = (function (name,size,smooth){\nreturn quil.sketch.current_applet.call(null).createFont([cljs.core.str(name)].join(''),size,smooth);\n});\n\nquil.core$macros.create_font.cljs$core$IFn$_invoke$arity$4 = (function (name,size,smooth,charset){\nreturn quil.sketch.current_applet.call(null).createFont([cljs.core.str(name)].join(''),size,smooth,charset);\n});\n\nquil.core$macros.create_font.cljs$lang$maxFixedArity = (4);\n/**\n * Creates and returns a new PGraphics object of the types :p2d, :p3d,\n *   :java2d, :pdf. By default :java2d is used. Use this class if you\n *   need to draw into an off-screen graphics buffer. It's not possible\n *   to use create-graphics with the :opengl renderer, because it doesn't\n *   allow offscreen use. The :pdf renderer requires the filename parameter.\n * \n *   Note: don't use create-graphics in draw in clojurescript, it leaks memory.\n *   You should create graphic in setup and reuse it in draw instead of creating\n *   a new one.\n * \n *   It's important to call any drawing commands between (.beginDraw graphics) and\n *   (.endDraw graphics) statements or use with-graphics macro. This is also true\n *   for any commands that affect drawing, such as smooth or color-mode.\n * \n *   If you're using :pdf renderer - don't forget to call (.dispose graphics)\n *   as last command inside with-graphics macro, otherwise graphics won't be\n *   saved.\n * \n *   Unlike the main drawing surface which is completely opaque, surfaces\n *   created with create-graphics can have transparency. This makes it\n *   possible to draw into a graphics and maintain the alpha channel. By\n *   using save to write a PNG or TGA file, the transparency of the\n *   graphics object will be honored.\n */\nquil.core$macros.create_graphics = (function quil$core$macros$create_graphics(var_args){\nvar args240 = [];\nvar len__3279__auto___243 = arguments.length;\nvar i__3280__auto___244 = (0);\nwhile(true){\nif((i__3280__auto___244 < len__3279__auto___243)){\nargs240.push((arguments[i__3280__auto___244]));\n\nvar G__245 = (i__3280__auto___244 + (1));\ni__3280__auto___244 = G__245;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__242 = args240.length;\nswitch (G__242) {\ncase (2):\nreturn quil.core$macros.create_graphics.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.create_graphics.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.create_graphics.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args240.length)].join('')));\n\n}\n});\n\nquil.core$macros.create_graphics.cljs$core$IFn$_invoke$arity$2 = (function (w,h){\nreturn quil.sketch.current_applet.call(null).createGraphics((w | (0)),(h | (0)),new cljs.core.Keyword(null,\"p2d\",\"p2d\",(-2106175755)));\n});\n\nquil.core$macros.create_graphics.cljs$core$IFn$_invoke$arity$3 = (function (w,h,renderer){\nreturn quil.sketch.current_applet.call(null).createGraphics((w | (0)),(h | (0)),quil.sketch.resolve_renderer.call(null,renderer));\n});\n\nquil.core$macros.create_graphics.cljs$core$IFn$_invoke$arity$4 = (function (w,h,renderer,path){\nreturn quil.sketch.current_applet.call(null).createGraphics((w | (0)),(h | (0)),quil.sketch.resolve_renderer.call(null,renderer),path);\n});\n\nquil.core$macros.create_graphics.cljs$lang$maxFixedArity = (4);\n/**\n * Creates a new PImage (the datatype for storing images). This\n *   provides a fresh buffer of pixels to play with. Set the size of the\n *   buffer with the width and height parameters. The format parameter\n *   defines how the pixels are stored. See the PImage reference for more\n *   information.\n * \n *   Possible formats: :rgb, :argb, :alpha (grayscale alpha channel)\n * \n *   Prefer using create-image over initialising new PImage instances\n *   directly.\n */\nquil.core$macros.create_image = (function quil$core$macros$create_image(w,h,format){\nvar format__$1 = quil.util.resolve_constant_key.call(null,format,quil.core$macros.image_formats);\nreturn quil.sketch.current_applet.call(null).createImage((w | (0)),(h | (0)),(format__$1 | (0)));\n});\n/**\n * Return the current fill color.\n */\nquil.core$macros.current_fill = (function quil$core$macros$current_fill(){\nreturn quil.core$macros.current_graphics.call(null).fillColor();\n});\n/**\n * Return the current stroke color.\n */\nquil.core$macros.current_stroke = (function quil$core$macros$current_stroke(){\nreturn quil.core$macros.current_graphics.call(null).strokeColor();\n});\n/**\n * Sets the cursor to a predefined symbol or makes it\n *   visible if already hidden (after no-cursor was called).\n * \n *   Available modes: :arrow, :cross, :hand, :move, :text, :wait\n * \n *   See cursor-image for specifying a generic image as the cursor\n *   symbol.\n */\nquil.core$macros.cursor = (function quil$core$macros$cursor(var_args){\nvar args247 = [];\nvar len__3279__auto___250 = arguments.length;\nvar i__3280__auto___251 = (0);\nwhile(true){\nif((i__3280__auto___251 < len__3279__auto___250)){\nargs247.push((arguments[i__3280__auto___251]));\n\nvar G__252 = (i__3280__auto___251 + (1));\ni__3280__auto___251 = G__252;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__249 = args247.length;\nswitch (G__249) {\ncase (0):\nreturn quil.core$macros.cursor.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.cursor.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args247.length)].join('')));\n\n}\n});\n\nquil.core$macros.cursor.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.sketch.current_applet.call(null).cursor();\n});\n\nquil.core$macros.cursor.cljs$core$IFn$_invoke$arity$1 = (function (cursor_mode){\nvar cursor_mode__$1 = quil.util.resolve_constant_key.call(null,cursor_mode,quil.core$macros.cursor_modes);\nreturn quil.sketch.current_applet.call(null).cursor([cljs.core.str(cursor_mode__$1)].join(''));\n});\n\nquil.core$macros.cursor.cljs$lang$maxFixedArity = (1);\n/**\n * Set the cursor to a predefined image. The horizontal and vertical\n *   active spots of the cursor may be specified with hx and hy.\n *   It is recommended to make the size 16x16 or 32x32 pixels.\n */\nquil.core$macros.cursor_image = (function quil$core$macros$cursor_image(var_args){\nvar args254 = [];\nvar len__3279__auto___257 = arguments.length;\nvar i__3280__auto___258 = (0);\nwhile(true){\nif((i__3280__auto___258 < len__3279__auto___257)){\nargs254.push((arguments[i__3280__auto___258]));\n\nvar G__259 = (i__3280__auto___258 + (1));\ni__3280__auto___258 = G__259;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__256 = args254.length;\nswitch (G__256) {\ncase (1):\nreturn quil.core$macros.cursor_image.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.cursor_image.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args254.length)].join('')));\n\n}\n});\n\nquil.core$macros.cursor_image.cljs$core$IFn$_invoke$arity$1 = (function (img){\nreturn quil.sketch.current_applet.call(null).cursor(img);\n});\n\nquil.core$macros.cursor_image.cljs$core$IFn$_invoke$arity$3 = (function (img,hx,hy){\nreturn quil.sketch.current_applet.call(null).cursor(img,(hx | (0)),(hy | (0)));\n});\n\nquil.core$macros.cursor_image.cljs$lang$maxFixedArity = (3);\n/**\n * Draws a curved line on the screen. The first and second parameters\n *   specify the beginning control point and the last two parameters\n *   specify the ending control point. The middle parameters specify the\n *   start and stop of the curve. Longer curves can be created by putting\n *   a series of curve fns together or using curve-vertex. An additional\n *   fn called curve-tightness provides control for the visual quality of\n *   the curve. The curve fn is an implementation of Catmull-Rom\n *   splines.\n */\nquil.core$macros.curve = (function quil$core$macros$curve(var_args){\nvar args261 = [];\nvar len__3279__auto___264 = arguments.length;\nvar i__3280__auto___265 = (0);\nwhile(true){\nif((i__3280__auto___265 < len__3279__auto___264)){\nargs261.push((arguments[i__3280__auto___265]));\n\nvar G__266 = (i__3280__auto___265 + (1));\ni__3280__auto___265 = G__266;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__263 = args261.length;\nswitch (G__263) {\ncase (8):\nreturn quil.core$macros.curve.cljs$core$IFn$_invoke$arity$8((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]));\n\nbreak;\ncase (12):\nreturn quil.core$macros.curve.cljs$core$IFn$_invoke$arity$12((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]),(arguments[(11)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args261.length)].join('')));\n\n}\n});\n\nquil.core$macros.curve.cljs$core$IFn$_invoke$arity$8 = (function (x1,y1,x2,y2,x3,y3,x4,y4){\nreturn quil.core$macros.current_graphics.call(null).curve(x1,y1,x2,y2,x3,y3,x4,y4);\n});\n\nquil.core$macros.curve.cljs$core$IFn$_invoke$arity$12 = (function (x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4){\nreturn quil.core$macros.current_graphics.call(null).curve(x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4);\n});\n\nquil.core$macros.curve.cljs$lang$maxFixedArity = (12);\n/**\n * Sets the resolution at which curves display. The default value is\n *   20. This function is only useful when using the :p3d or :opengl\n *   renderer as the default (:java2d) renderer does not use this\n *   information.\n */\nquil.core$macros.curve_detail = (function quil$core$macros$curve_detail(detail){\nreturn quil.core$macros.current_graphics.call(null).curveDetail((detail | (0)));\n});\n/**\n * Evalutes the curve at point t for points a, b, c, d. The parameter\n *   t varies between 0 and 1, a and d are points on the curve, and b c\n *   and are the control points. This can be done once with the x\n *   coordinates and a second time with the y coordinates to get the\n *   location of a curve at t.\n */\nquil.core$macros.curve_point = (function quil$core$macros$curve_point(a,b,c,d,t){\nreturn quil.core$macros.current_graphics.call(null).curvePoint(a,b,c,d,t);\n});\n/**\n * Calculates the tangent of a point on a curve.\n *   See: http://en.wikipedia.org/wiki/Tangent\n */\nquil.core$macros.curve_tangent = (function quil$core$macros$curve_tangent(a,b,c,d,t){\nreturn quil.core$macros.current_graphics.call(null).curveTangent(a,b,c,d,t);\n});\n/**\n * Modifies the quality of forms created with curve and\n *   curve-vertex. The parameter squishy determines how the curve fits\n *   to the vertex points. The value 0.0 is the default value for\n *   squishy (this value defines the curves to be Catmull-Rom splines)\n *   and the value 1.0 connects all the points with straight\n *   lines. Values within the range -5.0 and 5.0 will deform the curves\n *   but will leave them recognizable and as values increase in\n *   magnitude, they will continue to deform.\n */\nquil.core$macros.curve_tightness = (function quil$core$macros$curve_tightness(ti){\nreturn quil.core$macros.current_graphics.call(null).curveTightness(ti);\n});\n/**\n * Specifies vertex coordinates for curves. This function may only be\n *   used between begin-shape and end-shape and only when there is no\n *   mode keyword specified to begin-shape. The first and last points in a\n *   series of curve-vertex lines will be used to guide the beginning and\n *   end of a the curve. A minimum of four points is required to draw a\n *   tiny curve between the second and third points. Adding a fifth point\n *   with curve-vertex will draw the curve between the second, third, and\n *   fourth points. The curve-vertex function is an implementation of\n *   Catmull-Rom splines.\n */\nquil.core$macros.curve_vertex = (function quil$core$macros$curve_vertex(var_args){\nvar args268 = [];\nvar len__3279__auto___271 = arguments.length;\nvar i__3280__auto___272 = (0);\nwhile(true){\nif((i__3280__auto___272 < len__3279__auto___271)){\nargs268.push((arguments[i__3280__auto___272]));\n\nvar G__273 = (i__3280__auto___272 + (1));\ni__3280__auto___272 = G__273;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__270 = args268.length;\nswitch (G__270) {\ncase (2):\nreturn quil.core$macros.curve_vertex.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.curve_vertex.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args268.length)].join('')));\n\n}\n});\n\nquil.core$macros.curve_vertex.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.core$macros.current_graphics.call(null).curveVertex(x,y);\n});\n\nquil.core$macros.curve_vertex.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.current_graphics.call(null).curveVertex(x,y,z);\n});\n\nquil.core$macros.curve_vertex.cljs$lang$maxFixedArity = (3);\n/**\n * Get the current day of the month (1 through 31).\n */\nquil.core$macros.day = (function quil$core$macros$day(){\nreturn quil.sketch.current_applet.call(null).day();\n});\nquil.core$macros.degrees = (function quil$core$macros$degrees(radians){\nreturn quil.sketch.current_applet.call(null).degrees(radians);\n});\n/**\n * Forces the program to stop running for a specified time. Delay\n *   times are specified in thousandths of a second, therefore the\n *   function call (delay 3000) will stop the program for three\n *   seconds. Because the screen is updated only at the end of draw,\n *   the program may appear to 'freeze', because the screen will not\n *   update when the delay fn is used. This function has no affect\n *   inside setup.\n */\nquil.core$macros.delay_frame = (function quil$core$macros$delay_frame(freeze_ms){\nreturn quil.sketch.current_applet.call(null).delay((freeze_ms | (0)));\n});\n/**\n * Adds a directional light. Directional light comes from one\n *   direction and is stronger when hitting a surface squarely and weaker\n *   if it hits at a gentle angle. After hitting a surface, a\n *   directional lights scatters in all directions. Lights need to be\n *   included in the draw fn to remain persistent in a looping\n *   program. Placing them in the setup fn of a looping program will cause\n *   them to only have an effect the first time through the loop. The\n *   affect of the r, g, and b parameters is determined by the current\n *   color mode. The nx, ny, and nz parameters specify the direction the\n *   light is facing. For example, setting ny to -1 will cause the\n *   geometry to be lit from below (the light is facing directly upward)\n */\nquil.core$macros.directional_light = (function quil$core$macros$directional_light(r,g,b,nx,ny,nz){\nreturn quil.core$macros.current_graphics.call(null).directionalLight(r,g,b,nx,ny,nz);\n});\n/**\n * Calculates the distance between two points\n */\nquil.core$macros.dist = (function quil$core$macros$dist(var_args){\nvar args275 = [];\nvar len__3279__auto___278 = arguments.length;\nvar i__3280__auto___279 = (0);\nwhile(true){\nif((i__3280__auto___279 < len__3279__auto___278)){\nargs275.push((arguments[i__3280__auto___279]));\n\nvar G__280 = (i__3280__auto___279 + (1));\ni__3280__auto___279 = G__280;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__277 = args275.length;\nswitch (G__277) {\ncase (4):\nreturn quil.core$macros.dist.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (6):\nreturn quil.core$macros.dist.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args275.length)].join('')));\n\n}\n});\n\nquil.core$macros.dist.cljs$core$IFn$_invoke$arity$4 = (function (x1,y1,x2,y2){\nreturn quil.sketch.current_applet.call(null).dist(x1,y1,x2,y2);\n});\n\nquil.core$macros.dist.cljs$core$IFn$_invoke$arity$6 = (function (x1,y1,z1,x2,y2,z2){\nreturn quil.sketch.current_applet.call(null).dist(x1,y1,z1,x2,y2,z2);\n});\n\nquil.core$macros.dist.cljs$lang$maxFixedArity = (6);\n/**\n * Draws an ellipse (oval) in the display window. An ellipse with an\n *   equal width and height is a circle.  The origin may be changed with\n *   the ellipse-mode function\n */\nquil.core$macros.ellipse = (function quil$core$macros$ellipse(x,y,width,height){\nreturn quil.core$macros.current_graphics.call(null).ellipse(x,y,width,height);\n});\n/**\n * Modifies the origin of the ellispse according to the specified mode:\n * \n *   :center  - specifies the location of the ellipse as\n *           the center of the shape. (Default).\n *   :radius  - similar to center, but the width and height parameters to\n *           ellipse specify the radius of the ellipse, rather than the\n *           diameter.\n *   :corner  - draws the shape from the upper-left corner of its bounding\n *           box.\n *   :corners - uses the four parameters to ellipse to set two opposing\n *           corners of the ellipse's bounding box.\n */\nquil.core$macros.ellipse_mode = (function quil$core$macros$ellipse_mode(mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.ellipse_modes);\nreturn quil.core$macros.current_graphics.call(null).ellipseMode((mode__$1 | (0)));\n});\n/**\n * Sets the emissive color of the material used for drawing shapes\n *  drawn to the screen. Used in combination with ambient, specular, and\n *  shininess in setting the material properties of shapes. Converts all\n *  args to floats\n */\nquil.core$macros.emissive_float = (function quil$core$macros$emissive_float(var_args){\nvar args282 = [];\nvar len__3279__auto___285 = arguments.length;\nvar i__3280__auto___286 = (0);\nwhile(true){\nif((i__3280__auto___286 < len__3279__auto___285)){\nargs282.push((arguments[i__3280__auto___286]));\n\nvar G__287 = (i__3280__auto___286 + (1));\ni__3280__auto___286 = G__287;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__284 = args282.length;\nswitch (G__284) {\ncase (1):\nreturn quil.core$macros.emissive_float.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.emissive_float.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args282.length)].join('')));\n\n}\n});\n\nquil.core$macros.emissive_float.cljs$core$IFn$_invoke$arity$1 = (function (float_val){\nreturn quil.core$macros.current_graphics.call(null).emissive(float_val);\n});\n\nquil.core$macros.emissive_float.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core$macros.current_graphics.call(null).emissive(r,g,b);\n});\n\nquil.core$macros.emissive_float.cljs$lang$maxFixedArity = (3);\n/**\n * Sets the emissive color of the material used for drawing shapes\n *   drawn to the screen. Used in combination with ambient, specular, and\n *   shininess in setting the material properties of shapes. Converts all\n *   args to ints\n */\nquil.core$macros.emissive_int = (function quil$core$macros$emissive_int(int_val){\nreturn quil.core$macros.current_graphics.call(null).emissive((int_val | (0)));\n});\n/**\n * Sets the emissive color of the material used for drawing shapes\n *   drawn to the screen. Used in combination with ambient, specular, and\n *   shininess in setting the material properties of shapes.\n * \n *   If passed one arg - it is assumed to be an int (i.e. a color),\n *   multiple args are converted to floats.\n */\nquil.core$macros.emissive = (function quil$core$macros$emissive(var_args){\nvar args289 = [];\nvar len__3279__auto___292 = arguments.length;\nvar i__3280__auto___293 = (0);\nwhile(true){\nif((i__3280__auto___293 < len__3279__auto___292)){\nargs289.push((arguments[i__3280__auto___293]));\n\nvar G__294 = (i__3280__auto___293 + (1));\ni__3280__auto___293 = G__294;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__291 = args289.length;\nswitch (G__291) {\ncase (1):\nreturn quil.core$macros.emissive.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.emissive.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args289.length)].join('')));\n\n}\n});\n\nquil.core$macros.emissive.cljs$core$IFn$_invoke$arity$1 = (function (c){\nreturn quil.core$macros.emissive_float.call(null,c);\n});\n\nquil.core$macros.emissive.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core$macros.emissive_float.call(null,r,g,b);\n});\n\nquil.core$macros.emissive.cljs$lang$maxFixedArity = (3);\n/**\n * Unsets the matrix mode from the camera matrix. See begin-camera.\n */\nquil.core$macros.end_camera = (function quil$core$macros$end_camera(){\nreturn quil.core$macros.current_graphics.call(null).endCamera();\n});\n/**\n * Use the begin-contour and end-contour function to create negative\n *   shapes within shapes. These functions can only be within a\n *   begin-shape/end-shape pair and they only work with the :p2d and :p3d\n *   renderers.\n */\nquil.core$macros.end_contour = (function quil$core$macros$end_contour(){\nreturn quil.core$macros.current_graphics.call(null).endContour();\n});\n/**\n * Complement to begin-raw; they must always be used together. See\n *   the begin-raw docstring for details.\n */\nquil.core$macros.end_raw = (function quil$core$macros$end_raw(){\nreturn quil.core$macros.current_graphics.call(null).endRaw();\n});\n/**\n * May only be called after begin-shape. When end-shape is called,\n *   all of image data defined since the previous call to begin-shape is\n *   written into the image buffer. The keyword :close may be passed to\n *   close the shape (to connect the beginning and the end).\n */\nquil.core$macros.end_shape = (function quil$core$macros$end_shape(var_args){\nvar args296 = [];\nvar len__3279__auto___299 = arguments.length;\nvar i__3280__auto___300 = (0);\nwhile(true){\nif((i__3280__auto___300 < len__3279__auto___299)){\nargs296.push((arguments[i__3280__auto___300]));\n\nvar G__301 = (i__3280__auto___300 + (1));\ni__3280__auto___300 = G__301;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__298 = args296.length;\nswitch (G__298) {\ncase (0):\nreturn quil.core$macros.end_shape.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.end_shape.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args296.length)].join('')));\n\n}\n});\n\nquil.core$macros.end_shape.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.current_graphics.call(null).endShape();\n});\n\nquil.core$macros.end_shape.cljs$core$IFn$_invoke$arity$1 = (function (mode){\nif(cljs.core._EQ_.call(null,new cljs.core.Keyword(null,\"close\",\"close\",(1835149582)),mode)){\n} else {\n}\n\nreturn quil.core$macros.current_graphics.call(null).endShape((2));\n});\n\nquil.core$macros.end_shape.cljs$lang$maxFixedArity = (1);\n/**\n * Quits/stops/exits the program.  Rather than terminating\n *   immediately, exit will cause the sketch to exit after draw has\n *   completed (or after setup completes if called during the setup\n *   method). \n */\nquil.core$macros.exit = (function quil$core$macros$exit(){\nreturn quil.sketch.current_applet.call(null).exit();\n});\n/**\n * Returns Euler's number e (2.71828...) raised to the power of the\n *   value parameter.\n */\nquil.core$macros.exp = (function quil$core$macros$exp(val){\nreturn quil.sketch.current_applet.call(null).exp(val);\n});\n/**\n * Sets custom property on graphcis object indicating that it has\n *   fill color.\n */\nquil.core$macros.clear_no_fill_cljs = (function quil$core$macros$clear_no_fill_cljs(graphics){\nreturn (graphics[quil.core$macros.no_fill_prop] = false);\n});\n/**\n * Sets the color used to fill shapes. For example, (fill 204 102 0),\n *   will specify that all subsequent shapes will be filled with orange.\n */\nquil.core$macros.fill_float = (function quil$core$macros$fill_float(var_args){\nvar args303 = [];\nvar len__3279__auto___306 = arguments.length;\nvar i__3280__auto___307 = (0);\nwhile(true){\nif((i__3280__auto___307 < len__3279__auto___306)){\nargs303.push((arguments[i__3280__auto___307]));\n\nvar G__308 = (i__3280__auto___307 + (1));\ni__3280__auto___307 = G__308;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__305 = args303.length;\nswitch (G__305) {\ncase (1):\nreturn quil.core$macros.fill_float.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.fill_float.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.fill_float.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.fill_float.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args303.length)].join('')));\n\n}\n});\n\nquil.core$macros.fill_float.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nquil.core$macros.current_graphics.call(null).fill(gray);\n\nreturn quil.core$macros.clear_no_fill_cljs.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.fill_float.cljs$core$IFn$_invoke$arity$2 = (function (gray,alpha){\nquil.core$macros.current_graphics.call(null).fill(gray,alpha);\n\nreturn quil.core$macros.clear_no_fill_cljs.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.fill_float.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nquil.core$macros.current_graphics.call(null).fill(r,g,b);\n\nreturn quil.core$macros.clear_no_fill_cljs.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.fill_float.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,alpha){\nquil.core$macros.current_graphics.call(null).fill(r,g,b,alpha);\n\nreturn quil.core$macros.clear_no_fill_cljs.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.fill_float.cljs$lang$maxFixedArity = (4);\n/**\n * Sets the color used to fill shapes.\n */\nquil.core$macros.fill_int = (function quil$core$macros$fill_int(var_args){\nvar args310 = [];\nvar len__3279__auto___313 = arguments.length;\nvar i__3280__auto___314 = (0);\nwhile(true){\nif((i__3280__auto___314 < len__3279__auto___313)){\nargs310.push((arguments[i__3280__auto___314]));\n\nvar G__315 = (i__3280__auto___314 + (1));\ni__3280__auto___314 = G__315;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__312 = args310.length;\nswitch (G__312) {\ncase (1):\nreturn quil.core$macros.fill_int.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.fill_int.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args310.length)].join('')));\n\n}\n});\n\nquil.core$macros.fill_int.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nquil.core$macros.current_graphics.call(null).fill(cljs.core.unchecked_int.call(null,rgb));\n\nreturn quil.core$macros.clear_no_fill_cljs.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.fill_int.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nquil.core$macros.current_graphics.call(null).fill(cljs.core.unchecked_int.call(null,rgb),alpha);\n\nreturn quil.core$macros.clear_no_fill_cljs.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.fill_int.cljs$lang$maxFixedArity = (2);\n/**\n * Sets the color used to fill shapes.\n */\nquil.core$macros.fill = (function quil$core$macros$fill(var_args){\nvar args317 = [];\nvar len__3279__auto___320 = arguments.length;\nvar i__3280__auto___321 = (0);\nwhile(true){\nif((i__3280__auto___321 < len__3279__auto___320)){\nargs317.push((arguments[i__3280__auto___321]));\n\nvar G__322 = (i__3280__auto___321 + (1));\ni__3280__auto___321 = G__322;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__319 = args317.length;\nswitch (G__319) {\ncase (1):\nreturn quil.core$macros.fill.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.fill.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.fill.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.fill.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args317.length)].join('')));\n\n}\n});\n\nquil.core$macros.fill.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core$macros.fill_float.call(null,rgb);\n});\n\nquil.core$macros.fill.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core$macros.fill_float.call(null,rgb,alpha);\n});\n\nquil.core$macros.fill.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core$macros.fill_float.call(null,r,g,b);\n});\n\nquil.core$macros.fill.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,a){\nreturn quil.core$macros.fill_float.call(null,r,g,b,a);\n});\n\nquil.core$macros.fill.cljs$lang$maxFixedArity = (4);\n/**\n * Originally named filter in Processing Language.\n *   Filters the display window with the specified mode and level.\n *   Level defines the quality of the filter and mode may be one of the\n *   following keywords:\n * \n *   :threshold - converts the image to black and white pixels depending\n *             if they are above or below the threshold defined by\n *             the level parameter. The level must be between\n *             0.0 (black) and 1.0 (white). If no level is specified,\n *             0.5 is used.\n *   :gray      - converts any colors in the image to grayscale\n *             equivalents. Doesn't work with level.\n *   :invert    - sets each pixel to its inverse value. Doesn't work with\n *             level.\n *   :posterize - limits each channel of the image to the number of\n *             colors specified as the level parameter. The parameter can\n *             be set to values between 2 and 255, but results are most\n *             noticeable in the lower ranges.\n *   :blur      - executes a Guassian blur with the level parameter\n *             specifying the extent of the blurring. If no level\n *             parameter is used, the blur is equivalent to Guassian\n *             blur of radius 1.\n *   :opaque    - sets the alpha channel to entirely opaque. Doesn't work\n *             with level.\n *   :erode     - reduces the light areas. Doesn't work with level.\n *   :dilate    - increases the light areas.  Doesn't work with level.\n */\nquil.core$macros.display_filter = (function quil$core$macros$display_filter(var_args){\nvar args324 = [];\nvar len__3279__auto___327 = arguments.length;\nvar i__3280__auto___328 = (0);\nwhile(true){\nif((i__3280__auto___328 < len__3279__auto___327)){\nargs324.push((arguments[i__3280__auto___328]));\n\nvar G__329 = (i__3280__auto___328 + (1));\ni__3280__auto___328 = G__329;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__326 = args324.length;\nswitch (G__326) {\ncase (1):\nreturn quil.core$macros.display_filter.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.display_filter.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args324.length)].join('')));\n\n}\n});\n\nquil.core$macros.display_filter.cljs$core$IFn$_invoke$arity$1 = (function (mode){\nreturn quil.core$macros.current_graphics.call(null).filter((quil.util.resolve_constant_key.call(null,mode,quil.core$macros.filter_modes) | (0)));\n});\n\nquil.core$macros.display_filter.cljs$core$IFn$_invoke$arity$2 = (function (mode,level){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.filter_modes);\nreturn quil.core$macros.current_graphics.call(null).filter((mode__$1 | (0)),level);\n});\n\nquil.core$macros.display_filter.cljs$lang$maxFixedArity = (2);\n/**\n * Calculates the closest int value that is less than or equal to the\n *   value of the parameter. For example, (floor 9.03) returns the value 9.\n */\nquil.core$macros.floor = (function quil$core$macros$floor(n){\nreturn quil.sketch.current_applet.call(null).floor(n);\n});\n/**\n * Returns a boolean value representing whether the applet has focus.\n */\nquil.core$macros.focused = (function quil$core$macros$focused(){\nreturn quil.sketch.current_applet.call(null).focused;\n});\n/**\n * The system variable frameCount contains the number of frames\n *   displayed since the program started. Inside setup() the value is 0\n *   and after the first iteration of draw it is 1, etc.\n */\nquil.core$macros.frame_count = (function quil$core$macros$frame_count(){\nreturn quil.sketch.current_applet.call(null).frameCount;\n});\n/**\n * Returns the current framerate\n */\nquil.core$macros.current_frame_rate = (function quil$core$macros$current_frame_rate(){\nreturn quil.sketch.current_applet.call(null).__frameRate;\n});\n/**\n * Specifies a new target framerate (number of frames to be displayed every\n *   second). If the processor is not fast enough to maintain the\n *   specified rate, it will not be achieved. For example, the function\n *   call (frame-rate 30) will attempt to refresh 30 times a second. It\n *   is recommended to set the frame rate within setup. The default rate\n *   is 60 frames per second.\n */\nquil.core$macros.frame_rate = (function quil$core$macros$frame_rate(new_rate){\ncljs.core.reset_BANG_.call(null,quil.sketch.current_applet.call(null).target_frame_rate,new_rate);\n\nreturn quil.sketch.current_applet.call(null).frameRate(new_rate);\n});\n/**\n * Sets a perspective matrix defined through the parameters. Works\n *   like glFrustum, except it wipes out the current perspective matrix\n *   rather than muliplying itself with it.\n */\nquil.core$macros.frustum = (function quil$core$macros$frustum(left,right,bottom,top,near,far){\nreturn quil.core$macros.current_graphics.call(null).frustum(left,right,bottom,top,near,far);\n});\n/**\n * Reads the color of any pixel or grabs a section of an image. If no\n *   parameters are specified, a copy of entire image is returned. Get the\n *   value of one pixel by specifying an x,y coordinate. Get a section of\n *   the image by specifying an additional width and height parameter.\n *   If the pixel requested is outside of the image window, black is returned.\n *   The numbers returned are scaled according to the current color ranges,\n *   but only RGB values are returned by this function. For example, even though\n *   you may have drawn a shape with (color-mode :hsb), the numbers returned\n *   will be in RGB.\n * \n *   Getting the color of a single pixel with (get x y) is easy, but not\n *   as fast as grabbing the data directly using the pixels fn.\n * \n *   If no img specified - current-graphics is used.\n */\nquil.core$macros.get_pixel = (function quil$core$macros$get_pixel(var_args){\nvar args331 = [];\nvar len__3279__auto___334 = arguments.length;\nvar i__3280__auto___335 = (0);\nwhile(true){\nif((i__3280__auto___335 < len__3279__auto___334)){\nargs331.push((arguments[i__3280__auto___335]));\n\nvar G__336 = (i__3280__auto___335 + (1));\ni__3280__auto___335 = G__336;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__333 = args331.length;\nswitch (G__333) {\ncase (0):\nreturn quil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (5):\nreturn quil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args331.length)].join('')));\n\n}\n});\n\nquil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.get_pixel.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$1 = (function (img){\nreturn img.get();\n});\n\nquil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.core$macros.get_pixel.call(null,quil.core$macros.current_graphics.call(null),x,y);\n});\n\nquil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$3 = (function (img,x,y){\nreturn img.get((x | (0)),(y | (0)));\n});\n\nquil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$4 = (function (x,y,w,h){\nreturn quil.core$macros.get_pixel.call(null,quil.core$macros.current_graphics.call(null),x,y,w,h);\n});\n\nquil.core$macros.get_pixel.cljs$core$IFn$_invoke$arity$5 = (function (img,x,y,w,h){\nreturn img.get((x | (0)),(y | (0)),(w | (0)),(h | (0)));\n});\n\nquil.core$macros.get_pixel.cljs$lang$maxFixedArity = (5);\n/**\n * Extracts the green value from a color, scaled to match current\n *   color-mode. This value is always returned as a float so be careful\n *   not to assign it to an int value.\n */\nquil.core$macros.green = (function quil$core$macros$green(col){\nreturn quil.core$macros.current_graphics.call(null).green(cljs.core.unchecked_int.call(null,col));\n});\n/**\n * Converts a byte, char, int, or color to a String containing the\n *   equivalent hexadecimal notation. For example color(0, 102, 153) will\n *   convert to the String \"FF006699\". This function can help make your\n *   geeky debugging sessions much happier. \n */\nquil.core$macros.hex = (function quil$core$macros$hex(var_args){\nvar args338 = [];\nvar len__3279__auto___341 = arguments.length;\nvar i__3280__auto___342 = (0);\nwhile(true){\nif((i__3280__auto___342 < len__3279__auto___341)){\nargs338.push((arguments[i__3280__auto___342]));\n\nvar G__343 = (i__3280__auto___342 + (1));\ni__3280__auto___342 = G__343;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__340 = args338.length;\nswitch (G__340) {\ncase (1):\nreturn quil.core$macros.hex.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.hex.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args338.length)].join('')));\n\n}\n});\n\nquil.core$macros.hex.cljs$core$IFn$_invoke$arity$1 = (function (val){\nreturn quil.sketch.current_applet.call(null).hex(val);\n});\n\nquil.core$macros.hex.cljs$core$IFn$_invoke$arity$2 = (function (val,num_digits){\nreturn quil.sketch.current_applet.call(null).hex(val,num_digits);\n});\n\nquil.core$macros.hex.cljs$lang$maxFixedArity = (2);\n/**\n * Height of the display window. The value of height is zero until\n *   size is called.\n */\nquil.core$macros.height = (function quil$core$macros$height(){\nreturn quil.sketch.current_applet.call(null).height;\n});\n/**\n * Set various hints and hacks for the renderer. This is used to\n *   handle obscure rendering features that cannot be implemented in a\n *   consistent manner across renderers. Many options will often graduate\n *   to standard features instead of hints over time.\n * \n *   Options:\n * \n *   :enable-native-fonts - Use the native version fonts when they are\n *  installed, rather than the bitmapped version from a .vlw\n *  file. This is useful with the default (or JAVA2D) renderer\n *  setting, as it will improve font rendering speed. This is not\n *  enabled by default, because it can be misleading while testing\n *  because the type will look great on your machine (because you have\n *  the font installed) but lousy on others' machines if the identical\n *  font is unavailable. This option can only be set per-sketch, and\n *  must be called before any use of text-font.\n * \n *   :disable-native-fonts - Disables native font support.\n * \n *   :disable-depth-test - Disable the zbuffer, allowing you to draw on\n *  top of everything at will. When depth testing is disabled, items\n *  will be drawn to the screen sequentially, like a painting. This\n *  hint is most often used to draw in 3D, then draw in 2D on top of\n *  it (for instance, to draw GUI controls in 2D on top of a 3D\n *  interface). Starting in release 0149, this will also clear the\n *  depth buffer. Restore the default with :enable-depth-test\n *  but note that with the depth buffer cleared, any 3D drawing that\n *  happens later in draw will ignore existing shapes on the screen.\n * \n *   :enable-depth-test - Enables the zbuffer.\n * \n *   :enable-depth-sort - Enable primitive z-sorting of triangles and\n *  lines in :p3d and :opengl rendering modes. This can slow\n *  performance considerably, and the algorithm is not yet perfect.\n * \n *   :disable-depth-sort - Disables hint :enable-depth-sort\n * \n *   :disable-opengl-errors - Speeds up the OPENGL renderer setting\n *   by not checking for errors while running.\n * \n *   :enable-opengl-errors - Turns on OpenGL error checking\n * \n *   :enable-depth-mask\n *   :disable-depth-mask\n * \n *   :enable-optimized-stroke\n *   :disable-optimized-stroke\n *   :enable-retina-pixels\n *   :disable-retina-pixels\n *   :enable-stroke-perspective\n *   :disable-stroke-perspective\n *   :enable-stroke-pure\n *   :disable-stroke-pure\n *   :enable-texture-mipmaps\n *   :disable-texture-mipmaps\n */\nquil.core$macros.hint = (function quil$core$macros$hint(hint_type){\nvar hint_type__$1 = (((hint_type instanceof cljs.core.Keyword))?cljs.core.get.call(null,quil.core$macros.hint_options,hint_type):hint_type);\nreturn quil.core$macros.current_graphics.call(null).hint((hint_type__$1 | (0)));\n});\n/**\n * Returns the current hour as a value from 0 - 23.\n */\nquil.core$macros.hour = (function quil$core$macros$hour(){\nreturn quil.sketch.current_applet.call(null).hour();\n});\n/**\n * Extracts the hue value from a color.\n */\nquil.core$macros.hue = (function quil$core$macros$hue(col){\nreturn quil.core$macros.current_graphics.call(null).hue(cljs.core.unchecked_int.call(null,col));\n});\n/**\n * Displays images to the screen. Processing currently works with GIF,\n *   JPEG, and Targa images. The color of an image may be modified with\n *   the tint function and if a GIF has transparency, it will maintain\n *   its transparency. The img parameter specifies the image to display\n *   and the x and y parameters define the location of the image from its\n *   upper-left corner. The image is displayed at its original size\n *   unless the width and height parameters specify a different size. The\n *   image-mode fn changes the way the parameters work. A call to\n *   (image-mode :corners) will change the width and height parameters to\n *   define the x and y values of the opposite corner of the image.\n * \n *   Starting with release 0124, when using the default (JAVA2D)\n *   renderer, smooth will also improve image quality of resized\n *   images.\n */\nquil.core$macros.image = (function quil$core$macros$image(var_args){\nvar args345 = [];\nvar len__3279__auto___348 = arguments.length;\nvar i__3280__auto___349 = (0);\nwhile(true){\nif((i__3280__auto___349 < len__3279__auto___348)){\nargs345.push((arguments[i__3280__auto___349]));\n\nvar G__350 = (i__3280__auto___349 + (1));\ni__3280__auto___349 = G__350;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__347 = args345.length;\nswitch (G__347) {\ncase (3):\nreturn quil.core$macros.image.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (5):\nreturn quil.core$macros.image.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args345.length)].join('')));\n\n}\n});\n\nquil.core$macros.image.cljs$core$IFn$_invoke$arity$3 = (function (img,x,y){\nreturn quil.core$macros.current_graphics.call(null).image(img,x,y);\n});\n\nquil.core$macros.image.cljs$core$IFn$_invoke$arity$5 = (function (img,x,y,c,d){\nreturn quil.core$macros.current_graphics.call(null).image(img,x,y,c,d);\n});\n\nquil.core$macros.image.cljs$lang$maxFixedArity = (5);\n/**\n * Originally named filter in Processing Language.\n *   Filters given image with the specified mode and level.\n *   Level defines the quality of the filter and mode may be one of\n *   the following keywords:\n * \n *   :threshold - converts the image to black and white pixels depending\n *             if they are above or below the threshold defined by\n *             the level parameter. The level must be between\n *             0.0 (black) and 1.0 (white). If no level is specified,\n *             0.5 is used.\n *   :gray      - converts any colors in the image to grayscale\n *             equivalents. Doesn't work with level.\n *   :invert    - sets each pixel to its inverse value. Doesn't work with\n *             level.\n *   :posterize - limits each channel of the image to the number of\n *             colors specified as the level parameter. The parameter can\n *             be set to values between 2 and 255, but results are most\n *             noticeable in the lower ranges.\n *   :blur      - executes a Guassian blur with the level parameter\n *             specifying the extent of the blurring. If no level\n *             parameter is used, the blur is equivalent to Guassian\n *             blur of radius 1.\n *   :opaque    - sets the alpha channel to entirely opaque. Doesn't work\n *             with level.\n *   :erode     - reduces the light areas. Doesn't work with level.\n *   :dilate    - increases the light areas.  Doesn't work with level.\n */\nquil.core$macros.image_filter = (function quil$core$macros$image_filter(var_args){\nvar args352 = [];\nvar len__3279__auto___355 = arguments.length;\nvar i__3280__auto___356 = (0);\nwhile(true){\nif((i__3280__auto___356 < len__3279__auto___355)){\nargs352.push((arguments[i__3280__auto___356]));\n\nvar G__357 = (i__3280__auto___356 + (1));\ni__3280__auto___356 = G__357;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__354 = args352.length;\nswitch (G__354) {\ncase (2):\nreturn quil.core$macros.image_filter.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.image_filter.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args352.length)].join('')));\n\n}\n});\n\nquil.core$macros.image_filter.cljs$core$IFn$_invoke$arity$2 = (function (img,mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.filter_modes);\nreturn img.filter((mode__$1 | (0)));\n});\n\nquil.core$macros.image_filter.cljs$core$IFn$_invoke$arity$3 = (function (img,mode,level){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.filter_modes);\nreturn img.filter((mode__$1 | (0)),level);\n});\n\nquil.core$macros.image_filter.cljs$lang$maxFixedArity = (3);\n/**\n * Modifies the location from which images draw. The default mode is :corner.\n * Available modes are:\n * \n *   :corner  - specifies the location to be the upper left corner and\n *           uses the fourth and fifth parameters of image to set the\n *           image's width and height.\n * \n *   :corners - uses the second and third parameters of image to set the\n *           location of one corner of the image and uses the fourth\n *           and fifth parameters to set the opposite corner.\n * \n *   :center  - draw images centered at the given x and y position.\n */\nquil.core$macros.image_mode = (function quil$core$macros$image_mode(mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.image_modes);\nreturn quil.core$macros.current_graphics.call(null).imageMode((mode__$1 | (0)));\n});\n/**\n * The variable keyCode is used to detect special keys such as the UP,\n *   DOWN, LEFT, RIGHT arrow keys and ALT, CONTROL, SHIFT. When checking\n *   for these keys, it's first necessary to check and see if the key is\n *   coded. This is done with the conditional (= (key) CODED).\n * \n *   The keys included in the ASCII specification (BACKSPACE, TAB, ENTER,\n *   RETURN, ESC, and DELETE) do not require checking to see if they key\n *   is coded, and you should simply use the key variable instead of\n *   key-code If you're making cross-platform projects, note that the\n *   ENTER key is commonly used on PCs and Unix and the RETURN key is\n *   used instead on Macintosh. Check for both ENTER and RETURN to make\n *   sure your program will work for all platforms.\n * \n *   For users familiar with Java, the values for UP and DOWN are simply\n *   shorter versions of Java's KeyEvent.VK_UP and\n *   KeyEvent.VK_DOWN. Other keyCode values can be found in the Java\n *   KeyEvent reference.\n */\nquil.core$macros.key_code = (function quil$core$macros$key_code(){\nreturn quil.sketch.current_applet.call(null).keyCode;\n});\n/**\n * true if any key is currently pressed, false otherwise.\n */\nquil.core$macros.key_pressed_QMARK_ = (function quil$core$macros$key_pressed_QMARK_(){\nreturn quil.sketch.current_applet.call(null).keyPressed;\n});\n/**\n * Sets the falloff rates for point lights, spot lights, and ambient\n *   lights. The parameters are used to determine the falloff with the\n *   following equation:\n * \n *   d = distance from light position to vertex position\n *   falloff = 1 / (CONSTANT + d * LINEAR + (d*d) * QUADRATIC)\n * \n *   Like fill, it affects only the elements which are created after it\n *   in the code. The default value is (light-falloff 1.0 0.0 0.0).\n *   Thinking about an ambient light with a falloff can be tricky. It is\n *   used, for example, if you wanted a region of your scene to be lit\n *   ambiently one color and another region to be lit ambiently by\n *   another color, you would use an ambient light with location and\n *   falloff. You can think of it as a point light that doesn't care\n *   which direction a surface is facing.\n */\nquil.core$macros.light_falloff = (function quil$core$macros$light_falloff(constant,linear,quadratic){\nreturn quil.core$macros.current_graphics.call(null).lightFalloff(constant,linear,quadratic);\n});\n/**\n * Calculates a color or colors between two color at a specific\n *   increment. The amt parameter is the amount to interpolate between\n *   the two values where 0.0 equal to the first point, 0.1 is very near\n *   the first point, 0.5 is half-way in between, etc.\n */\nquil.core$macros.lerp_color = (function quil$core$macros$lerp_color(c1,c2,amt){\nreturn quil.core$macros.current_graphics.call(null).lerpColor(cljs.core.unchecked_int.call(null,c1),cljs.core.unchecked_int.call(null,c2),amt);\n});\n/**\n * Calculates a number between two numbers at a specific\n *   increment. The amt parameter is the amount to interpolate between\n *   the two values where 0.0 equal to the first point, 0.1 is very near\n *   the first point, 0.5 is half-way in between, etc. The lerp function\n *   is convenient for creating motion along a straight path and for\n *   drawing dotted lines.\n */\nquil.core$macros.lerp = (function quil$core$macros$lerp(start,stop,amt){\nreturn quil.sketch.current_applet.call(null).lerp(start,stop,amt);\n});\n/**\n * Sets the default ambient light, directional light, falloff, and\n *   specular values. The defaults are:\n * \n *   (ambient-light 128 128 128)\n *   (directional-light 128 128 128 0 0 -1)\n *   (light-falloff 1 0 0)\n *   (light-specular 0 0 0).\n * \n *   Lights need to be included in the draw to remain persistent in a\n *   looping program. Placing them in the setup of a looping program\n *   will cause them to only have an effect the first time through the\n *   loop.\n */\nquil.core$macros.lights = (function quil$core$macros$lights(){\nreturn quil.core$macros.current_graphics.call(null).lights();\n});\n/**\n * Sets the specular color for lights. Like fill, it affects only the\n *   elements which are created after it in the code. Specular refers to\n *   light which bounces off a surface in a perferred direction (rather\n *   than bouncing in all directions like a diffuse light) and is used\n *   for creating highlights. The specular quality of a light interacts\n *   with the specular material qualities set through the specular and\n *   shininess functions.\n */\nquil.core$macros.light_specular = (function quil$core$macros$light_specular(r,g,b){\nreturn quil.core$macros.current_graphics.call(null).lightSpecular(r,g,b);\n});\n/**\n * Draws a line (a direct path between two points) to the screen. The\n *   version of line with four parameters draws the line in 2D. To color\n *   a line, use the stroke function. A line cannot be filled, therefore\n *   the fill method will not affect the color of a line. 2D lines are\n *   drawn with a width of one pixel by default, but this can be changed\n *   with the stroke-weight function. The version with six parameters\n *   allows the line to be placed anywhere within XYZ space. \n */\nquil.core$macros.line = (function quil$core$macros$line(var_args){\nvar args359 = [];\nvar len__3279__auto___362 = arguments.length;\nvar i__3280__auto___363 = (0);\nwhile(true){\nif((i__3280__auto___363 < len__3279__auto___362)){\nargs359.push((arguments[i__3280__auto___363]));\n\nvar G__364 = (i__3280__auto___363 + (1));\ni__3280__auto___363 = G__364;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__361 = args359.length;\nswitch (G__361) {\ncase (2):\nreturn quil.core$macros.line.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.line.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (6):\nreturn quil.core$macros.line.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args359.length)].join('')));\n\n}\n});\n\nquil.core$macros.line.cljs$core$IFn$_invoke$arity$2 = (function (p1,p2){\nreturn cljs.core.apply.call(null,quil.core$macros.line,cljs.core.concat.call(null,p1,p2));\n});\n\nquil.core$macros.line.cljs$core$IFn$_invoke$arity$4 = (function (x1,y1,x2,y2){\nreturn quil.core$macros.current_graphics.call(null).line(x1,y1,x2,y2);\n});\n\nquil.core$macros.line.cljs$core$IFn$_invoke$arity$6 = (function (x1,y1,z1,x2,y2,z2){\nreturn quil.core$macros.current_graphics.call(null).line(x1,y1,z1,x2,y2,z2);\n});\n\nquil.core$macros.line.cljs$lang$maxFixedArity = (6);\n/**\n * Loads a font into a variable of type PFont. To load correctly,\n *   fonts must be located in the data directory of the current sketch.\n *   To create a font to use with Processing use the create-font fn.\n * \n *   Like load-image and other methods that load data, the load-font fn\n *   should not be used inside draw, because it will slow down the sketch\n *   considerably, as the font will be re-loaded from the disk (or\n *   network) on each frame.\n * \n *   For most renderers, Processing displays fonts using the .vlw font\n *   format, which uses images for each letter, rather than defining them\n *   through vector data. When hint :enable-native-fonts is used with the\n *   JAVA2D renderer, the native version of a font will be used if it is\n *   installed on the user's machine.\n * \n *   Using create-font (instead of load-font) enables vector data to be\n *   used with the JAVA2D (default) renderer setting. This can be helpful\n *   when many font sizes are needed, or when using any renderer based on\n *   JAVA2D, such as the PDF library.\n */\nquil.core$macros.load_font = (function quil$core$macros$load_font(filename){\nreturn quil.sketch.current_applet.call(null).loadFont([cljs.core.str(filename)].join(''));\n});\n/**\n * Loads an image into a variable of type PImage. Four types of\n *   images ( .gif, .jpg, .tga, .png) images may be loaded. To load\n *   correctly, images must be located in the data directory of the\n *   current sketch. In most cases, load all images in setup to preload\n *   them at the start of the program. Loading images inside draw will\n *   reduce the speed of a program.\n * \n *   The filename parameter can also be a URL to a file found online.\n * \n *   If an image is not loaded successfully, the null value is returned\n *   and an error message will be printed to the console. The error\n *   message does not halt the program, however the null value may cause\n *   a NullPointerException if your code does not check whether the value\n *   returned from load-image is nil.\n * \n *   Depending on the type of error, a PImage object may still be\n *   returned, but the width and height of the image will be set to\n *   -1. This happens if bad image data is returned or cannot be decoded\n *   properly. Sometimes this happens with image URLs that produce a 403\n *   error or that redirect to a password prompt, because load-image\n *   will attempt to interpret the HTML as image data.\n */\nquil.core$macros.load_image = (function quil$core$macros$load_image(filename){\nreturn quil.sketch.current_applet.call(null).loadImage([cljs.core.str(filename)].join(''));\n});\n/**\n * Loads a shader into the PShader object. Shaders are compatible with the\n *   P2D and P3D renderers, but not with the default renderer.\n */\nquil.core$macros.load_shader = (function quil$core$macros$load_shader(var_args){\nvar args366 = [];\nvar len__3279__auto___369 = arguments.length;\nvar i__3280__auto___370 = (0);\nwhile(true){\nif((i__3280__auto___370 < len__3279__auto___369)){\nargs366.push((arguments[i__3280__auto___370]));\n\nvar G__371 = (i__3280__auto___370 + (1));\ni__3280__auto___370 = G__371;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__368 = args366.length;\nswitch (G__368) {\ncase (1):\nreturn quil.core$macros.load_shader.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.load_shader.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args366.length)].join('')));\n\n}\n});\n\nquil.core$macros.load_shader.cljs$core$IFn$_invoke$arity$1 = (function (fragment_filename){\nreturn quil.core$macros.current_graphics.call(null).loadShader(fragment_filename);\n});\n\nquil.core$macros.load_shader.cljs$core$IFn$_invoke$arity$2 = (function (fragment_filename,vertex_filename){\nreturn quil.core$macros.current_graphics.call(null).loadShader(fragment_filename,vertex_filename);\n});\n\nquil.core$macros.load_shader.cljs$lang$maxFixedArity = (2);\n/**\n * Load a geometry from a file as a PShape.\n */\nquil.core$macros.load_shape = (function quil$core$macros$load_shape(filename){\nreturn quil.sketch.current_applet.call(null).loadShape(filename);\n});\n/**\n * Calculates the natural logarithm (the base-e logarithm) of a\n *   number. This function expects the values greater than 0.0.\n */\nquil.core$macros.log = (function quil$core$macros$log(val){\nreturn quil.sketch.current_applet.call(null).log(val);\n});\n/**\n * Calculates the magnitude (or length) of a vector. A vector is a\n *   direction in space commonly used in computer graphics and linear\n *   algebra. Because it has no start position, the magnitude of a vector\n *   can be thought of as the distance from coordinate (0,0) to its (x,y)\n *   value. Therefore, mag is a shortcut for writing (dist 0 0 x y).\n */\nquil.core$macros.mag = (function quil$core$macros$mag(var_args){\nvar args373 = [];\nvar len__3279__auto___376 = arguments.length;\nvar i__3280__auto___377 = (0);\nwhile(true){\nif((i__3280__auto___377 < len__3279__auto___376)){\nargs373.push((arguments[i__3280__auto___377]));\n\nvar G__378 = (i__3280__auto___377 + (1));\ni__3280__auto___377 = G__378;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__375 = args373.length;\nswitch (G__375) {\ncase (2):\nreturn quil.core$macros.mag.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.mag.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args373.length)].join('')));\n\n}\n});\n\nquil.core$macros.mag.cljs$core$IFn$_invoke$arity$2 = (function (a,b){\nreturn quil.sketch.current_applet.call(null).mag(a,b);\n});\n\nquil.core$macros.mag.cljs$core$IFn$_invoke$arity$3 = (function (a,b,c){\nreturn quil.sketch.current_applet.call(null).mag(a,b,c);\n});\n\nquil.core$macros.mag.cljs$lang$maxFixedArity = (3);\n/**\n * Re-maps a number from one range to another.\n * \n *   Numbers outside the range are not clamped to 0 and 1, because\n *   out-of-range values are often intentional and useful.\n */\nquil.core$macros.map_range = (function quil$core$macros$map_range(val,low1,high1,low2,high2){\nreturn quil.sketch.current_applet.call(null).map(val,low1,high1,low2,high2);\n});\n/**\n * Returns the number of milliseconds (thousandths of a second) since\n *   starting the sketch. This information is often used for timing\n *   animation sequences.\n */\nquil.core$macros.millis = (function quil$core$macros$millis(){\nreturn quil.sketch.current_applet.call(null).millis();\n});\n/**\n * Returns the current minute as a value from 0 - 59\n */\nquil.core$macros.minute = (function quil$core$macros$minute(){\nreturn quil.sketch.current_applet.call(null).minute();\n});\n/**\n * Returns the three-dimensional x, y, z position in model space. This\n *   returns the x value for a given coordinate based on the current set\n *   of transformations (scale, rotate, translate, etc.) The x value can\n *   be used to place an object in space relative to the location of the\n *   original point once the transformations are no longer in use.\n */\nquil.core$macros.model_x = (function quil$core$macros$model_x(x,y,z){\nreturn quil.core$macros.current_graphics.call(null).modelX(x,y,z);\n});\n/**\n * Returns the three-dimensional x, y, z position in model space. This\n *   returns the y value for a given coordinate based on the current set\n *   of transformations (scale, rotate, translate, etc.) The y value can\n *   be used to place an object in space relative to the location of the\n *   original point once the transformations are no longer in use.\n */\nquil.core$macros.model_y = (function quil$core$macros$model_y(x,y,z){\nreturn quil.core$macros.current_graphics.call(null).modelY(x,y,z);\n});\n/**\n * Returns the three-dimensional x, y, z position in model space. This\n *   returns the z value for a given coordinate based on the current set\n *   of transformations (scale, rotate, translate, etc.) The z value can\n *   be used to place an object in space relative to the location of the\n *   original point once the transformations are no longer in use.\n */\nquil.core$macros.model_z = (function quil$core$macros$model_z(x,y,z){\nreturn quil.core$macros.current_graphics.call(null).modelZ(x,y,z);\n});\n/**\n * Returns the current month as a value from 1 - 12.\n */\nquil.core$macros.month = (function quil$core$macros$month(){\nreturn quil.sketch.current_applet.call(null).month();\n});\n/**\n * The value of the system variable mouseButton is either :left, :right,\n *   or :center depending on which button is pressed. nil if no button pressed\n */\nquil.core$macros.mouse_button = (function quil$core$macros$mouse_button(){\nvar button_code = quil.sketch.current_applet.call(null).mouseButton;\nvar pred__383 = cljs.core._EQ_;\nvar expr__384 = button_code;\nif(cljs.core.truth_(pred__383.call(null,(37),expr__384))){\nreturn new cljs.core.Keyword(null,\"left\",\"left\",(-399115937));\n} else {\nif(cljs.core.truth_(pred__383.call(null,(39),expr__384))){\nreturn new cljs.core.Keyword(null,\"right\",\"right\",(-452581833));\n} else {\nif(cljs.core.truth_(pred__383.call(null,(3),expr__384))){\nreturn new cljs.core.Keyword(null,\"center\",\"center\",(-748944368));\n} else {\nreturn null;\n}\n}\n}\n});\n/**\n * Variable storing if a mouse button is pressed. The value of the\n *   system variable mousePressed is true if a mouse button is pressed\n *   and false if a button is not pressed.\n */\nquil.core$macros.mouse_pressed_QMARK_ = (function quil$core$macros$mouse_pressed_QMARK_(){\nreturn quil.sketch.current_applet.call(null).mousePressed;\n});\n/**\n * Current horizontal coordinate of the mouse.\n */\nquil.core$macros.mouse_x = (function quil$core$macros$mouse_x(){\nreturn quil.sketch.current_applet.call(null).mouseX;\n});\n/**\n * Current vertical coordinate of the mouse.\n */\nquil.core$macros.mouse_y = (function quil$core$macros$mouse_y(){\nreturn quil.sketch.current_applet.call(null).mouseY;\n});\n/**\n * Hides the cursor from view. Will not work when running the in full\n *   screen (Present) mode.\n */\nquil.core$macros.no_cursor = (function quil$core$macros$no_cursor(){\nreturn quil.sketch.current_applet.call(null).noCursor();\n});\n/**\n * Disables filling geometry. If both no-stroke and no-fill are called,\n *   nothing will be drawn to the screen.\n */\nquil.core$macros.no_fill = (function quil$core$macros$no_fill(){\nquil.core$macros.current_graphics.call(null).noFill();\n\nreturn (quil.core$macros.current_graphics.call(null)[quil.core$macros.no_fill_prop] = true);\n});\n/**\n * Returns the Perlin noise value at specified coordinates. Perlin\n *   noise is a random sequence generator producing a more natural\n *   ordered, harmonic succession of numbers compared to the standard\n *   random function. It was invented by Ken Perlin in the 1980s and\n *   been used since in graphical applications to produce procedural\n *   textures, natural motion, shapes, terrains etc.\n * \n *   The main difference to the random function is that Perlin noise is\n *   defined in an infinite n-dimensional space where each pair of\n *   coordinates corresponds to a fixed semi-random value (fixed only for\n *   the lifespan of the program). The resulting value will always be\n *   between 0.0 and 1.0. Processing can compute 1D, 2D and 3D noise,\n *   depending on the number of coordinates given. The noise value can be\n *   animated by moving through the noise space and the 2nd and 3rd\n *   dimensions can also be interpreted as time.\n * \n *   The actual noise is structured similar to an audio signal, in\n *   respect to the function's use of frequencies. Similar to the concept\n *   of harmonics in physics, perlin noise is computed over several\n *   octaves which are added together for the final result.\n * \n *   Another way to adjust the character of the resulting sequence is the\n *   scale of the input coordinates. As the function works within an\n *   infinite space the value of the coordinates doesn't matter as such,\n *   only the distance between successive coordinates does (eg. when\n *   using noise within a loop). As a general rule the smaller the\n *   difference between coordinates, the smoother the resulting noise\n *   sequence will be. Steps of 0.005-0.03 work best for most\n *   applications, but this will differ depending on use.\n */\nquil.core$macros.noise = (function quil$core$macros$noise(var_args){\nvar args386 = [];\nvar len__3279__auto___389 = arguments.length;\nvar i__3280__auto___390 = (0);\nwhile(true){\nif((i__3280__auto___390 < len__3279__auto___389)){\nargs386.push((arguments[i__3280__auto___390]));\n\nvar G__391 = (i__3280__auto___390 + (1));\ni__3280__auto___390 = G__391;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__388 = args386.length;\nswitch (G__388) {\ncase (1):\nreturn quil.core$macros.noise.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.noise.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.noise.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args386.length)].join('')));\n\n}\n});\n\nquil.core$macros.noise.cljs$core$IFn$_invoke$arity$1 = (function (x){\nreturn quil.sketch.current_applet.call(null).noise(x);\n});\n\nquil.core$macros.noise.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.sketch.current_applet.call(null).noise(x,y);\n});\n\nquil.core$macros.noise.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.sketch.current_applet.call(null).noise(x,y,z);\n});\n\nquil.core$macros.noise.cljs$lang$maxFixedArity = (3);\n/**\n * Adjusts the character and level of detail produced by the Perlin\n *   noise function. Similar to harmonics in physics, noise is computed\n *   over several octaves. Lower octaves contribute more to the output\n *   signal and as such define the overal intensity of the noise, whereas\n *   higher octaves create finer grained details in the noise\n *   sequence. By default, noise is computed over 4 octaves with each\n *   octave contributing exactly half than its predecessor, starting at\n *   50% strength for the 1st octave. This falloff amount can be changed\n *   by adding an additional function parameter. Eg. a falloff factor of\n *   0.75 means each octave will now have 75% impact (25% less) of the\n *   previous lower octave. Any value between 0.0 and 1.0 is valid,\n *   however note that values greater than 0.5 might result in greater\n *   than 1.0 values returned by noise.\n * \n *   By changing these parameters, the signal created by the noise\n *   function can be adapted to fit very specific needs and\n *   characteristics.\n */\nquil.core$macros.noise_detail = (function quil$core$macros$noise_detail(var_args){\nvar args393 = [];\nvar len__3279__auto___396 = arguments.length;\nvar i__3280__auto___397 = (0);\nwhile(true){\nif((i__3280__auto___397 < len__3279__auto___396)){\nargs393.push((arguments[i__3280__auto___397]));\n\nvar G__398 = (i__3280__auto___397 + (1));\ni__3280__auto___397 = G__398;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__395 = args393.length;\nswitch (G__395) {\ncase (1):\nreturn quil.core$macros.noise_detail.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.noise_detail.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args393.length)].join('')));\n\n}\n});\n\nquil.core$macros.noise_detail.cljs$core$IFn$_invoke$arity$1 = (function (octaves){\nreturn quil.sketch.current_applet.call(null).noiseDetail((octaves | (0)));\n});\n\nquil.core$macros.noise_detail.cljs$core$IFn$_invoke$arity$2 = (function (octaves,falloff){\nreturn quil.sketch.current_applet.call(null).noiseDetail((octaves | (0)),falloff);\n});\n\nquil.core$macros.noise_detail.cljs$lang$maxFixedArity = (2);\n/**\n * Sets the seed value for noise. By default, noise produces different\n *   results each time the program is run. Set the value parameter to a\n *   constant to return the same pseudo-random numbers each time the\n *   software is run.\n */\nquil.core$macros.noise_seed = (function quil$core$macros$noise_seed(val){\nreturn quil.sketch.current_applet.call(null).noiseSeed((val | (0)));\n});\n/**\n * Disable all lighting. Lighting is turned off by default and enabled\n *   with the lights fn. This function can be used to disable lighting so\n *   that 2D geometry (which does not require lighting) can be drawn\n *   after a set of lighted 3D geometry.\n */\nquil.core$macros.no_lights = (function quil$core$macros$no_lights(){\nreturn quil.core$macros.current_graphics.call(null).noLights();\n});\n/**\n * Stops Processing from continuously executing the code within\n *   draw. If start-loop is called, the code in draw will begin to run\n *   continuously again. If using no-loop in setup, it should be the last\n *   line inside the block.\n * \n *   When no-loop is used, it's not possible to manipulate or access the\n *   screen inside event handling functions such as mouse-pressed or\n *   key-pressed. Instead, use those functions to call redraw or\n *   loop which will run draw, which can update the screen\n *   properly. This means that when no-loop has been called, no drawing\n *   can happen, and functions like save-frame may not be used.\n * \n *   Note that if the sketch is resized, redraw will be called to\n *   update the sketch, even after no-oop has been\n *   specified. Otherwise, the sketch would enter an odd state until\n *   loop was called.\n */\nquil.core$macros.no_loop = (function quil$core$macros$no_loop(){\nreturn quil.sketch.current_applet.call(null).noLoop();\n});\n/**\n * Normalize a value to exist between 0 and 1 (inclusive).\n */\nquil.core$macros.norm = (function quil$core$macros$norm(val,start,stop){\nreturn quil.sketch.current_applet.call(null).norm(val,start,stop);\n});\n/**\n * Sets the current normal vector. This is for drawing three\n *   dimensional shapes and surfaces and specifies a vector perpendicular\n *   to the surface of the shape which determines how lighting affects\n *   it. Processing attempts to automatically assign normals to shapes,\n *   but since that's imperfect, this is a better option when you want\n *   more control. This function is identical to glNormal3f() in OpenGL.\n */\nquil.core$macros.normal = (function quil$core$macros$normal(nx,ny,nz){\nreturn quil.core$macros.current_graphics.call(null).normal(nx,ny,nz);\n});\n/**\n * Draws all geometry with jagged (aliased) edges. Must be called inside\n *   :settings handler.\n */\nquil.core$macros.no_smooth = (function quil$core$macros$no_smooth(){\nreturn quil.core$macros.current_graphics.call(null).noSmooth();\n});\n/**\n * Disables drawing the stroke (outline). If both no-stroke and\n *   no-fill are called, nothing will be drawn to the screen.\n */\nquil.core$macros.no_stroke = (function quil$core$macros$no_stroke(){\nreturn quil.core$macros.current_graphics.call(null).noStroke();\n});\n/**\n * Removes the current fill value for displaying images and reverts to\n *   displaying images with their original hues.\n */\nquil.core$macros.no_tint = (function quil$core$macros$no_tint(){\nreturn quil.core$macros.current_graphics.call(null).noTint();\n});\n/**\n * Sets an orthographic projection and defines a parallel clipping\n *   volume. All objects with the same dimension appear the same size,\n *   regardless of whether they are near or far from the camera. The\n *   parameters to this function specify the clipping volume where left\n *   and right are the minimum and maximum x values, top and bottom are\n *   the minimum and maximum y values, and near and far are the minimum\n *   and maximum z values. If no parameters are given, the default is\n *   used: (ortho 0 width 0 height -10 10)\n */\nquil.core$macros.ortho = (function quil$core$macros$ortho(var_args){\nvar args400 = [];\nvar len__3279__auto___403 = arguments.length;\nvar i__3280__auto___404 = (0);\nwhile(true){\nif((i__3280__auto___404 < len__3279__auto___403)){\nargs400.push((arguments[i__3280__auto___404]));\n\nvar G__405 = (i__3280__auto___404 + (1));\ni__3280__auto___404 = G__405;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__402 = args400.length;\nswitch (G__402) {\ncase (0):\nreturn quil.core$macros.ortho.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (4):\nreturn quil.core$macros.ortho.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (6):\nreturn quil.core$macros.ortho.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args400.length)].join('')));\n\n}\n});\n\nquil.core$macros.ortho.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.current_graphics.call(null).ortho();\n});\n\nquil.core$macros.ortho.cljs$core$IFn$_invoke$arity$4 = (function (left,right,bottom,top){\nreturn quil.core$macros.current_graphics.call(null).ortho(left,right,bottom,top);\n});\n\nquil.core$macros.ortho.cljs$core$IFn$_invoke$arity$6 = (function (left,right,bottom,top,near,far){\nreturn quil.core$macros.current_graphics.call(null).ortho(left,right,bottom,top,near,far);\n});\n\nquil.core$macros.ortho.cljs$lang$maxFixedArity = (6);\n/**\n * Sets a perspective projection applying foreshortening, making\n *   distant objects appear smaller than closer ones. The parameters\n *   define a viewing volume with the shape of truncated pyramid. Objects\n *   near to the front of the volume appear their actual size, while\n *   farther objects appear smaller. This projection simulates the\n *   perspective of the world more accurately than orthographic\n *   projection. The version of perspective without parameters sets the\n *   default perspective and the version with four parameters allows the\n *   programmer to set the area precisely. The default values are:\n *   perspective(PI/3.0, width/height, cameraZ/10.0, cameraZ*10.0) where\n *   cameraZ is ((height/2.0) / tan(PI*60.0/360.0));\n */\nquil.core$macros.perspective = (function quil$core$macros$perspective(var_args){\nvar args407 = [];\nvar len__3279__auto___410 = arguments.length;\nvar i__3280__auto___411 = (0);\nwhile(true){\nif((i__3280__auto___411 < len__3279__auto___410)){\nargs407.push((arguments[i__3280__auto___411]));\n\nvar G__412 = (i__3280__auto___411 + (1));\ni__3280__auto___411 = G__412;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__409 = args407.length;\nswitch (G__409) {\ncase (0):\nreturn quil.core$macros.perspective.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (4):\nreturn quil.core$macros.perspective.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args407.length)].join('')));\n\n}\n});\n\nquil.core$macros.perspective.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.current_graphics.call(null).perspective();\n});\n\nquil.core$macros.perspective.cljs$core$IFn$_invoke$arity$4 = (function (fovy,aspect,z_near,z_far){\nreturn quil.core$macros.current_graphics.call(null).perspective(fovy,aspect,z_near,z_far);\n});\n\nquil.core$macros.perspective.cljs$lang$maxFixedArity = (4);\n/**\n * Array containing the values for all the pixels in the display\n *   window or image. This array is therefore the size of the display window. If\n *   this array is modified, the update-pixels fn must be called to update\n *   the changes. Calls .loadPixels before obtaining the pixel array.\n */\nquil.core$macros.pixels = (function quil$core$macros$pixels(var_args){\nvar args414 = [];\nvar len__3279__auto___417 = arguments.length;\nvar i__3280__auto___418 = (0);\nwhile(true){\nif((i__3280__auto___418 < len__3279__auto___417)){\nargs414.push((arguments[i__3280__auto___418]));\n\nvar G__419 = (i__3280__auto___418 + (1));\ni__3280__auto___418 = G__419;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__416 = args414.length;\nswitch (G__416) {\ncase (0):\nreturn quil.core$macros.pixels.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.pixels.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args414.length)].join('')));\n\n}\n});\n\nquil.core$macros.pixels.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.pixels.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.pixels.cljs$core$IFn$_invoke$arity$1 = (function (img){\nimg.loadPixels();\n\nvar pix_array = img.pixels.toArray();\nimg.stored_pix_array = pix_array;\n\nreturn pix_array;\n});\n\nquil.core$macros.pixels.cljs$lang$maxFixedArity = (1);\n/**\n * Horizontal coordinate of the mouse in the previous frame\n */\nquil.core$macros.pmouse_x = (function quil$core$macros$pmouse_x(){\nreturn quil.sketch.current_applet.call(null).pmouseX;\n});\n/**\n * Vertical coordinate of the mouse in the previous frame\n */\nquil.core$macros.pmouse_y = (function quil$core$macros$pmouse_y(){\nreturn quil.sketch.current_applet.call(null).pmouseY;\n});\n/**\n * Draws a point, a coordinate in space at the dimension of one\n *   pixel. The first parameter is the horizontal value for the point,\n *   the second value is the vertical value for the point, and the\n *   optional third value is the depth value. Drawing this shape in 3D\n *   using the z parameter requires the :P3D or :opengl renderer to be\n *   used.\n */\nquil.core$macros.point = (function quil$core$macros$point(var_args){\nvar args421 = [];\nvar len__3279__auto___424 = arguments.length;\nvar i__3280__auto___425 = (0);\nwhile(true){\nif((i__3280__auto___425 < len__3279__auto___424)){\nargs421.push((arguments[i__3280__auto___425]));\n\nvar G__426 = (i__3280__auto___425 + (1));\ni__3280__auto___425 = G__426;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__423 = args421.length;\nswitch (G__423) {\ncase (2):\nreturn quil.core$macros.point.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.point.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args421.length)].join('')));\n\n}\n});\n\nquil.core$macros.point.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.core$macros.current_graphics.call(null).point(x,y);\n});\n\nquil.core$macros.point.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.current_graphics.call(null).point(x,y,z);\n});\n\nquil.core$macros.point.cljs$lang$maxFixedArity = (3);\n/**\n * Adds a point light. Lights need to be included in the draw() to\n *   remain persistent in a looping program. Placing them in the setup()\n *   of a looping program will cause them to only have an effect the\n *   first time through the loop. The affect of the r, g, and b\n *   parameters is determined by the current color mode. The x, y, and z\n *   parameters set the position of the light\n */\nquil.core$macros.point_light = (function quil$core$macros$point_light(r,g,b,x,y,z){\nreturn quil.core$macros.current_graphics.call(null).pointLight(r,g,b,x,y,z);\n});\n/**\n * Pops the current transformation matrix off the matrix\n *   stack. Understanding pushing and popping requires understanding the\n *   concept of a matrix stack. The push-matrix fn saves the current\n *   coordinate system to the stack and pop-matrix restores the prior\n *   coordinate system. push-matrix and pop-matrix are used in conjuction\n *   with the other transformation methods and may be embedded to control\n *   the scope of the transformations.\n */\nquil.core$macros.pop_matrix = (function quil$core$macros$pop_matrix(){\nreturn quil.core$macros.current_graphics.call(null).popMatrix();\n});\n/**\n * Restores the prior settings on the 'style stack'. Used in\n *   conjunction with push-style. Together they allow you to change the\n *   style settings and later return to what you had. When a new style is\n *   started with push-style, it builds on the current style information.\n *   The push-style and pop-style functions can be nested to provide more\n *   control\n */\nquil.core$macros.pop_style = (function quil$core$macros$pop_style(){\nreturn quil.core$macros.current_graphics.call(null).popStyle();\n});\n/**\n * Facilitates exponential expressions. The pow() function is an\n *   efficient way of multiplying numbers by themselves (or their\n *   reciprocal) in large quantities. For example, (pow 3 5) is\n *   equivalent to the expression (* 3 3 3 3 3) and (pow 3 -5) is\n *   equivalent to (/ 1 (* 3 3 3 3 3)).\n */\nquil.core$macros.pow = (function quil$core$macros$pow(num,exponent){\nreturn quil.sketch.current_applet.call(null).pow(num,exponent);\n});\n/**\n * Prints the current camera matrix to std out. Useful for debugging.\n */\nquil.core$macros.print_camera = (function quil$core$macros$print_camera(){\nreturn quil.core$macros.current_graphics.call(null).printCamera();\n});\n/**\n * Prints the current matrix to std out. Useful for debugging.\n */\nquil.core$macros.print_matrix = (function quil$core$macros$print_matrix(){\nreturn quil.core$macros.current_graphics.call(null).printMatrix();\n});\n/**\n * Prints the current projection matrix to std out. Useful for\n *   debugging\n */\nquil.core$macros.print_projection = (function quil$core$macros$print_projection(){\nreturn quil.core$macros.current_graphics.call(null).printProjection();\n});\n/**\n * Pushes the current transformation matrix onto the matrix\n *   stack. Understanding push-matrix and pop-matrix requires\n *   understanding the concept of a matrix stack. The push-matrix\n *   function saves the current coordinate system to the stack and\n *   pop-matrix restores the prior coordinate system. push-matrix and\n *   pop-matrix are used in conjuction with the other transformation\n *   methods and may be embedded to control the scope of the\n *   transformations.\n */\nquil.core$macros.push_matrix = (function quil$core$macros$push_matrix(){\nreturn quil.core$macros.current_graphics.call(null).pushMatrix();\n});\n/**\n * Saves the current style settings onto a 'style stack'. Use with\n *   pop-style which restores the prior settings. Note that these\n *   functions are always used together. They allow you to change the\n *   style settings and later return to what you had. When a new style is\n *   started with push-style, it builds on the current style\n *   information. The push-style and pop-style fns can be embedded to\n *   provide more control.\n * \n *   The style information controlled by the following functions are\n *   included in the style: fill, stroke, tint, stroke-weight,\n *   stroke-cap, stroke-join, image-mode, rect-mode, ellipse-mode,\n *   shape-mode, color-mode, text-align, text-font, text-mode, text-size,\n *   text-leading, emissive, specular, shininess, and ambient\n */\nquil.core$macros.push_style = (function quil$core$macros$push_style(){\nreturn quil.core$macros.current_graphics.call(null).pushStyle();\n});\n/**\n * A quad is a quadrilateral, a four sided polygon. It is similar to a\n *   rectangle, but the angles between its edges are not constrained to\n *   be ninety degrees. The first pair of parameters (x1,y1) sets the\n *   first vertex and the subsequent pairs should proceed clockwise or\n *   counter-clockwise around the defined shape.\n */\nquil.core$macros.quad = (function quil$core$macros$quad(x1,y1,x2,y2,x3,y3,x4,y4){\nreturn quil.core$macros.current_graphics.call(null).quad(x1,y1,x2,y2,x3,y3,x4,y4);\n});\n/**\n * Specifies vertex coordinates for quadratic Bezier curves. Each call to\n *   quadratic-vertex defines the position of one control points and one\n *   anchor point of a Bezier curve, adding a new segment to a line or shape.\n *   The first time quadratic-vertex is used within a begin-shape call, it\n *   must be prefaced with a call to vertex to set the first anchor point.\n *   This function must be used between begin-shape and end-shape and only\n *   when there is no MODE parameter specified to begin-shape. Using the 3D\n *   version requires rendering with :p3d.\n */\nquil.core$macros.quadratic_vertex = (function quil$core$macros$quadratic_vertex(var_args){\nvar args428 = [];\nvar len__3279__auto___431 = arguments.length;\nvar i__3280__auto___432 = (0);\nwhile(true){\nif((i__3280__auto___432 < len__3279__auto___431)){\nargs428.push((arguments[i__3280__auto___432]));\n\nvar G__433 = (i__3280__auto___432 + (1));\ni__3280__auto___432 = G__433;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__430 = args428.length;\nswitch (G__430) {\ncase (4):\nreturn quil.core$macros.quadratic_vertex.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (6):\nreturn quil.core$macros.quadratic_vertex.cljs$core$IFn$_invoke$arity$6((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args428.length)].join('')));\n\n}\n});\n\nquil.core$macros.quadratic_vertex.cljs$core$IFn$_invoke$arity$4 = (function (cx,cy,x3,y3){\nreturn quil.core$macros.current_graphics.call(null).quadraticVertex(cx,cy,x3,y3);\n});\n\nquil.core$macros.quadratic_vertex.cljs$core$IFn$_invoke$arity$6 = (function (cx,cy,cz,x3,y3,z3){\nreturn quil.core$macros.current_graphics.call(null).quadraticVertex(cx,cy,cz,x3,y3,z3);\n});\n\nquil.core$macros.quadratic_vertex.cljs$lang$maxFixedArity = (6);\nquil.core$macros.radians = (function quil$core$macros$radians(degrees){\nreturn quil.sketch.current_applet.call(null).radians(degrees);\n});\n/**\n * Generates random numbers. Each time the random function is called,\n *   it returns an unexpected value within the specified range. If one\n *   parameter is passed to the function it will return a float between\n *   zero and the value of the high parameter. The function call (random\n *   5) returns values between 0 and 5 (starting at zero, up to but not\n *   including 5). If two parameters are passed, it will return a float\n *   with a value between the parameters. The function call\n *   (random -5 10.2) returns values starting at -5 up to (but not\n *   including) 10.2.\n */\nquil.core$macros.random = (function quil$core$macros$random(var_args){\nvar args435 = [];\nvar len__3279__auto___438 = arguments.length;\nvar i__3280__auto___439 = (0);\nwhile(true){\nif((i__3280__auto___439 < len__3279__auto___438)){\nargs435.push((arguments[i__3280__auto___439]));\n\nvar G__440 = (i__3280__auto___439 + (1));\ni__3280__auto___439 = G__440;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__437 = args435.length;\nswitch (G__437) {\ncase (1):\nreturn quil.core$macros.random.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.random.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args435.length)].join('')));\n\n}\n});\n\nquil.core$macros.random.cljs$core$IFn$_invoke$arity$1 = (function (max){\nreturn quil.sketch.current_applet.call(null).random(max);\n});\n\nquil.core$macros.random.cljs$core$IFn$_invoke$arity$2 = (function (min,max){\nreturn quil.sketch.current_applet.call(null).random(min,max);\n});\n\nquil.core$macros.random.cljs$lang$maxFixedArity = (2);\n/**\n * Returns a float from a random series of numbers having a mean of 0 and\n *   standard deviation of 1. Each time the randomGaussian() function is called,\n *   it returns a number fitting a Gaussian, or normal, distribution.\n *   There is theoretically no minimum or maximum value that randomGaussian()\n *   might return. Rather, there is just a very low probability that values far\n *   from the mean will be returned; and a higher probability that numbers near\n *   the mean will be returned. .\n */\nquil.core$macros.random_gaussian = (function quil$core$macros$random_gaussian(){\nreturn quil.sketch.current_applet.call(null).randomGaussian();\n});\n/**\n * Sets the seed value for random. By default, random produces\n *   different results each time the program is run. Set the value\n *   parameter to a constant to return the same pseudo-random numbers\n *   each time the software is run.\n */\nquil.core$macros.random_seed = (function quil$core$macros$random_seed(w){\nreturn quil.sketch.current_applet.call(null).randomSeed(w);\n});\n/**\n * Contains the value of the most recent key on the keyboard that was\n *   used (either pressed or released).\n * \n *   For non-ASCII keys, use the keyCode variable. The keys included in\n *   the ASCII specification (BACKSPACE, TAB, ENTER, RETURN, ESC, and\n *   DELETE) do not require checking to see if they key is coded, and you\n *   should simply use the key variable instead of keyCode If you're\n *   making cross-platform projects, note that the ENTER key is commonly\n *   used on PCs and Unix and the RETURN key is used instead on\n *   Macintosh. Check for both ENTER and RETURN to make sure your program\n *   will work for all platforms.\n */\nquil.core$macros.raw_key = (function quil$core$macros$raw_key(){\nreturn quil.sketch.current_applet.call(null).key;\n});\n/**\n * Draws a rectangle to the screen. A rectangle is a four-sided shape\n *   with every angle at ninety degrees. By default, the first two\n *   parameters set the location of the upper-left corner, the third\n *   sets the width, and the fourth sets the height. These parameters\n *   may be changed with rect-mode.\n * \n *   To draw a rounded rectangle, add a fifth parameter, which is used as\n *   the radius value for all four corners. To use a different radius value\n *   for each corner, include eight parameters.\n */\nquil.core$macros.rect = (function quil$core$macros$rect(var_args){\nvar args442 = [];\nvar len__3279__auto___445 = arguments.length;\nvar i__3280__auto___446 = (0);\nwhile(true){\nif((i__3280__auto___446 < len__3279__auto___445)){\nargs442.push((arguments[i__3280__auto___446]));\n\nvar G__447 = (i__3280__auto___446 + (1));\ni__3280__auto___446 = G__447;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__444 = args442.length;\nswitch (G__444) {\ncase (4):\nreturn quil.core$macros.rect.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (5):\nreturn quil.core$macros.rect.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ncase (8):\nreturn quil.core$macros.rect.cljs$core$IFn$_invoke$arity$8((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args442.length)].join('')));\n\n}\n});\n\nquil.core$macros.rect.cljs$core$IFn$_invoke$arity$4 = (function (x,y,width,height){\nreturn quil.core$macros.current_graphics.call(null).rect(x,y,width,height);\n});\n\nquil.core$macros.rect.cljs$core$IFn$_invoke$arity$5 = (function (x,y,width,height,r){\nreturn quil.core$macros.current_graphics.call(null).rect(x,y,width,height,r);\n});\n\nquil.core$macros.rect.cljs$core$IFn$_invoke$arity$8 = (function (x,y,width,height,top_left_r,top_right_r,bottom_right_r,bottom_left_r){\nreturn quil.core$macros.current_graphics.call(null).rect(x,y,width,height,top_left_r,top_right_r,bottom_right_r,bottom_left_r);\n});\n\nquil.core$macros.rect.cljs$lang$maxFixedArity = (8);\n/**\n * Modifies the location from which rectangles draw. The default mode\n *   is :corner. Available modes are:\n * \n * \n *   :corner  - Specifies the location to be the upper left corner of the\n *           shape and uses the third and fourth parameters of rect to\n *           specify the width and height.\n * \n *   :corners - Uses the first and second parameters of rect to set the\n *           location of one corner and uses the third and fourth\n *           parameters to set the opposite corner.\n * \n *   :center  - Draws the image from its center point and uses the third\n *           and forth parameters of rect to specify the image's width\n *           and height.\n * \n *   :radius  - Draws the image from its center point and uses the third\n *           and forth parameters of rect() to specify half of the\n *           image's width and height.\n */\nquil.core$macros.rect_mode = (function quil$core$macros$rect_mode(mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.rect_modes);\nreturn quil.core$macros.current_graphics.call(null).rectMode((mode__$1 | (0)));\n});\n/**\n * Extracts the red value from a color, scaled to match current color-mode.\n */\nquil.core$macros.red = (function quil$core$macros$red(c){\nreturn quil.core$macros.current_graphics.call(null).red(cljs.core.unchecked_int.call(null,c));\n});\n/**\n * Executes the code within the draw fn one time. This functions\n *   allows the program to update the display window only when necessary,\n *   for example when an event registered by mouse-pressed or\n *   key-pressed occurs.\n * \n *   In structuring a program, it only makes sense to call redraw\n *   within events such as mouse-pressed. This is because redraw does\n *   not run draw immediately (it only sets a flag that indicates an\n *   update is needed).\n * \n *   Calling redraw within draw has no effect because draw is\n *   continuously called anyway.\n */\nquil.core$macros.redraw = (function quil$core$macros$redraw(){\nreturn quil.sketch.current_applet.call(null).redraw();\n});\n/**\n * This function load images on a separate thread so that your sketch\n *   does not freeze while images load during setup. While the image is\n *   loading, its width and height will be 0. If an error occurs while\n *   loading the image, its width and height will be set to -1. You'll\n *   know when the image has loaded properly because its width and height\n *   will be greater than 0. Asynchronous image loading (particularly\n *   when downloading from a server) can dramatically improve\n *   performance.\n */\nquil.core$macros.request_image = (function quil$core$macros$request_image(filename){\nreturn quil.sketch.current_applet.call(null).requestImage([cljs.core.str(filename)].join(''));\n});\n/**\n * Replaces the current matrix with the identity matrix. The\n *   equivalent function in OpenGL is glLoadIdentity()\n */\nquil.core$macros.reset_matrix = (function quil$core$macros$reset_matrix(){\nreturn quil.core$macros.current_graphics.call(null).resetMatrix();\n});\n/**\n * Resize the image to a new width and height.\n *   To make the image scale proportionally, use 0 as the value for the wide or\n *   high parameter. For instance, to make the width of an image 150 pixels,\n *   and change the height using the same proportion, use resize(150, 0).\n * \n *   Even though a PGraphics is technically a PImage, it is not possible\n *   to rescale the image data found in a PGraphics.\n *   (It's simply not possible to do this consistently across renderers:\n *   technically infeasible with P3D, or what would it even do with PDF?)\n *   If you want to resize PGraphics content, first get a copy of its image data\n *   using the get() method, and call resize() on the PImage that is returned.\n */\nquil.core$macros.resize = (function quil$core$macros$resize(img,w,h){\nreturn img.resize(w,h);\n});\n/**\n * Rotates a shape the amount specified by the angle parameter. Angles\n *   should be specified in radians (values from 0 to TWO-PI) or\n *   converted to radians with the radians function.\n * \n *   Objects are always rotated around their relative position to the\n *   origin and positive numbers rotate objects in a clockwise\n *   direction. Transformations apply to everything that happens after\n *   and subsequent calls to the function accumulates the effect. For\n *   example, calling (rotate HALF-PI) and then (rotate HALF-PI) is the\n *   same as (rotate PI). All tranformations are reset when draw begins\n *   again.\n * \n *   Technically, rotate multiplies the current transformation matrix by\n *   a rotation matrix. This function can be further controlled by the\n *   push-matrix and pop-matrix.\n */\nquil.core$macros.rotate = (function quil$core$macros$rotate(var_args){\nvar args449 = [];\nvar len__3279__auto___452 = arguments.length;\nvar i__3280__auto___453 = (0);\nwhile(true){\nif((i__3280__auto___453 < len__3279__auto___452)){\nargs449.push((arguments[i__3280__auto___453]));\n\nvar G__454 = (i__3280__auto___453 + (1));\ni__3280__auto___453 = G__454;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__451 = args449.length;\nswitch (G__451) {\ncase (1):\nreturn quil.core$macros.rotate.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.rotate.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args449.length)].join('')));\n\n}\n});\n\nquil.core$macros.rotate.cljs$core$IFn$_invoke$arity$1 = (function (angle){\nreturn quil.core$macros.current_graphics.call(null).rotate(angle);\n});\n\nquil.core$macros.rotate.cljs$core$IFn$_invoke$arity$4 = (function (angle,vx,vy,vz){\nreturn quil.core$macros.current_graphics.call(null).rotate(angle,vx,vy,vz);\n});\n\nquil.core$macros.rotate.cljs$lang$maxFixedArity = (4);\n/**\n * Rotates a shape around the x-axis the amount specified by the angle\n *   parameter. Angles should be specified in radians (values from 0 to\n *   (* PI 2)) or converted to radians with the radians function. Objects\n *   are always rotated around their relative position to the origin and\n *   positive numbers rotate objects in a counterclockwise\n *   direction. Transformations apply to everything that happens after\n *   and subsequent calls to the function accumulates the effect. For\n *   example, calling (rotate-x HALF-PI) and then (rotate-x HALF-PI) is\n *   the same as (rotate-x PI). If rotate-x is called within the draw fn,\n *   the transformation is reset when the loop begins again. This\n *   function requires either the :p3d or :opengl renderer.\n */\nquil.core$macros.rotate_x = (function quil$core$macros$rotate_x(angle){\nreturn quil.core$macros.current_graphics.call(null).rotateX(angle);\n});\n/**\n * Rotates a shape around the y-axis the amount specified by the angle\n *   parameter. Angles should be specified in radians (values from 0\n *   to (* PI 2)) or converted to radians with the radians function.\n *   Objects are always rotated around their relative position to the\n *   origin and positive numbers rotate objects in a counterclockwise\n *   direction. Transformations apply to everything that happens after\n *   and subsequent calls to the function accumulates the effect. For\n *   example, calling (rotate-y HALF-PI) and then (rotate-y HALF-PI) is\n *   the same as (rotate-y PI). If rotate-y is called within the draw fn,\n *   the transformation is reset when the loop begins again. This\n *   function requires either the :p3d or :opengl renderer.\n */\nquil.core$macros.rotate_y = (function quil$core$macros$rotate_y(angle){\nreturn quil.core$macros.current_graphics.call(null).rotateY(angle);\n});\n/**\n * Rotates a shape around the z-axis the amount specified by the angle\n *   parameter. Angles should be specified in radians (values from 0\n *   to (* PI 2)) or converted to radians with the radians function.\n *   Objects are always rotated around their relative position to the\n *   origin and positive numbers rotate objects in a counterclockwise\n *   direction. Transformations apply to everything that happens after\n *   and subsequent calls to the function accumulates the effect. For\n *   example, calling (rotate-z HALF-PI) and then (rotate-z HALF-PI) is\n *   the same as (rotate-z PI). If rotate-y is called within the draw fn,\n *   the transformation is reset when the loop begins again. This\n *   function requires either the :p3d or :opengl renderer.\n */\nquil.core$macros.rotate_z = (function quil$core$macros$rotate_z(angle){\nreturn quil.core$macros.current_graphics.call(null).rotateZ(angle);\n});\n/**\n * Calculates the integer closest to the value parameter. For example,\n *   (round 9.2) returns the value 9.\n */\nquil.core$macros.round = (function quil$core$macros$round(val){\nreturn quil.sketch.current_applet.call(null).round(val);\n});\n/**\n * Extracts the saturation value from a color.\n */\nquil.core$macros.saturation = (function quil$core$macros$saturation(c){\nreturn quil.core$macros.current_graphics.call(null).saturation(cljs.core.unchecked_int.call(null,c));\n});\n/**\n * Saves an image from the display window. Images are saved in TIFF,\n *   TARGA, JPEG, and PNG format depending on the extension within the\n *   filename parameter. For example, image.tif will have a TIFF image\n *   and image.png will save a PNG image. If no extension is included in\n *   the filename, the image will save in TIFF format and .tif will be\n *   added to the name. All images saved from the main drawing window\n *   will be opaque. To save images without a background, use\n *   create-graphics.\n */\nquil.core$macros.save = (function quil$core$macros$save(filename){\nreturn quil.core$macros.current_graphics.call(null).save([cljs.core.str(filename)].join(''));\n});\n/**\n * Saves an image identical to the current display window as a\n *   file. May be called multple times - each file saved will have a\n *   unique name. Name and image formate may be modified by passing a\n *   string parameter of the form \"foo-####.ext\" where foo- can be any\n *   arbitrary string, #### will be replaced with the current frame id\n *   and .ext is one of .tiff, .targa, .png, .jpeg or .jpg\n * \n *   Examples:\n *   (save-frame)\n *   (save-frame \"pretty-pic-####.jpg\")\n */\nquil.core$macros.save_frame = (function quil$core$macros$save_frame(var_args){\nvar args456 = [];\nvar len__3279__auto___459 = arguments.length;\nvar i__3280__auto___460 = (0);\nwhile(true){\nif((i__3280__auto___460 < len__3279__auto___459)){\nargs456.push((arguments[i__3280__auto___460]));\n\nvar G__461 = (i__3280__auto___460 + (1));\ni__3280__auto___460 = G__461;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__458 = args456.length;\nswitch (G__458) {\ncase (0):\nreturn quil.core$macros.save_frame.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.save_frame.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args456.length)].join('')));\n\n}\n});\n\nquil.core$macros.save_frame.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.sketch.current_applet.call(null).saveFrame();\n});\n\nquil.core$macros.save_frame.cljs$core$IFn$_invoke$arity$1 = (function (name){\nreturn quil.sketch.current_applet.call(null).saveFrame([cljs.core.str(name)].join(''));\n});\n\nquil.core$macros.save_frame.cljs$lang$maxFixedArity = (1);\n/**\n * Increases or decreases the size of a shape by expanding and\n *   contracting vertices. Objects always scale from their relative\n *   origin to the coordinate system. Scale values are specified as\n *   decimal percentages. For example, the function call (scale 2)\n *   increases the dimension of a shape by 200%. Transformations apply to\n *   everything that happens after and subsequent calls to the function\n *   multiply the effect. For example, calling (scale 2) and then\n *   (scale 1.5) is the same as (scale 3). If scale is called within\n *   draw, the transformation is reset when the loop begins again. Using\n *   this fuction with the z parameter requires specfying :p3d or :opengl\n *   as the renderer. This function can be further controlled by\n *   push-matrix and pop-matrix.\n */\nquil.core$macros.scale = (function quil$core$macros$scale(var_args){\nvar args463 = [];\nvar len__3279__auto___466 = arguments.length;\nvar i__3280__auto___467 = (0);\nwhile(true){\nif((i__3280__auto___467 < len__3279__auto___466)){\nargs463.push((arguments[i__3280__auto___467]));\n\nvar G__468 = (i__3280__auto___467 + (1));\ni__3280__auto___467 = G__468;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__465 = args463.length;\nswitch (G__465) {\ncase (1):\nreturn quil.core$macros.scale.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.scale.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.scale.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args463.length)].join('')));\n\n}\n});\n\nquil.core$macros.scale.cljs$core$IFn$_invoke$arity$1 = (function (s){\nreturn quil.core$macros.current_graphics.call(null).scale(s);\n});\n\nquil.core$macros.scale.cljs$core$IFn$_invoke$arity$2 = (function (sx,sy){\nreturn quil.core$macros.current_graphics.call(null).scale(sx,sy);\n});\n\nquil.core$macros.scale.cljs$core$IFn$_invoke$arity$3 = (function (sx,sy,sz){\nreturn quil.core$macros.current_graphics.call(null).scale(sx,sy,sz);\n});\n\nquil.core$macros.scale.cljs$lang$maxFixedArity = (3);\n/**\n * Takes a three-dimensional x, y, z position and returns the x value\n *   for where it will appear on a (two-dimensional) screen, once\n *   affected by translate, scale or any other transformations\n */\nquil.core$macros.screen_x = (function quil$core$macros$screen_x(var_args){\nvar args470 = [];\nvar len__3279__auto___473 = arguments.length;\nvar i__3280__auto___474 = (0);\nwhile(true){\nif((i__3280__auto___474 < len__3279__auto___473)){\nargs470.push((arguments[i__3280__auto___474]));\n\nvar G__475 = (i__3280__auto___474 + (1));\ni__3280__auto___474 = G__475;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__472 = args470.length;\nswitch (G__472) {\ncase (2):\nreturn quil.core$macros.screen_x.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.screen_x.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args470.length)].join('')));\n\n}\n});\n\nquil.core$macros.screen_x.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.core$macros.current_graphics.call(null).screenX(x,y);\n});\n\nquil.core$macros.screen_x.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.current_graphics.call(null).screenX(x,y,z);\n});\n\nquil.core$macros.screen_x.cljs$lang$maxFixedArity = (3);\n/**\n * Takes a three-dimensional x, y, z position and returns the y value\n *   for where it will appear on a (two-dimensional) screen, once\n *   affected by translate, scale or any other transformations\n */\nquil.core$macros.screen_y = (function quil$core$macros$screen_y(var_args){\nvar args477 = [];\nvar len__3279__auto___480 = arguments.length;\nvar i__3280__auto___481 = (0);\nwhile(true){\nif((i__3280__auto___481 < len__3279__auto___480)){\nargs477.push((arguments[i__3280__auto___481]));\n\nvar G__482 = (i__3280__auto___481 + (1));\ni__3280__auto___481 = G__482;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__479 = args477.length;\nswitch (G__479) {\ncase (2):\nreturn quil.core$macros.screen_y.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.screen_y.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args477.length)].join('')));\n\n}\n});\n\nquil.core$macros.screen_y.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.core$macros.current_graphics.call(null).screenY(x,y);\n});\n\nquil.core$macros.screen_y.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.current_graphics.call(null).screenY(x,y,z);\n});\n\nquil.core$macros.screen_y.cljs$lang$maxFixedArity = (3);\n/**\n * Given an x, y, z coordinate, returns its z value.\n * This value can be used to determine if an x, y, z coordinate is in\n * front or in back of another (x, y, z) coordinate. The units are\n * based on how the zbuffer is set up, and don't relate to anything\n * 'real'. They're only useful for in comparison to another value\n * obtained from screen-z, or directly out of the zbuffer\n */\nquil.core$macros.screen_z = (function quil$core$macros$screen_z(x,y,z){\nreturn quil.core$macros.current_graphics.call(null).screenZ(x,y,z);\n});\n/**\n * Returns the current second as a value from 0 - 59.\n */\nquil.core$macros.seconds = (function quil$core$macros$seconds(){\nreturn quil.sketch.current_applet.call(null).second();\n});\n/**\n * Changes the color of any pixel in the display window. The x and y\n *   parameters specify the pixel to change and the color parameter\n *   specifies the color value. The color parameter is affected by the\n *   current color mode (the default is RGB values from 0 to 255).\n * \n *   Setting the color of a single pixel with (set x, y) is easy, but not\n *   as fast as putting the data directly into pixels[].\n * \n *   This function ignores imageMode().\n * \n *   Due to what appears to be a bug in Apple's Java implementation, the\n *   point() and set() methods are extremely slow in some circumstances\n *   when used with the default renderer. Using :p2d or :p3d will fix the\n *   problem. Grouping many calls to point or set-pixel together can also\n *   help. (Bug 1094)\n */\nquil.core$macros.set_pixel = (function quil$core$macros$set_pixel(var_args){\nvar args484 = [];\nvar len__3279__auto___487 = arguments.length;\nvar i__3280__auto___488 = (0);\nwhile(true){\nif((i__3280__auto___488 < len__3279__auto___487)){\nargs484.push((arguments[i__3280__auto___488]));\n\nvar G__489 = (i__3280__auto___488 + (1));\ni__3280__auto___488 = G__489;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__486 = args484.length;\nswitch (G__486) {\ncase (3):\nreturn quil.core$macros.set_pixel.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.set_pixel.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args484.length)].join('')));\n\n}\n});\n\nquil.core$macros.set_pixel.cljs$core$IFn$_invoke$arity$3 = (function (x,y,c){\nreturn quil.core$macros.set_pixel.call(null,quil.core$macros.current_graphics.call(null),x,y,c);\n});\n\nquil.core$macros.set_pixel.cljs$core$IFn$_invoke$arity$4 = (function (img,x,y,c){\nreturn img.set((x | (0)),(y | (0)),(c | (0)));\n});\n\nquil.core$macros.set_pixel.cljs$lang$maxFixedArity = (4);\n/**\n * Writes an image directly into the display window. The x and y\n *   parameters define the coordinates for the upper-left corner of the\n *   image.\n */\nquil.core$macros.set_image = (function quil$core$macros$set_image(x,y,src){\nreturn quil.core$macros.current_graphics.call(null).set((x | (0)),(y | (0)),src);\n});\n/**\n * Displays shapes to the screen. The shapes must have been loaded\n *   with load-shape. Processing currently works with SVG shapes\n *   only. The sh parameter specifies the shape to display and the x and\n *   y parameters define the location of the shape from its upper-left\n *   corner. The shape is displayed at its original size unless the width\n *   and height parameters specify a different size. The shape-mode\n *   fn changes the way the parameters work. A call to\n *   (shape-mode :corners), for example, will change the width and height\n *   parameters to define the x and y values of the opposite corner of\n *   the shape.\n * \n *   Note complex shapes may draw awkwardly with the renderers :p2d, :p3d, and\n *   :opengl. Those renderers do not yet support shapes that have holes\n *   or complicated breaks.\n */\nquil.core$macros.shape = (function quil$core$macros$shape(var_args){\nvar args491 = [];\nvar len__3279__auto___494 = arguments.length;\nvar i__3280__auto___495 = (0);\nwhile(true){\nif((i__3280__auto___495 < len__3279__auto___494)){\nargs491.push((arguments[i__3280__auto___495]));\n\nvar G__496 = (i__3280__auto___495 + (1));\ni__3280__auto___495 = G__496;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__493 = args491.length;\nswitch (G__493) {\ncase (1):\nreturn quil.core$macros.shape.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.shape.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (5):\nreturn quil.core$macros.shape.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args491.length)].join('')));\n\n}\n});\n\nquil.core$macros.shape.cljs$core$IFn$_invoke$arity$1 = (function (sh){\nreturn quil.core$macros.current_graphics.call(null).shape(sh);\n});\n\nquil.core$macros.shape.cljs$core$IFn$_invoke$arity$3 = (function (sh,x,y){\nreturn quil.core$macros.current_graphics.call(null).shape(sh,x,y);\n});\n\nquil.core$macros.shape.cljs$core$IFn$_invoke$arity$5 = (function (sh,x,y,width,height){\nreturn quil.core$macros.current_graphics.call(null).shape(sh,x,y,width,height);\n});\n\nquil.core$macros.shape.cljs$lang$maxFixedArity = (5);\n/**\n * Shears a shape around the x-axis the amount specified by the angle\n *   parameter. Angles should be specified in radians (values from 0 to\n *   PI*2) or converted to radians with the radians() function. Objects\n *   are always sheared around their relative position to the origin and\n *   positive numbers shear objects in a clockwise direction.\n *   Transformations apply to everything that happens after and\n *   subsequent calls to the function accumulates the effect. For\n *   example, calling (shear-x (/ PI 2)) and then (shear-x (/ PI 2)) is\n *   the same as (shear-x PI). If shear-x is called within the draw fn,\n *   the transformation is reset when the loop begins again. This\n *   function works in P2D or JAVA2D mode.\n * \n *   Technically, shear-x multiplies the current transformation matrix\n *   by a rotation matrix. This function can be further controlled by the\n *   push-matrix and pop-matrix fns.\n */\nquil.core$macros.shear_x = (function quil$core$macros$shear_x(angle){\nreturn quil.core$macros.current_graphics.call(null).shearX(angle);\n});\n/**\n * Shears a shape around the y-axis the amount specified by the angle\n *   parameter. Angles should be specified in radians (values from 0 to\n *   PI*2) or converted to radians with the radians() function. Objects\n *   are always sheared around their relative position to the origin and\n *   positive numbers shear objects in a clockwise direction.\n *   Transformations apply to everything that happens after and\n *   subsequent calls to the function accumulates the effect. For\n *   example, calling (shear-y (/ PI 2)) and then (shear-y (/ PI 2)) is\n *   the same as (shear-y PI). If shear-y is called within the draw fn,\n *   the transformation is reset when the loop begins again. This\n *   function works in P2D or JAVA2D mode.\n * \n *   Technically, shear-y multiplies the current transformation matrix\n *   by a rotation matrix. This function can be further controlled by the\n *   push-matrix and pop-matrix fns.\n */\nquil.core$macros.shear_y = (function quil$core$macros$shear_y(angle){\nreturn quil.core$macros.current_graphics.call(null).shearY(angle);\n});\n/**\n * Modifies the location from which shapes draw. Available modes are\n *   :corner, :corners and :center. Default is :corner.\n * \n *   :corner  - specifies the location to be the upper left corner of the\n *           shape and uses the third and fourth parameters of shape\n *           to specify the width and height.\n * \n *   :corners - uses the first and second parameters of shape to set\n *           the location of one corner and uses the third and fourth\n *           parameters to set the opposite corner.\n * \n *   :center  - draws the shape from its center point and uses the third\n *           and forth parameters of shape to specify the width and\n *           height. \n */\nquil.core$macros.shape_mode = (function quil$core$macros$shape_mode(mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.p_shape_modes);\nreturn quil.core$macros.current_graphics.call(null).shapeMode((mode__$1 | (0)));\n});\n/**\n * Sets the amount of gloss in the surface of shapes. Used in\n *   combination with ambient, specular, and emissive in setting\n *   the material properties of shapes.\n */\nquil.core$macros.shininess = (function quil$core$macros$shininess(shine){\nreturn quil.core$macros.current_graphics.call(null).shininess(shine);\n});\n/**\n * Calculates the sine of an angle. This function expects the values\n *   of the angle parameter to be provided in radians (values from 0 to\n *   6.28). A float within the range -1 to 1 is returned.\n */\nquil.core$macros.sin = (function quil$core$macros$sin(angle){\nreturn quil.sketch.current_applet.call(null).sin(angle);\n});\n/**\n * Draws all geometry with smooth (anti-aliased) edges. This will slow\n *   down the frame rate of the application, but will enhance the visual\n *   refinement.\n * \n *   Must be called inside :settings handler.\n * \n *   The level parameter (int) increases the level of smoothness with the\n *   P2D and P3D renderers. This is the level of over sampling applied to\n *   the graphics buffer. The value '2' will double the rendering size\n *   before scaling it down to the display size. This is called '2x\n *   anti-aliasing.' The value 4 is used for 4x anti-aliasing and 8 is\n *   specified for 8x anti-aliasing. If level is set to 0, it will disable\n *   all smoothing; it's the equivalent of the function noSmooth().\n *   The maximum anti-aliasing level is determined by the hardware of the\n *   machine that is running the software.\n * \n *   Note that smooth will also improve image quality of resized images.\n */\nquil.core$macros.smooth = (function quil$core$macros$smooth(var_args){\nvar args498 = [];\nvar len__3279__auto___501 = arguments.length;\nvar i__3280__auto___502 = (0);\nwhile(true){\nif((i__3280__auto___502 < len__3279__auto___501)){\nargs498.push((arguments[i__3280__auto___502]));\n\nvar G__503 = (i__3280__auto___502 + (1));\ni__3280__auto___502 = G__503;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__500 = args498.length;\nswitch (G__500) {\ncase (0):\nreturn quil.core$macros.smooth.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.smooth.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args498.length)].join('')));\n\n}\n});\n\nquil.core$macros.smooth.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.current_graphics.call(null).smooth();\n});\n\nquil.core$macros.smooth.cljs$core$IFn$_invoke$arity$1 = (function (level){\nreturn quil.core$macros.current_graphics.call(null).smooth((level | (0)));\n});\n\nquil.core$macros.smooth.cljs$lang$maxFixedArity = (1);\n/**\n * Sets the specular color of the materials used for shapes drawn to\n *   the screen, which sets the color of hightlights. Specular refers to\n *   light which bounces off a surface in a perferred direction (rather\n *   than bouncing in all directions like a diffuse light). Used in\n *   combination with emissive, ambient, and shininess in setting\n *   the material properties of shapes.\n */\nquil.core$macros.specular = (function quil$core$macros$specular(var_args){\nvar args505 = [];\nvar len__3279__auto___508 = arguments.length;\nvar i__3280__auto___509 = (0);\nwhile(true){\nif((i__3280__auto___509 < len__3279__auto___508)){\nargs505.push((arguments[i__3280__auto___509]));\n\nvar G__510 = (i__3280__auto___509 + (1));\ni__3280__auto___509 = G__510;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__507 = args505.length;\nswitch (G__507) {\ncase (1):\nreturn quil.core$macros.specular.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.specular.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args505.length)].join('')));\n\n}\n});\n\nquil.core$macros.specular.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nreturn quil.core$macros.current_graphics.call(null).specular(gray);\n});\n\nquil.core$macros.specular.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.current_graphics.call(null).specular(x,y,z);\n});\n\nquil.core$macros.specular.cljs$lang$maxFixedArity = (3);\n/**\n * Generates a hollow ball made from tessellated triangles.\n */\nquil.core$macros.sphere = (function quil$core$macros$sphere(radius){\nreturn quil.core$macros.current_graphics.call(null).sphere(radius);\n});\n/**\n * Controls the detail used to render a sphere by adjusting the number\n *   of vertices of the sphere mesh. The default resolution is 30, which\n *   creates a fairly detailed sphere definition with vertices every\n *   360/30 = 12 degrees. If you're going to render a great number of\n *   spheres per frame, it is advised to reduce the level of detail using\n *   this function. The setting stays active until sphere-detail is\n *   called again with a new parameter and so should not be called prior\n *   to every sphere statement, unless you wish to render spheres with\n *   different settings, e.g. using less detail for smaller spheres or\n *   ones further away from the camera. To controla the detail of the\n *   horizontal and vertical resolution independently, use the version of\n *   the functions with two parameters.\n */\nquil.core$macros.sphere_detail = (function quil$core$macros$sphere_detail(var_args){\nvar args512 = [];\nvar len__3279__auto___515 = arguments.length;\nvar i__3280__auto___516 = (0);\nwhile(true){\nif((i__3280__auto___516 < len__3279__auto___515)){\nargs512.push((arguments[i__3280__auto___516]));\n\nvar G__517 = (i__3280__auto___516 + (1));\ni__3280__auto___516 = G__517;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__514 = args512.length;\nswitch (G__514) {\ncase (1):\nreturn quil.core$macros.sphere_detail.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.sphere_detail.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args512.length)].join('')));\n\n}\n});\n\nquil.core$macros.sphere_detail.cljs$core$IFn$_invoke$arity$1 = (function (res){\nreturn quil.core$macros.current_graphics.call(null).sphereDetail((res | (0)));\n});\n\nquil.core$macros.sphere_detail.cljs$core$IFn$_invoke$arity$2 = (function (ures,vres){\nreturn quil.core$macros.current_graphics.call(null).sphereDetail((ures | (0)),(vres | (0)));\n});\n\nquil.core$macros.sphere_detail.cljs$lang$maxFixedArity = (2);\n/**\n * Adds a spot light. Lights need to be included in the draw to\n *   remain persistent in a looping program. Placing them in the setup\n *   of a looping program will cause them to only have an effect the\n *   first time through the loop. The affect of the r, g, and b\n *   parameters is determined by the current color mode. The x, y, and z\n *   parameters specify the position of the light and nx, ny, nz specify\n *   the direction or light. The angle parameter affects angle of the\n *   spotlight cone.\n */\nquil.core$macros.spot_light = (function quil$core$macros$spot_light(var_args){\nvar args519 = [];\nvar len__3279__auto___528 = arguments.length;\nvar i__3280__auto___529 = (0);\nwhile(true){\nif((i__3280__auto___529 < len__3279__auto___528)){\nargs519.push((arguments[i__3280__auto___529]));\n\nvar G__530 = (i__3280__auto___529 + (1));\ni__3280__auto___529 = G__530;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__521 = args519.length;\nswitch (G__521) {\ncase (11):\nreturn quil.core$macros.spot_light.cljs$core$IFn$_invoke$arity$11((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]),(arguments[(5)]),(arguments[(6)]),(arguments[(7)]),(arguments[(8)]),(arguments[(9)]),(arguments[(10)]));\n\nbreak;\ncase (5):\nreturn quil.core$macros.spot_light.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args519.length)].join('')));\n\n}\n});\n\nquil.core$macros.spot_light.cljs$core$IFn$_invoke$arity$11 = (function (r,g,b,x,y,z,nx,ny,nz,angle,concentration){\nreturn quil.core$macros.current_graphics.call(null).spotLight(r,g,b,x,y,z,nx,ny,nz,angle,concentration);\n});\n\nquil.core$macros.spot_light.cljs$core$IFn$_invoke$arity$5 = (function (p__522,p__523,p__524,angle,concentration){\nvar vec__525 = p__522;\nvar r = cljs.core.nth.call(null,vec__525,(0),null);\nvar g = cljs.core.nth.call(null,vec__525,(1),null);\nvar b = cljs.core.nth.call(null,vec__525,(2),null);\nvar vec__526 = p__523;\nvar x = cljs.core.nth.call(null,vec__526,(0),null);\nvar y = cljs.core.nth.call(null,vec__526,(1),null);\nvar z = cljs.core.nth.call(null,vec__526,(2),null);\nvar vec__527 = p__524;\nvar nx = cljs.core.nth.call(null,vec__527,(0),null);\nvar ny = cljs.core.nth.call(null,vec__527,(1),null);\nvar nz = cljs.core.nth.call(null,vec__527,(2),null);\nreturn quil.core$macros.current_graphics.call(null).spotLight(r,g,b,x,y,z,nx,ny,nz,angle,concentration);\n});\n\nquil.core$macros.spot_light.cljs$lang$maxFixedArity = (11);\n/**\n * Squares a number (multiplies a number by itself). The result is\n *   always a positive number, as multiplying two negative numbers always\n *   yields a positive result. For example, -1 * -1 = 1.\n */\nquil.core$macros.sq = (function quil$core$macros$sq(a){\nreturn quil.sketch.current_applet.call(null).sq(a);\n});\n/**\n * Calculates the square root of a number. The square root of a number\n *   is always positive, even though there may be a valid negative\n *   root. The square root s of number a is such that (= a (* s s)) . It\n *   is the opposite of squaring.\n */\nquil.core$macros.sqrt = (function quil$core$macros$sqrt(a){\nreturn quil.sketch.current_applet.call(null).sqrt(a);\n});\n/**\n * Causes Processing to continuously execute the code within\n *   draw. If no-loop is called, the code in draw stops executing.\n */\nquil.core$macros.start_loop = (function quil$core$macros$start_loop(){\nreturn quil.sketch.current_applet.call(null).loop();\n});\n/**\n * Sets the color used to draw lines and borders around\n *   shapes. Converts all args to floats\n */\nquil.core$macros.stroke_float = (function quil$core$macros$stroke_float(var_args){\nvar args532 = [];\nvar len__3279__auto___535 = arguments.length;\nvar i__3280__auto___536 = (0);\nwhile(true){\nif((i__3280__auto___536 < len__3279__auto___535)){\nargs532.push((arguments[i__3280__auto___536]));\n\nvar G__537 = (i__3280__auto___536 + (1));\ni__3280__auto___536 = G__537;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__534 = args532.length;\nswitch (G__534) {\ncase (1):\nreturn quil.core$macros.stroke_float.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.stroke_float.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.stroke_float.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.stroke_float.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args532.length)].join('')));\n\n}\n});\n\nquil.core$macros.stroke_float.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nreturn quil.core$macros.current_graphics.call(null).stroke(gray);\n});\n\nquil.core$macros.stroke_float.cljs$core$IFn$_invoke$arity$2 = (function (gray,alpha){\nreturn quil.core$macros.current_graphics.call(null).stroke(gray,alpha);\n});\n\nquil.core$macros.stroke_float.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.current_graphics.call(null).stroke(x,y,z);\n});\n\nquil.core$macros.stroke_float.cljs$core$IFn$_invoke$arity$4 = (function (x,y,z,a){\nreturn quil.core$macros.current_graphics.call(null).stroke(x,y,z,a);\n});\n\nquil.core$macros.stroke_float.cljs$lang$maxFixedArity = (4);\n/**\n * Sets the color used to draw lines and borders around\n *   shapes. Converts rgb to int and alpha to a float.\n */\nquil.core$macros.stroke_int = (function quil$core$macros$stroke_int(var_args){\nvar args539 = [];\nvar len__3279__auto___542 = arguments.length;\nvar i__3280__auto___543 = (0);\nwhile(true){\nif((i__3280__auto___543 < len__3279__auto___542)){\nargs539.push((arguments[i__3280__auto___543]));\n\nvar G__544 = (i__3280__auto___543 + (1));\ni__3280__auto___543 = G__544;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__541 = args539.length;\nswitch (G__541) {\ncase (1):\nreturn quil.core$macros.stroke_int.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.stroke_int.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args539.length)].join('')));\n\n}\n});\n\nquil.core$macros.stroke_int.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core$macros.current_graphics.call(null).stroke(cljs.core.unchecked_int.call(null,rgb));\n});\n\nquil.core$macros.stroke_int.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core$macros.current_graphics.call(null).stroke(cljs.core.unchecked_int.call(null,rgb),alpha);\n});\n\nquil.core$macros.stroke_int.cljs$lang$maxFixedArity = (2);\n/**\n * Sets the color used to draw lines and borders around shapes. This\n *   color is either specified in terms of the RGB or HSB color depending\n *   on the current color-mode (the default color space is RGB, with\n *   each value in the range from 0 to 255).\n */\nquil.core$macros.stroke = (function quil$core$macros$stroke(var_args){\nvar args546 = [];\nvar len__3279__auto___549 = arguments.length;\nvar i__3280__auto___550 = (0);\nwhile(true){\nif((i__3280__auto___550 < len__3279__auto___549)){\nargs546.push((arguments[i__3280__auto___550]));\n\nvar G__551 = (i__3280__auto___550 + (1));\ni__3280__auto___550 = G__551;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__548 = args546.length;\nswitch (G__548) {\ncase (1):\nreturn quil.core$macros.stroke.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.stroke.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.stroke.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.stroke.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args546.length)].join('')));\n\n}\n});\n\nquil.core$macros.stroke.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core$macros.stroke_float.call(null,rgb);\n});\n\nquil.core$macros.stroke.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core$macros.stroke_float.call(null,rgb,alpha);\n});\n\nquil.core$macros.stroke.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.stroke_float.call(null,x,y,z);\n});\n\nquil.core$macros.stroke.cljs$core$IFn$_invoke$arity$4 = (function (x,y,z,a){\nreturn quil.core$macros.stroke_float.call(null,x,y,z,a);\n});\n\nquil.core$macros.stroke.cljs$lang$maxFixedArity = (4);\n/**\n * Sets the style for rendering line endings. These ends are either\n *   squared, extended, or rounded and specified with the corresponding\n *   parameters :square, :project, and :round. The default cap is :round.\n */\nquil.core$macros.stroke_cap = (function quil$core$macros$stroke_cap(cap_mode){\nvar cap_mode__$1 = quil.util.resolve_constant_key.call(null,cap_mode,quil.core$macros.stroke_cap_modes);\nreturn quil.core$macros.current_graphics.call(null).strokeCap([cljs.core.str(cap_mode__$1)].join(''));\n});\n/**\n * Sets the style of the joints which connect line\n *   segments. These joints are either mitered, beveled, or rounded and\n *   specified with the corresponding parameters :miter, :bevel, and\n *   :round. The default joint is :miter.\n * \n *   This function is not available with the :p2d, :p3d, or :opengl\n *   renderers.\n */\nquil.core$macros.stroke_join = (function quil$core$macros$stroke_join(join_mode){\nvar join_mode__$1 = quil.util.resolve_constant_key.call(null,join_mode,quil.core$macros.stroke_join_modes);\nreturn quil.core$macros.current_graphics.call(null).strokeJoin([cljs.core.str(join_mode__$1)].join(''));\n});\n/**\n * Sets the width of the stroke used for lines, points, and the border\n *   around shapes. All widths are set in units of pixels. \n */\nquil.core$macros.stroke_weight = (function quil$core$macros$stroke_weight(weight){\nreturn quil.core$macros.current_graphics.call(null).strokeWeight(weight);\n});\n/**\n * Calculates the ratio of the sine and cosine of an angle. This\n *   function expects the values of the angle parameter to be provided in\n *   radians (values from 0 to PI*2). Values are returned in the range\n *   infinity to -infinity.\n */\nquil.core$macros.tan = (function quil$core$macros$tan(angle){\nreturn quil.sketch.current_applet.call(null).tan(angle);\n});\n/**\n * Returns the target framerate specified with the fn frame-rate\n */\nquil.core$macros.target_frame_rate = (function quil$core$macros$target_frame_rate(){\nreturn cljs.core.deref.call(null,quil.sketch.current_applet.call(null).target_frame_rate);\n});\n/**\n * Returns whether fill is disabled for current graphics.\n */\nquil.core$macros.no_fill_QMARK_ = (function quil$core$macros$no_fill_QMARK_(graphics){\nreturn (graphics[quil.core$macros.no_fill_prop]) === true;\n});\n/**\n * Draws a char to the screen in the specified position. See text fn\n *   for more details.\n */\nquil.core$macros.text_char = (function quil$core$macros$text_char(var_args){\nvar args553 = [];\nvar len__3279__auto___556 = arguments.length;\nvar i__3280__auto___557 = (0);\nwhile(true){\nif((i__3280__auto___557 < len__3279__auto___556)){\nargs553.push((arguments[i__3280__auto___557]));\n\nvar G__558 = (i__3280__auto___557 + (1));\ni__3280__auto___557 = G__558;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__555 = args553.length;\nswitch (G__555) {\ncase (3):\nreturn quil.core$macros.text_char.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.text_char.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args553.length)].join('')));\n\n}\n});\n\nquil.core$macros.text_char.cljs$core$IFn$_invoke$arity$3 = (function (c,x,y){\nif(cljs.core.truth_(quil.core$macros.no_fill_QMARK_.call(null,quil.core$macros.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core$macros.current_graphics.call(null).text(cljs.core.char$.call(null,c),x,y);\n}\n});\n\nquil.core$macros.text_char.cljs$core$IFn$_invoke$arity$4 = (function (c,x,y,z){\nif(cljs.core.truth_(quil.core$macros.no_fill_QMARK_.call(null,quil.core$macros.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core$macros.current_graphics.call(null).text(cljs.core.char$.call(null,c),x,y,z);\n}\n});\n\nquil.core$macros.text_char.cljs$lang$maxFixedArity = (4);\n/**\n * Draws a number to the screen in the specified position. See text fn\n *   for more details.\n */\nquil.core$macros.text_num = (function quil$core$macros$text_num(var_args){\nvar args560 = [];\nvar len__3279__auto___563 = arguments.length;\nvar i__3280__auto___564 = (0);\nwhile(true){\nif((i__3280__auto___564 < len__3279__auto___563)){\nargs560.push((arguments[i__3280__auto___564]));\n\nvar G__565 = (i__3280__auto___564 + (1));\ni__3280__auto___564 = G__565;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__562 = args560.length;\nswitch (G__562) {\ncase (3):\nreturn quil.core$macros.text_num.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.text_num.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args560.length)].join('')));\n\n}\n});\n\nquil.core$macros.text_num.cljs$core$IFn$_invoke$arity$3 = (function (num,x,y){\nif(cljs.core.truth_(quil.core$macros.no_fill_QMARK_.call(null,quil.core$macros.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core$macros.current_graphics.call(null).text(num,x,y);\n}\n});\n\nquil.core$macros.text_num.cljs$core$IFn$_invoke$arity$4 = (function (num,x,y,z){\nif(cljs.core.truth_(quil.core$macros.no_fill_QMARK_.call(null,quil.core$macros.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core$macros.current_graphics.call(null).text(num,x,y,z);\n}\n});\n\nquil.core$macros.text_num.cljs$lang$maxFixedArity = (4);\n/**\n * Draws text to the screen in the position specified by the x and y\n *   parameters and the optional z parameter. A default font will be used\n *   unless a font is set with the text-font fn. Change the color of the\n *   text with the fill fn. The text displays in relation to the\n *   text-align fn, which gives the option to draw to the left, right, and\n *   center of the coordinates.\n * \n *   The x1, y1, x2 and y2 parameters define a\n *   rectangular area to display within and may only be used with string\n *   data. For text drawn inside a rectangle, the coordinates are\n *   interpreted based on the current rect-mode setting.\n */\nquil.core$macros.text = (function quil$core$macros$text(var_args){\nvar args567 = [];\nvar len__3279__auto___570 = arguments.length;\nvar i__3280__auto___571 = (0);\nwhile(true){\nif((i__3280__auto___571 < len__3279__auto___570)){\nargs567.push((arguments[i__3280__auto___571]));\n\nvar G__572 = (i__3280__auto___571 + (1));\ni__3280__auto___571 = G__572;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__569 = args567.length;\nswitch (G__569) {\ncase (3):\nreturn quil.core$macros.text.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.text.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (5):\nreturn quil.core$macros.text.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args567.length)].join('')));\n\n}\n});\n\nquil.core$macros.text.cljs$core$IFn$_invoke$arity$3 = (function (s,x,y){\nif(cljs.core.truth_(quil.core$macros.no_fill_QMARK_.call(null,quil.core$macros.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core$macros.current_graphics.call(null).text(s,x,y);\n}\n});\n\nquil.core$macros.text.cljs$core$IFn$_invoke$arity$4 = (function (s,x,y,z){\nif(cljs.core.truth_(quil.core$macros.no_fill_QMARK_.call(null,quil.core$macros.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core$macros.current_graphics.call(null).text(s,x,y,z);\n}\n});\n\nquil.core$macros.text.cljs$core$IFn$_invoke$arity$5 = (function (s,x1,y1,x2,y2){\nif(cljs.core.truth_(quil.core$macros.no_fill_QMARK_.call(null,quil.core$macros.current_graphics.call(null)))){\nreturn null;\n} else {\nreturn quil.core$macros.current_graphics.call(null).text(s,x1,y1,x2,y2);\n}\n});\n\nquil.core$macros.text.cljs$lang$maxFixedArity = (5);\n/**\n * Sets the current alignment for drawing text. Available modes are:\n * \n *   horizontal - :left, :center, and :right\n *   vertical   - :top, :bottom, :center, and :baseline\n * \n *   An optional second parameter specifies the vertical alignment\n *   mode. :baseline is the default. The :top and :center parameters are\n *   straightforward. The :bottom parameter offsets the line based on the\n *   current text-descent. For multiple lines, the final line will be\n *   aligned to the bottom, with the previous lines appearing above it.\n * \n *   When using text with width and height parameters, :baseline is\n *   ignored, and treated as :top. (Otherwise, text would by default draw\n *   outside the box, since :baseline is the default setting. :baseline is\n *   not a useful drawing mode for text drawn in a rectangle.)\n * \n *   The vertical alignment is based on the value of text-ascent, which\n *   many fonts do not specify correctly. It may be necessary to use a\n *   hack and offset by a few pixels by hand so that the offset looks\n *   correct. To do this as less of a hack, use some percentage of\n *   text-ascent or text-descent so that the hack works even if you\n *   change the size of the font.\n */\nquil.core$macros.text_align = (function quil$core$macros$text_align(var_args){\nvar args574 = [];\nvar len__3279__auto___577 = arguments.length;\nvar i__3280__auto___578 = (0);\nwhile(true){\nif((i__3280__auto___578 < len__3279__auto___577)){\nargs574.push((arguments[i__3280__auto___578]));\n\nvar G__579 = (i__3280__auto___578 + (1));\ni__3280__auto___578 = G__579;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__576 = args574.length;\nswitch (G__576) {\ncase (1):\nreturn quil.core$macros.text_align.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.text_align.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args574.length)].join('')));\n\n}\n});\n\nquil.core$macros.text_align.cljs$core$IFn$_invoke$arity$1 = (function (align){\nvar align__$1 = quil.util.resolve_constant_key.call(null,align,quil.core$macros.horizontal_alignment_modes);\nreturn quil.core$macros.current_graphics.call(null).textAlign((align__$1 | (0)));\n});\n\nquil.core$macros.text_align.cljs$core$IFn$_invoke$arity$2 = (function (align_x,align_y){\nvar align_x__$1 = quil.util.resolve_constant_key.call(null,align_x,quil.core$macros.horizontal_alignment_modes);\nvar align_y__$1 = quil.util.resolve_constant_key.call(null,align_y,quil.core$macros.vertical_alignment_modes);\nreturn quil.core$macros.current_graphics.call(null).textAlign((align_x__$1 | (0)),(align_y__$1 | (0)));\n});\n\nquil.core$macros.text_align.cljs$lang$maxFixedArity = (2);\n/**\n * Returns the ascent of the current font at its current size. This\n *   information is useful for determining the height of the font above\n *   the baseline. For example, adding the text-ascent and text-descent\n *   values will give you the total height of the line.\n */\nquil.core$macros.text_ascent = (function quil$core$macros$text_ascent(){\nreturn quil.core$macros.current_graphics.call(null).textAscent();\n});\n/**\n * Returns descent of the current font at its current size. This\n *   information is useful for determining the height of the font below\n *   the baseline. For example, adding the text-ascent and text-descent\n *   values will give you the total height of the line.\n */\nquil.core$macros.text_descent = (function quil$core$macros$text_descent(){\nreturn quil.core$macros.current_graphics.call(null).textDescent();\n});\n/**\n * Sets the current font that will be drawn with the text\n *   function. Fonts must be loaded with load-font before it can be\n *   used. This font will be used in all subsequent calls to the text\n *   function. If no size parameter is input, the font will appear at its\n *   original size until it is changed with text-size.\n * \n *   Because fonts are usually bitmaped, you should create fonts at the\n *   sizes that will be used most commonly. Using textFont without the\n *   size parameter will result in the cleanest-looking text.\n * \n *   With the default (JAVA2D) and PDF renderers, it's also possible to\n *   enable the use of native fonts via the command\n *   (hint :enable-native-fonts). This will produce vector text in JAVA2D\n *   sketches and PDF output in cases where the vector data is available:\n *   when the font is still installed, or the font is created via the\n *   create-font fn\n */\nquil.core$macros.text_font = (function quil$core$macros$text_font(var_args){\nvar args581 = [];\nvar len__3279__auto___584 = arguments.length;\nvar i__3280__auto___585 = (0);\nwhile(true){\nif((i__3280__auto___585 < len__3279__auto___584)){\nargs581.push((arguments[i__3280__auto___585]));\n\nvar G__586 = (i__3280__auto___585 + (1));\ni__3280__auto___585 = G__586;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__583 = args581.length;\nswitch (G__583) {\ncase (1):\nreturn quil.core$macros.text_font.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.text_font.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args581.length)].join('')));\n\n}\n});\n\nquil.core$macros.text_font.cljs$core$IFn$_invoke$arity$1 = (function (font){\nreturn quil.core$macros.current_graphics.call(null).textFont(font);\n});\n\nquil.core$macros.text_font.cljs$core$IFn$_invoke$arity$2 = (function (font,size){\nreturn quil.core$macros.current_graphics.call(null).textFont(font,(size | (0)));\n});\n\nquil.core$macros.text_font.cljs$lang$maxFixedArity = (2);\n/**\n * Sets the spacing between lines of text in units of pixels. This\n *   setting will be used in all subsequent calls to the text function.\n */\nquil.core$macros.text_leading = (function quil$core$macros$text_leading(leading){\nreturn quil.core$macros.current_graphics.call(null).textLeading(leading);\n});\n/**\n * Sets the way text draws to the screen - available modes\n *   are :model and :shape\n * \n *   In the default configuration (the :model mode), it's possible to\n *   rotate, scale, and place letters in two and three dimensional space.\n * \n *   The :shape mode draws text using the glyph outlines of individual\n *   characters rather than as textures. This mode is only supported with\n *   the PDF and OPENGL renderer settings. With the PDF renderer, you\n *   must specify the :shape text-mode before any other drawing occurs.\n *   If the outlines are not available, then :shape will be ignored and\n *   :model will be used instead.\n * \n *   The :shape option in OPENGL mode can be combined with begin-raw to\n *   write vector-accurate text to 2D and 3D output files, for instance\n *   DXF or PDF. :shape is not currently optimized for OPENGL, so if\n *   recording shape data, use :model until you're ready to capture the\n *   geometry with begin-raw.\n */\nquil.core$macros.text_mode = (function quil$core$macros$text_mode(mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.text_modes);\nreturn quil.core$macros.current_graphics.call(null).textMode((mode__$1 | (0)));\n});\n/**\n * Sets the current font size. This size will be used in all\n *   subsequent calls to the text fn. Font size is measured in\n *   units of pixels.\n */\nquil.core$macros.text_size = (function quil$core$macros$text_size(size){\nreturn quil.core$macros.current_graphics.call(null).textSize(size);\n});\n/**\n * Sets a texture to be applied to vertex points. The texture fn must\n *   be called between begin-shape and end-shape and before any calls to\n *   vertex.\n * \n *   When textures are in use, the fill color is ignored. Instead, use\n *   tint to specify the color of the texture as it is applied to the\n *   shape.\n */\nquil.core$macros.texture = (function quil$core$macros$texture(img){\nreturn quil.core$macros.current_graphics.call(null).texture(img);\n});\n/**\n * Sets the coordinate space for texture mapping. There are two\n *   options, :image and :normal.\n * \n *   :image refers to the actual coordinates of the image and :normal\n *   refers to a normalized space of values ranging from 0 to 1. The\n *   default mode is :image. In :image, if an image is 100 x 200 pixels,\n *   mapping the image onto the entire size of a quad would require the\n *   points (0,0) (0,100) (100,200) (0,200). The same mapping in\n *   NORMAL_SPACE is (0,0) (0,1) (1,1) (0,1).\n */\nquil.core$macros.texture_mode = (function quil$core$macros$texture_mode(mode){\nvar mode__$1 = quil.util.resolve_constant_key.call(null,mode,quil.core$macros.texture_modes);\nreturn quil.core$macros.current_graphics.call(null).textureMode((mode__$1 | (0)));\n});\n/**\n * Calculates and returns the width of any text string.\n */\nquil.core$macros.text_width = (function quil$core$macros$text_width(data){\nreturn quil.core$macros.current_graphics.call(null).textWidth(data);\n});\n/**\n * Sets the fill value for displaying images. Images can be tinted to\n *   specified colors or made transparent by setting the alpha.\n * \n *   To make an image transparent, but not change it's color, use white\n *   as the tint color and specify an alpha value. For instance,\n *   tint(255, 128) will make an image 50% transparent (unless\n *   colorMode() has been used).\n * \n *   The value for the parameter gray must be less than or equal to the\n *   current maximum value as specified by colorMode(). The default\n *   maximum value is 255.\n * \n *   Also used to control the coloring of textures in 3D.\n */\nquil.core$macros.tint_float = (function quil$core$macros$tint_float(var_args){\nvar args588 = [];\nvar len__3279__auto___591 = arguments.length;\nvar i__3280__auto___592 = (0);\nwhile(true){\nif((i__3280__auto___592 < len__3279__auto___591)){\nargs588.push((arguments[i__3280__auto___592]));\n\nvar G__593 = (i__3280__auto___592 + (1));\ni__3280__auto___592 = G__593;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__590 = args588.length;\nswitch (G__590) {\ncase (1):\nreturn quil.core$macros.tint_float.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.tint_float.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.tint_float.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.tint_float.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args588.length)].join('')));\n\n}\n});\n\nquil.core$macros.tint_float.cljs$core$IFn$_invoke$arity$1 = (function (gray){\nreturn quil.core$macros.current_graphics.call(null).tint(gray);\n});\n\nquil.core$macros.tint_float.cljs$core$IFn$_invoke$arity$2 = (function (gray,alpha){\nreturn quil.core$macros.current_graphics.call(null).tint(gray,alpha);\n});\n\nquil.core$macros.tint_float.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core$macros.current_graphics.call(null).tint(r,g,b);\n});\n\nquil.core$macros.tint_float.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,a){\nreturn quil.core$macros.current_graphics.call(null).tint(g,g,b,a);\n});\n\nquil.core$macros.tint_float.cljs$lang$maxFixedArity = (4);\n/**\n * Sets the fill value for displaying images. Images can be tinted to\n *   specified colors or made transparent by setting the alpha.\n * \n *   To make an image transparent, but not change it's color, use white\n *   as the tint color and specify an alpha value. For instance,\n *   tint(255, 128) will make an image 50% transparent (unless\n *   colorMode() has been used).\n * \n *   The value for the parameter gray must be less than or equal to the\n *   current maximum value as specified by colorMode(). The default\n *   maximum value is 255.\n * \n *   Also used to control the coloring of textures in 3D.\n */\nquil.core$macros.tint_int = (function quil$core$macros$tint_int(var_args){\nvar args595 = [];\nvar len__3279__auto___598 = arguments.length;\nvar i__3280__auto___599 = (0);\nwhile(true){\nif((i__3280__auto___599 < len__3279__auto___598)){\nargs595.push((arguments[i__3280__auto___599]));\n\nvar G__600 = (i__3280__auto___599 + (1));\ni__3280__auto___599 = G__600;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__597 = args595.length;\nswitch (G__597) {\ncase (1):\nreturn quil.core$macros.tint_int.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.tint_int.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args595.length)].join('')));\n\n}\n});\n\nquil.core$macros.tint_int.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core$macros.current_graphics.call(null).tint(cljs.core.unchecked_int.call(null,rgb));\n});\n\nquil.core$macros.tint_int.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core$macros.current_graphics.call(null).tint(cljs.core.unchecked_int.call(null,rgb),alpha);\n});\n\nquil.core$macros.tint_int.cljs$lang$maxFixedArity = (2);\n/**\n * Sets the fill value for displaying images. Images can be tinted to\n *   specified colors or made transparent by setting the alpha.\n * \n *   To make an image transparent, but not change it's color, use white\n *   as the tint color and specify an alpha value. For instance,\n *   tint(255, 128) will make an image 50% transparent (unless\n *   colorMode() has been used).\n * \n *   The value for the parameter gray must be less than or equal to the\n *   current maximum value as specified by colorMode(). The default\n *   maximum value is 255.\n * \n *   Also used to control the coloring of textures in 3D.\n */\nquil.core$macros.tint = (function quil$core$macros$tint(var_args){\nvar args602 = [];\nvar len__3279__auto___605 = arguments.length;\nvar i__3280__auto___606 = (0);\nwhile(true){\nif((i__3280__auto___606 < len__3279__auto___605)){\nargs602.push((arguments[i__3280__auto___606]));\n\nvar G__607 = (i__3280__auto___606 + (1));\ni__3280__auto___606 = G__607;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__604 = args602.length;\nswitch (G__604) {\ncase (1):\nreturn quil.core$macros.tint.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.tint.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.tint.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.tint.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args602.length)].join('')));\n\n}\n});\n\nquil.core$macros.tint.cljs$core$IFn$_invoke$arity$1 = (function (rgb){\nreturn quil.core$macros.current_graphics.call(null).tint(rgb);\n});\n\nquil.core$macros.tint.cljs$core$IFn$_invoke$arity$2 = (function (rgb,alpha){\nreturn quil.core$macros.current_graphics.call(null).tint(rgb,alpha);\n});\n\nquil.core$macros.tint.cljs$core$IFn$_invoke$arity$3 = (function (r,g,b){\nreturn quil.core$macros.tint_float.call(null,r,g,b);\n});\n\nquil.core$macros.tint.cljs$core$IFn$_invoke$arity$4 = (function (r,g,b,a){\nreturn quil.core$macros.tint_float.call(null,r,g,b,a);\n});\n\nquil.core$macros.tint.cljs$lang$maxFixedArity = (4);\n/**\n * Specifies an amount to displace objects within the display\n *   window. The x parameter specifies left/right translation, the y\n *   parameter specifies up/down translation, and the z parameter\n *   specifies translations toward/away from the screen.  Transformations\n *   apply to everything that happens after and subsequent calls to the\n *   function accumulates the effect. For example, calling (translate 50\n *   0) and then (translate 20, 0) is the same as (translate 70, 0). If\n *   translate is called within draw, the transformation is reset when\n *   the loop begins again. This function can be further controlled by\n *   the push-matrix and pop-matrix.\n */\nquil.core$macros.translate = (function quil$core$macros$translate(var_args){\nvar args609 = [];\nvar len__3279__auto___612 = arguments.length;\nvar i__3280__auto___613 = (0);\nwhile(true){\nif((i__3280__auto___613 < len__3279__auto___612)){\nargs609.push((arguments[i__3280__auto___613]));\n\nvar G__614 = (i__3280__auto___613 + (1));\ni__3280__auto___613 = G__614;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__611 = args609.length;\nswitch (G__611) {\ncase (1):\nreturn quil.core$macros.translate.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase (2):\nreturn quil.core$macros.translate.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.translate.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args609.length)].join('')));\n\n}\n});\n\nquil.core$macros.translate.cljs$core$IFn$_invoke$arity$1 = (function (v){\nreturn cljs.core.apply.call(null,quil.core$macros.translate,v);\n});\n\nquil.core$macros.translate.cljs$core$IFn$_invoke$arity$2 = (function (tx,ty){\nreturn quil.core$macros.current_graphics.call(null).translate(tx,ty);\n});\n\nquil.core$macros.translate.cljs$core$IFn$_invoke$arity$3 = (function (tx,ty,tz){\nreturn quil.core$macros.current_graphics.call(null).translate(tx,ty,tz);\n});\n\nquil.core$macros.translate.cljs$lang$maxFixedArity = (3);\n/**\n * A triangle is a plane created by connecting three points. The first\n *   two arguments specify the first point, the middle two arguments\n *   specify the second point, and the last two arguments specify the\n *   third point.\n */\nquil.core$macros.triangle = (function quil$core$macros$triangle(x1,y1,x2,y2,x3,y3){\nreturn quil.core$macros.current_graphics.call(null).triangle(x1,y1,x2,y2,x3,y3);\n});\n/**\n * Unpack a binary string to an integer. See binary for converting\n *   integers to strings.\n */\nquil.core$macros.unbinary = (function quil$core$macros$unbinary(str_val){\nreturn quil.sketch.current_applet.call(null).unbinary([cljs.core.str(str_val)].join(''));\n});\n/**\n * Converts a String representation of a hexadecimal number to its\n *   equivalent integer value.\n */\nquil.core$macros.unhex = (function quil$core$macros$unhex(hex_str){\nreturn quil.sketch.current_applet.call(null).unhex([cljs.core.str(hex_str)].join(''));\n});\n/**\n * Updates the display window or image with the data in the pixels array.\n *   Use in conjunction with (pixels). If you're only reading pixels from\n *   the array, there's no need to call update-pixels unless there are\n *   changes.\n * \n *   Certain renderers may or may not seem to require pixels or\n *   update-pixels. However, the rule is that any time you want to\n *   manipulate the pixels array, you must first call pixels, and\n *   after changes have been made, call update-pixels. Even if the\n *   renderer may not seem to use this function in the current Processing\n *   release, this will always be subject to change.\n */\nquil.core$macros.update_pixels = (function quil$core$macros$update_pixels(var_args){\nvar args616 = [];\nvar len__3279__auto___619 = arguments.length;\nvar i__3280__auto___620 = (0);\nwhile(true){\nif((i__3280__auto___620 < len__3279__auto___619)){\nargs616.push((arguments[i__3280__auto___620]));\n\nvar G__621 = (i__3280__auto___620 + (1));\ni__3280__auto___620 = G__621;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__618 = args616.length;\nswitch (G__618) {\ncase (0):\nreturn quil.core$macros.update_pixels.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase (1):\nreturn quil.core$macros.update_pixels.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args616.length)].join('')));\n\n}\n});\n\nquil.core$macros.update_pixels.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn quil.core$macros.update_pixels.call(null,quil.core$macros.current_graphics.call(null));\n});\n\nquil.core$macros.update_pixels.cljs$core$IFn$_invoke$arity$1 = (function (img){\nvar temp__2279__auto___623 = img.stored_pix_array;\nif(cljs.core.truth_(temp__2279__auto___623)){\nvar pix_array_624 = temp__2279__auto___623;\nimg.pixels.set(pix_array_624);\n\nimg.stored_pix_array = null;\n} else {\n}\n\nreturn img.updatePixels();\n});\n\nquil.core$macros.update_pixels.cljs$lang$maxFixedArity = (1);\n/**\n * All shapes are constructed by connecting a series of\n *   vertices. vertex is used to specify the vertex coordinates for\n *   points, lines, triangles, quads, and polygons and is used\n *   exclusively within the begin-shape and end-shape fns.\n * \n *   Drawing a vertex in 3D using the z parameter requires the :p3d or\n *   :opengl renderers to be used.\n * \n *   This function is also used to map a texture onto the geometry. The\n *   texture fn declares the texture to apply to the geometry and the u\n *   and v coordinates set define the mapping of this texture to the\n *   form. By default, the coordinates used for u and v are specified in\n *   relation to the image's size in pixels, but this relation can be\n *   changed with texture-mode.\n */\nquil.core$macros.vertex = (function quil$core$macros$vertex(var_args){\nvar args625 = [];\nvar len__3279__auto___628 = arguments.length;\nvar i__3280__auto___629 = (0);\nwhile(true){\nif((i__3280__auto___629 < len__3279__auto___628)){\nargs625.push((arguments[i__3280__auto___629]));\n\nvar G__630 = (i__3280__auto___629 + (1));\ni__3280__auto___629 = G__630;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar G__627 = args625.length;\nswitch (G__627) {\ncase (2):\nreturn quil.core$macros.vertex.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase (3):\nreturn quil.core$macros.vertex.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase (4):\nreturn quil.core$macros.vertex.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase (5):\nreturn quil.core$macros.vertex.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));\n\nbreak;\ndefault:\nthrow (new Error([cljs.core.str(\"Invalid arity: \"),cljs.core.str(args625.length)].join('')));\n\n}\n});\n\nquil.core$macros.vertex.cljs$core$IFn$_invoke$arity$2 = (function (x,y){\nreturn quil.core$macros.current_graphics.call(null).vertex(x,y);\n});\n\nquil.core$macros.vertex.cljs$core$IFn$_invoke$arity$3 = (function (x,y,z){\nreturn quil.core$macros.current_graphics.call(null).vertex(x,y,z);\n});\n\nquil.core$macros.vertex.cljs$core$IFn$_invoke$arity$4 = (function (x,y,u,v){\nreturn quil.core$macros.current_graphics.call(null).vertex(x,y,u,v);\n});\n\nquil.core$macros.vertex.cljs$core$IFn$_invoke$arity$5 = (function (x,y,z,u,v){\nreturn quil.core$macros.current_graphics.call(null).vertex(x,y,z,u,v);\n});\n\nquil.core$macros.vertex.cljs$lang$maxFixedArity = (5);\n/**\n * Returns the current year as an integer (2003, 2004, 2005, etc).\n */\nquil.core$macros.year = (function quil$core$macros$year(){\nreturn quil.sketch.current_applet.call(null).year();\n});\n/**\n * Width of the display window. The value of width is zero until size is\n *   called.\n */\nquil.core$macros.width = (function quil$core$macros$width(){\nreturn quil.sketch.current_applet.call(null).width;\n});\n/**\n * Temporarily set the fill color for the body of this macro.\n * The code outside of with-fill form will have the previous fill color set.\n * \n * The fill color has to be in a vector!\n * Example: (with-fill [255] ...)\n *          (with-fill [10 80 98] ...)\n */\nquil.core$macros.with_fill = (function quil$core$macros$with_fill(var_args){\nvar args__3281__auto__ = [];\nvar len__3279__auto___636 = arguments.length;\nvar i__3280__auto___637 = (0);\nwhile(true){\nif((i__3280__auto___637 < len__3279__auto___636)){\nargs__3281__auto__.push((arguments[i__3280__auto___637]));\n\nvar G__638 = (i__3280__auto___637 + (1));\ni__3280__auto___637 = G__638;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__3282__auto__ = ((((3) < args__3281__auto__.length))?(new cljs.core.IndexedSeq(args__3281__auto__.slice((3)),(0),null)):null);\nreturn quil.core$macros.with_fill.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__3282__auto__);\n});\n\nquil.core$macros.with_fill.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,fill_args,body){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"let\",\"let\",(358118826),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"old-fill__11__auto__\",\"old-fill__11__auto__\",(-1432464131),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"current-fill\",\"quil.core/current-fill\",(269663137),null))))))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"apply\",\"apply\",(-1334050276),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"fill\",\"quil.core/fill\",(814613078),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,fill_args)))),body,cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"fill\",\"quil.core/fill\",(814613078),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"old-fill__11__auto__\",\"old-fill__11__auto__\",(-1432464131),null)))))));\n});\n\nquil.core$macros.with_fill.cljs$lang$maxFixedArity = (3);\n\nquil.core$macros.with_fill.cljs$lang$applyTo = (function (seq632){\nvar G__633 = cljs.core.first.call(null,seq632);\nvar seq632__$1 = cljs.core.next.call(null,seq632);\nvar G__634 = cljs.core.first.call(null,seq632__$1);\nvar seq632__$2 = cljs.core.next.call(null,seq632__$1);\nvar G__635 = cljs.core.first.call(null,seq632__$2);\nvar seq632__$3 = cljs.core.next.call(null,seq632__$2);\nreturn quil.core$macros.with_fill.cljs$core$IFn$_invoke$arity$variadic(G__633,G__634,G__635,seq632__$3);\n});\n\nquil.core$macros.with_fill.cljs$lang$macro = true;\n/**\n * Temporarily set the stroke color for the body of this macro.\n * The code outside of with-stroke form will have the previous stroke color set.\n * \n * The stroke color has to be in a vector!\n * Example: (with-stroke [255] ...)\n *          (with-stroke [10 80 98] ...)\n */\nquil.core$macros.with_stroke = (function quil$core$macros$with_stroke(var_args){\nvar args__3281__auto__ = [];\nvar len__3279__auto___643 = arguments.length;\nvar i__3280__auto___644 = (0);\nwhile(true){\nif((i__3280__auto___644 < len__3279__auto___643)){\nargs__3281__auto__.push((arguments[i__3280__auto___644]));\n\nvar G__645 = (i__3280__auto___644 + (1));\ni__3280__auto___644 = G__645;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__3282__auto__ = ((((3) < args__3281__auto__.length))?(new cljs.core.IndexedSeq(args__3281__auto__.slice((3)),(0),null)):null);\nreturn quil.core$macros.with_stroke.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__3282__auto__);\n});\n\nquil.core$macros.with_stroke.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,stroke_args,body){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"let\",\"let\",(358118826),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"old-stroke__12__auto__\",\"old-stroke__12__auto__\",(-1181229123),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"current-stroke\",\"quil.core/current-stroke\",(-1148124489),null))))))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"apply\",\"apply\",(-1334050276),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"stroke\",\"quil.core/stroke\",(577473004),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,stroke_args)))),body,cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"stroke\",\"quil.core/stroke\",(577473004),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"old-stroke__12__auto__\",\"old-stroke__12__auto__\",(-1181229123),null)))))));\n});\n\nquil.core$macros.with_stroke.cljs$lang$maxFixedArity = (3);\n\nquil.core$macros.with_stroke.cljs$lang$applyTo = (function (seq639){\nvar G__640 = cljs.core.first.call(null,seq639);\nvar seq639__$1 = cljs.core.next.call(null,seq639);\nvar G__641 = cljs.core.first.call(null,seq639__$1);\nvar seq639__$2 = cljs.core.next.call(null,seq639__$1);\nvar G__642 = cljs.core.first.call(null,seq639__$2);\nvar seq639__$3 = cljs.core.next.call(null,seq639__$2);\nreturn quil.core$macros.with_stroke.cljs$core$IFn$_invoke$arity$variadic(G__640,G__641,G__642,seq639__$3);\n});\n\nquil.core$macros.with_stroke.cljs$lang$macro = true;\n/**\n * Performs body with translation, restores current transformation on\n *   exit.\n */\nquil.core$macros.with_translation = (function quil$core$macros$with_translation(var_args){\nvar args__3281__auto__ = [];\nvar len__3279__auto___650 = arguments.length;\nvar i__3280__auto___651 = (0);\nwhile(true){\nif((i__3280__auto___651 < len__3279__auto___650)){\nargs__3281__auto__.push((arguments[i__3280__auto___651]));\n\nvar G__652 = (i__3280__auto___651 + (1));\ni__3280__auto___651 = G__652;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__3282__auto__ = ((((3) < args__3281__auto__.length))?(new cljs.core.IndexedSeq(args__3281__auto__.slice((3)),(0),null)):null);\nreturn quil.core$macros.with_translation.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__3282__auto__);\n});\n\nquil.core$macros.with_translation.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,translation_vector,body){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"let\",\"let\",(358118826),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"tr__13__auto__\",\"tr__13__auto__\",(1325556268),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,translation_vector))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"push-matrix\",\"quil.core/push-matrix\",(1356326676),null))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"try\",\"try\",(-1273693247),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"translate\",\"quil.core/translate\",(150889028),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"tr__13__auto__\",\"tr__13__auto__\",(1325556268),null))))),body,cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"finally\",\"finally\",(-1065347064),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"pop-matrix\",\"quil.core/pop-matrix\",(310892617),null)))))))))))));\n});\n\nquil.core$macros.with_translation.cljs$lang$maxFixedArity = (3);\n\nquil.core$macros.with_translation.cljs$lang$applyTo = (function (seq646){\nvar G__647 = cljs.core.first.call(null,seq646);\nvar seq646__$1 = cljs.core.next.call(null,seq646);\nvar G__648 = cljs.core.first.call(null,seq646__$1);\nvar seq646__$2 = cljs.core.next.call(null,seq646__$1);\nvar G__649 = cljs.core.first.call(null,seq646__$2);\nvar seq646__$3 = cljs.core.next.call(null,seq646__$2);\nreturn quil.core$macros.with_translation.cljs$core$IFn$_invoke$arity$variadic(G__647,G__648,G__649,seq646__$3);\n});\n\nquil.core$macros.with_translation.cljs$lang$macro = true;\n/**\n * Performs body with rotation, restores current transformation on exit.\n *   Accepts a vector [angle] or [angle x-axis y-axis z-axis].\n * \n *   Example:\n *  (with-rotation [angle]\n *    (vertex 1 2))\n */\nquil.core$macros.with_rotation = (function quil$core$macros$with_rotation(var_args){\nvar args__3281__auto__ = [];\nvar len__3279__auto___657 = arguments.length;\nvar i__3280__auto___658 = (0);\nwhile(true){\nif((i__3280__auto___658 < len__3279__auto___657)){\nargs__3281__auto__.push((arguments[i__3280__auto___658]));\n\nvar G__659 = (i__3280__auto___658 + (1));\ni__3280__auto___658 = G__659;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__3282__auto__ = ((((3) < args__3281__auto__.length))?(new cljs.core.IndexedSeq(args__3281__auto__.slice((3)),(0),null)):null);\nreturn quil.core$macros.with_rotation.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__3282__auto__);\n});\n\nquil.core$macros.with_rotation.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,rotation,body){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"let\",\"let\",(358118826),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"tr__14__auto__\",\"tr__14__auto__\",(448676950),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,rotation))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"push-matrix\",\"quil.core/push-matrix\",(1356326676),null))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"try\",\"try\",(-1273693247),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"apply\",\"apply\",(-1334050276),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"rotate\",\"quil.core/rotate\",(-1944995048),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"tr__14__auto__\",\"tr__14__auto__\",(448676950),null))))),body,cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"finally\",\"finally\",(-1065347064),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"pop-matrix\",\"quil.core/pop-matrix\",(310892617),null)))))))))))));\n});\n\nquil.core$macros.with_rotation.cljs$lang$maxFixedArity = (3);\n\nquil.core$macros.with_rotation.cljs$lang$applyTo = (function (seq653){\nvar G__654 = cljs.core.first.call(null,seq653);\nvar seq653__$1 = cljs.core.next.call(null,seq653);\nvar G__655 = cljs.core.first.call(null,seq653__$1);\nvar seq653__$2 = cljs.core.next.call(null,seq653__$1);\nvar G__656 = cljs.core.first.call(null,seq653__$2);\nvar seq653__$3 = cljs.core.next.call(null,seq653__$2);\nreturn quil.core$macros.with_rotation.cljs$core$IFn$_invoke$arity$variadic(G__654,G__655,G__656,seq653__$3);\n});\n\nquil.core$macros.with_rotation.cljs$lang$macro = true;\n/**\n * All subsequent calls of any drawing function will draw on given\n *   graphics. 'with-graphics' cannot be nested (you can draw simultaneously\n *   only on 1 graphics)\n */\nquil.core$macros.with_graphics = (function quil$core$macros$with_graphics(var_args){\nvar args__3281__auto__ = [];\nvar len__3279__auto___664 = arguments.length;\nvar i__3280__auto___665 = (0);\nwhile(true){\nif((i__3280__auto___665 < len__3279__auto___664)){\nargs__3281__auto__.push((arguments[i__3280__auto___665]));\n\nvar G__666 = (i__3280__auto___665 + (1));\ni__3280__auto___665 = G__666;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__3282__auto__ = ((((3) < args__3281__auto__.length))?(new cljs.core.IndexedSeq(args__3281__auto__.slice((3)),(0),null)):null);\nreturn quil.core$macros.with_graphics.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__3282__auto__);\n});\n\nquil.core$macros.with_graphics.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,graphics,body){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\"binding\",\"binding\",(-2114503176),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.vec.call(null,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.core\",\"*graphics*\",\"quil.core/*graphics*\",(-1088142302),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,graphics))))),cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\".beginDraw\",\".beginDraw\",(1110767550),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,graphics)))),body,cljs.core._conj.call(null,cljs.core.List.EMPTY,cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(null,\".endDraw\",\".endDraw\",(795589408),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,graphics))))));\n});\n\nquil.core$macros.with_graphics.cljs$lang$maxFixedArity = (3);\n\nquil.core$macros.with_graphics.cljs$lang$applyTo = (function (seq660){\nvar G__661 = cljs.core.first.call(null,seq660);\nvar seq660__$1 = cljs.core.next.call(null,seq660);\nvar G__662 = cljs.core.first.call(null,seq660__$1);\nvar seq660__$2 = cljs.core.next.call(null,seq660__$1);\nvar G__663 = cljs.core.first.call(null,seq660__$2);\nvar seq660__$3 = cljs.core.next.call(null,seq660__$2);\nreturn quil.core$macros.with_graphics.cljs$core$IFn$_invoke$arity$variadic(G__661,G__662,G__663,seq660__$3);\n});\n\nquil.core$macros.with_graphics.cljs$lang$macro = true;\n/**\n * Create and start a new visualisation applet. Can be used to create\n *   new sketches programmatically. See documentation for 'defsketch' for\n *   list of available options.\n */\nquil.core$macros.sketch = (function quil$core$macros$sketch(var_args){\nvar args__3281__auto__ = [];\nvar len__3279__auto___668 = arguments.length;\nvar i__3280__auto___669 = (0);\nwhile(true){\nif((i__3280__auto___669 < len__3279__auto___668)){\nargs__3281__auto__.push((arguments[i__3280__auto___669]));\n\nvar G__670 = (i__3280__auto___669 + (1));\ni__3280__auto___669 = G__670;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__3282__auto__ = ((((0) < args__3281__auto__.length))?(new cljs.core.IndexedSeq(args__3281__auto__.slice((0)),(0),null)):null);\nreturn quil.core$macros.sketch.cljs$core$IFn$_invoke$arity$variadic(argseq__3282__auto__);\n});\n\nquil.core$macros.sketch.cljs$core$IFn$_invoke$arity$variadic = (function (opts){\nreturn cljs.core.apply.call(null,quil.sketch.sketch,opts);\n});\n\nquil.core$macros.sketch.cljs$lang$maxFixedArity = (0);\n\nquil.core$macros.sketch.cljs$lang$applyTo = (function (seq667){\nreturn quil.core$macros.sketch.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq.call(null,seq667));\n});\n/**\n * Define and start a sketch and bind it to a var with the symbol\n *   app-name. If any of the options to the various callbacks are\n *   symbols, it wraps them in a call to var to ensure they aren't\n *   inlined and that redefinitions to the original fns are reflected in\n *   the visualisation.\n * \n *   Available options:\n * \n * :size           - A vector of width and height for the sketch or :fullscreen.\n *                   Defaults to [500 300]. If you're using :fullscreen you may\n *                   want to enable present mode - :features [:present]\n * \n * :renderer       - Specifies the renderer type. One of :p2d, :p3d, :java2d,\n *                   :opengl, :pdf). Defaults to :java2d. :dxf renderer\n *                   can't be used as sketch renderer. Use begin-raw method\n *                   instead. In clojurescript only :p2d and :p3d renderers\n *                   are supported.\n * \n * :output-file    - Specifies an output file path. Only used in :pdf mode.\n *                   Not supported in clojurescript.\n * \n * :title          - A string which will be displayed at the top of\n *                   the sketch window. Not supported in clojurescript.\n * \n * :features       - A vector of keywords customizing sketch behaviour.\n *                   Supported features:\n * \n *                   :keep-on-top - Sketch window will always be above other\n *                                  windows. Note: some platforms might not\n *                                  support always-on-top windows.\n *                                  Not supported in clojurescript.\n * \n *                   :exit-on-close - Shutdown JVM  when sketch is closed.\n *                                    Not supported in clojurescript.\n * \n *                   :resizable - Makes sketch resizable.\n *                                Not supported in clojurescript.\n * \n *                   :no-safe-fns - Do not catch and print exceptions thrown\n *                                  inside functions provided to sketch (like\n *                                  draw, mouse-click, key-pressed and\n *                                  other). By default all exceptions thrown\n *                                  inside these functions are catched. This\n *                                  prevents sketch from breaking when bad\n *                                  function was provided and allows you to\n *                                  fix it and reload it on fly. You can\n *                                  disable this behaviour by enabling\n *                                  :no-safe-fns feature.\n *                                  Not supported in clojurescript.\n * \n *                   :present - Switch to present mode (fullscreen without\n *                              borders, OS panels). You may want to use\n *                              this feature together with :size :fullscreen.\n *                              Not supported in clojurescript.\n * \n *                   :no-start - Disables autostart if sketch was created using\n *                               defsketch macro. To start sketch you have to\n *                               call function created defsketch.\n *                               Supported only in clojurescript.\n * \n *                   :global-key-events - Allows a sketch to receive any\n *                                        keyboard event sent to the page,\n *                                        regardless of whether the canvas it is\n *                                        loaded in has focus or not.\n *                                        Supported only in clojurescript.\n * \n *                   Usage example: :features [:keep-on-top :present]\n * \n * :bgcolor        - Sets background color for unused space in present mode.\n *                   Color is specified in hex format: #XXXXXX.\n *                   Example: :bgcolor \"#00FFFF\" (cyan background)\n *                   Not supported in clojurescript.\n * \n * :display        - Sets what display should be used by this sketch.\n *                   Displays are numbered starting from 0. Example: :display 1.\n *                   Not supported in clojurescript.\n * \n * :setup          - A function to be called once when setting the sketch up.\n * \n * :draw           - A function to be repeatedly called at most n times per\n *                   second where n is the target frame-rate set for\n *                   the visualisation.\n * \n * :host           - String id of canvas element or DOM element itself.\n *                   Specifies host for the sketch. Must be specified in sketch,\n *                   may be omitted in defsketch. If ommitted in defsketch,\n *                   :host is set to the name of the sketch. If element with\n *                   specified id is not found on the page and page is empty -\n *                   new canvas element will be created. Used in clojurescript.\n * \n * :focus-gained   - Called when the sketch gains focus.\n *                   Not supported in clojurescript.\n * \n * :focus-lost     - Called when the sketch loses focus.\n *                   Not supported in clojurescript.\n * \n * :mouse-entered  - Called when the mouse enters the sketch window.\n * \n * :mouse-exited   - Called when the mouse leaves the sketch window\n * \n * :mouse-pressed  - Called every time a mouse button is pressed.\n * \n * :mouse-released - Called every time a mouse button is released.\n * \n * :mouse-clicked  - called once after a mouse button has been pressed\n *                   and then released.\n * \n * :mouse-moved    - Called every time the mouse moves and a button is\n *                   not pressed.\n * \n * :mouse-dragged  - Called every time the mouse moves and a button is\n *                   pressed.\n * \n * :mouse-wheel    - Called every time mouse wheel is rotated.\n *                   Takes 1 argument - wheel rotation, an int.\n *                   Negative values if the mouse wheel was rotated\n *                   up/away from the user, and positive values\n *                   if the mouse wheel was rotated down/ towards the user\n * \n * :key-pressed    - Called every time any key is pressed.\n * \n * :key-released   - Called every time any key is released.\n * \n * :key-typed      - Called once every time non-modifier keys are\n *                   pressed.\n * \n * :on-close       - Called once, when sketch is closed\n *                   Not supported in clojurescript.\n * \n * :middleware     - Vector of middleware to be applied to the sketch.\n *                   Middleware will be applied in the same order as in comp\n *                   function: [f g] will be applied as (f (g options)).\n * \n * :settings       - cousin of :setup. A function to be called once when\n *                   setting sketch up. Should be used only for (smooth) and\n *                   (no-smooth). Due to Processing limitations these functions\n *                   cannot be used neither in :setup nor in :draw.\n */\nquil.core$macros.defsketch = (function quil$core$macros$defsketch(var_args){\nvar args__3281__auto__ = [];\nvar len__3279__auto___675 = arguments.length;\nvar i__3280__auto___676 = (0);\nwhile(true){\nif((i__3280__auto___676 < len__3279__auto___675)){\nargs__3281__auto__.push((arguments[i__3280__auto___676]));\n\nvar G__677 = (i__3280__auto___676 + (1));\ni__3280__auto___676 = G__677;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__3282__auto__ = ((((3) < args__3281__auto__.length))?(new cljs.core.IndexedSeq(args__3281__auto__.slice((3)),(0),null)):null);\nreturn quil.core$macros.defsketch.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__3282__auto__);\n});\n\nquil.core$macros.defsketch.cljs$core$IFn$_invoke$arity$variadic = (function (_AMPERSAND_form,_AMPERSAND_env,app_name,options){\nreturn cljs.core.sequence.call(null,cljs.core.concat.call(null,cljs.core._conj.call(null,cljs.core.List.EMPTY,new cljs.core.Symbol(\"quil.sketch$macros\",\"defsketch\",\"quil.sketch$macros/defsketch\",(2065609719),null)),cljs.core._conj.call(null,cljs.core.List.EMPTY,app_name),options));\n});\n\nquil.core$macros.defsketch.cljs$lang$maxFixedArity = (3);\n\nquil.core$macros.defsketch.cljs$lang$applyTo = (function (seq671){\nvar G__672 = cljs.core.first.call(null,seq671);\nvar seq671__$1 = cljs.core.next.call(null,seq671);\nvar G__673 = cljs.core.first.call(null,seq671__$1);\nvar seq671__$2 = cljs.core.next.call(null,seq671__$1);\nvar G__674 = cljs.core.first.call(null,seq671__$2);\nvar seq671__$3 = cljs.core.next.call(null,seq671__$2);\nreturn quil.core$macros.defsketch.cljs$core$IFn$_invoke$arity$variadic(G__672,G__673,G__674,seq671__$3);\n});\n\nquil.core$macros.defsketch.cljs$lang$macro = true;\n/**\n * Returns true if char c is a 'coded' char i.e. it is necessary to\n *   fetch the key-code as an integer and use that to determine the\n *   specific key pressed. See key-keyword.\n */\nquil.core$macros.key_coded_QMARK_ = (function quil$core$macros$key_coded_QMARK_(c){\nreturn cljs.core._EQ_.call(null,(65535),[cljs.core.str(c)].join('').charCodeAt());\n});\n/**\n * Returns a keyword representing the currently pressed key. Modifier\n *   keys are represented as: :up, :down, :left, :right, :alt, :control,\n *   :shift, :command, :f1-24\n */\nquil.core$macros.key_as_keyword = (function quil$core$macros$key_as_keyword(){\nvar key_char = quil.core$macros.raw_key.call(null);\nvar code = quil.core$macros.key_code.call(null);\nif(cljs.core.truth_(quil.core$macros.key_coded_QMARK_.call(null,key_char))){\nreturn cljs.core.get.call(null,quil.core$macros.KEY_CODES,code,new cljs.core.Keyword(null,\"unknown-key\",\"unknown-key\",(255305911)));\n} else {\nreturn cljs.core.keyword.call(null,[cljs.core.str(key_char)].join(''));\n}\n});\n"}}